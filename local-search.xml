<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>金刚功</title>
    <link href="/2023/07/28/%E9%87%91%E5%88%9A%E5%8A%9F/"/>
    <url>/2023/07/28/%E9%87%91%E5%88%9A%E5%8A%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>强身健体 &#x3D; 合理睡眠 + 合理饮食 + 合理锻炼</p><h1 id="合理睡眠"><a href="#合理睡眠" class="headerlink" title="合理睡眠"></a>合理睡眠</h1><p>由于经常熬夜，所以最近感觉身体，好像不属于自己了的样子，因此尝试了解和修改自己的生物钟。</p><p>首先，就是改掉自己喜欢晚上做事情的原则，一日之计在于晨，把计划都罗列到早上来，即使是玩耍的计划。</p><p>22:00 - 6:00往后，这段时间必须拿来休息，睡觉时间不能晚于 23:00，否则，身体的消耗太大，45岁以后各种病都会出来。</p><p>因此要好好的睡觉。</p><h1 id="合理饮食"><a href="#合理饮食" class="headerlink" title="合理饮食"></a>合理饮食</h1><p>现代人为什么会经常睡不着觉，很精神呢？一个原因，我认为是我们大家都吃的太好了，我们现在的饮食都吃的太好，所以“五谷生精血”，导致我们十分的精力旺盛。</p><p>减轻自己身体负担的方法，就是清淡饮食，经过 2 个月的个人实践证明，每天只吃水煮菜和简单的 5~6 片肉，再加 1 两米饭，中午晚上都这样吃；然后早上吃面条。这样的吃法，每天都会精力饱满，而且不会觉得很疲惫和饥饿感。脸上看起来也会更有精神，皮肤也会变好。清淡的饮食，吃起来全是享受。</p><h1 id="合理锻炼"><a href="#合理锻炼" class="headerlink" title="合理锻炼"></a>合理锻炼</h1><p>如果是太虚了，像鄙人一样，可以考虑早起练功。张至顺老爷子虽然已经驾鹤西去，100来岁老爷子也不会骗咱们，练了两天，效果明显。</p><p>一般我跑步的话跑 10 来分钟，才会出汗淋漓，练金刚功的时候，第4部的时候就浑身大汗了，而且有点儿站着吃力。希望自己能坚持下来，也推荐出来。</p><p>不过我陷入了几个误区，后边儿要避免：</p><ul><li><p>练功前后 1 小时不吃东西；</p></li><li><p>中午、下午、晚上，不能练此功（原理不懂）；</p></li><li><p>张至顺：太阳刚出未出时练此功；</p></li></ul><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=376729571&bvid=BV1Wo4y1D7Kr&cid=369404651&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position:absolute; height: 100%; width: 100%;"> </iframe></div>]]></content>
    
    
    <categories>
      
      <category>强身健体</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强身健体</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAVA-学习总结-3</title>
    <link href="/2023/07/28/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3/"/>
    <url>/2023/07/28/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>上一篇 SAVA 中提出了体系结构，论文的结尾是完成各个层次的工作内容。本次学习自治域间的源地址验证方法和实现。</p><p>其中主要内容来自于论文：</p><ul><li><a href="./%E8%87%AA%E6%B2%BB%E5%9F%9F%E9%97%B4%E7%9C%9F%E5%AE%9E%E6%BA%90%E5%9C%B0%E5%9D%80%E9%AA%8C%E8%AF%81%E6%96%B9%E6%B3%95%E5%8F%8A%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0_%E6%9D%8E%E6%9D%B0.pdf">自治域间真实源地址验证方法及技术实现_李杰</a></li></ul><p>这篇论文主要说明对真实 IPv6 源地址的网络寻址体系结构进行实现策略和关键进行说明，并详细介绍自治域间真实源地址验证方法的原理和机制和技术实现。</p><h1 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h1><p>这个部分仍然是说明解决源地址伪造问题的迫切性，主要由 3 个层面：</p><ul><li><p>安全层面：DoS、DDoS、僵尸网络（botnet）等多种攻击依赖于地址欺骗；</p></li><li><p>网络管理层面：源地址伪造是的网络管理者对大量攻击事件的源无法追溯和监控；</p></li><li><p>网络计量层面：管理结构无法获得准确的统计信息作为决策，垃圾流量（SPAM）使基于源地址的计费无法实现，大量伪造源地址攻击占用大量网络资源，造成大量经济损失；</p></li></ul><p>因此，确保源 IP 地址的真实性是实现可信任下一代互联网的核心问题。</p><h1 id="2、真实地址验证体系结构及实现策略"><a href="#2、真实地址验证体系结构及实现策略" class="headerlink" title="2、真实地址验证体系结构及实现策略"></a>2、真实地址验证体系结构及实现策略</h1><h2 id="2-1-体系结构"><a href="#2-1-体系结构" class="headerlink" title="2.1 体系结构"></a>2.1 体系结构</h2><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2023-08-01-11-30-39.png" alt="SAVA 源地址体系结构"></p><p>按照互联网的层次结构，SAVA 不同层次的机制分别在 <code>主机、IP 地址前缀和自治域</code> 粒度上保证源 IP 地址的真实性。</p><p>基于网络本身的分层结构，真实源地址验证体系结构被分为域间真实地址验证、域内真实源地址验证和接入子网真实地址验证 3 个层次的真实 IPv6 源地址网络寻址系统，它们有机的组合在一起，共同形成真实源地址验证框架。</p><h2 id="2-2-实现策略"><a href="#2-2-实现策略" class="headerlink" title="2.2 实现策略"></a>2.2 实现策略</h2><p>在真实源地址验证体系结构中：</p><ul><li><p>接入子网源地址验证：通过动态创建 MAC 地址、交换机端口和真实源 IP 地址间的关联，保留主机不能伪造接入子网中其他主机的地址；</p></li><li><p>域内源地址验证：域内每个路由器接口维护一个真实地址前缀表，对边缘接入网络应用如果过滤是一种解决方案</p></li><li><p>自治域间源地址验证：根据自治域邻接关系，SAVA 设计了两种生成域间验证规则的机制：</p><ul><li><p>非相邻自治域间：基于端到端轻量级签名的域间真实源地址验证方法，其思想是：将部署本方法的域组成一个信任联盟，联盟内各个域的控制服务器通过端到端的方式交互彼此的地址空间信息和协商签名信息，然后由域的边界路由器在发送的 IPv6 分组中增加 IPv6 扩展报头存放签名，并在接收的分组中检查签名是否正确。</p></li><li><p>相邻的自治域间：基于路由信息的真实源地址验证方法，其思想是：利用自治域互联关系，在自治系统边界路由器上生成与每一个路由器接口关联的真实 IPv6 源地址验证规则，并利用其对伪造 IPv6 源地址的分组进行验证检查。</p></li></ul></li></ul><h1 id="3-自治域间源地址验证方法及技术实现"><a href="#3-自治域间源地址验证方法及技术实现" class="headerlink" title="3 自治域间源地址验证方法及技术实现"></a>3 自治域间源地址验证方法及技术实现</h1><p>域间源地址验证是 SAVA 体系结构中最困难和复杂的部分，其目标是实现自治域粒度的真实源地址验证。</p><p>国际上进展：</p><p>Bremler-Barr 等人提出的 “基于源-目的自治域对应密钥的域间 IP 欺骗过滤机制 SPM”，在 SPM（Spoofing prevention method） 中每一对互为通信对端的自治域维护一对私密、唯一的密钥验证源地址的真实性，源域通过添加密钥可保证源地址的真实性，目的域通过检查密钥验证源地址的真实性。SPM 适合应用在早期的部署真实地址寻址机制的自治域较少、分布稀疏的网络中，采用该方案可实现自治域粒度的真实源地址验证。</p><p>APPA 在 SPM 基础上进行改进，其思想是：由部署验证机制的自治域作为成员单位组件一个信任联盟，联盟内每一对互为通信对端的成员自治域都各自维护有一对分别用来生成和验证标签的状态机，源域依据相应状态机生成确保源于本域的数据报文源地址真实性的标签添加在报文扩展头中，目的域依据同样的状态机去验证标签，若验证通过则判定源地址是真实可信的，从而实现源地址前缀验证。</p><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2023-08-01-15-58-51.png" alt="基于端到端轻量级标签的域间真实源地址验证方法"></p><p>如图所示，该方法实现所需要的具体各个组件。</p><h1 id="4-层次化的域间真实源地址验证方法及技术实现"><a href="#4-层次化的域间真实源地址验证方法及技术实现" class="headerlink" title="4 层次化的域间真实源地址验证方法及技术实现"></a>4 层次化的域间真实源地址验证方法及技术实现</h1><p>层次化的域间真实源地址验证方法是一种可自下而上分层级建立信任联盟、基于轻量级标签替换的自治域间真实源地址验证方法。</p><h2 id="4-1-基本思想"><a href="#4-1-基本思想" class="headerlink" title="4.1 基本思想"></a>4.1 基本思想</h2><p>该方法采用一种基于轻量级标签替换的自治域到自治域的加密认证机制，通过自下而上的分层，将部署了该方法的所有自治域（AS）划分为多层级新仍联盟，每一层级联盟可以作为成员（抽象为一个系统整体）参加更高层级的联盟，使得整个信任联盟系统构成一个具有源地址验证功能的、层次化的体系结构。</p><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3-2023-08-01-16-06-03.png" alt="基于标签替换的域间真实源地址验证方法构建的层次化的信任联盟体系结构"></p><p>如图所示，在层次化的信任联盟体系结构中，通过数据通信扩展为 3 类：</p><p>第一类，单一信任联盟数据通信，某一最低层级信任联盟内成员 AS 互为通信对端，报文仅在该联盟内部网络中交互。此类场景中，无需标签替换，只根据最低层级联盟状态机，采用传统的验证机制即可实现源地址验证。</p><p>第二类，跨信任联盟数据通信，隶属于不同层级信任联盟的 AS 互为通信对端，数据报文需要跨越联盟网络中交互，在此类数据通信场景中，处在不同层级联盟中的源 AS 和目的 AS 间无需通过建立状态机双向共享，而是通过引入 TAE 和联盟映射状态机充当跨联盟数据报文交互的 “中继代理”，完成自下而上的逐级标签替换，延续报文源地址真实性的信任关系，实现源地址验证。</p><p>第三类，非信任联盟数据通信，信任联盟中的 AS 与其他非信任联盟 AS 间进行的数据通信，在此类数据通信场景中无需源地址验证也不设计标签的任何操作。</p><h2 id="4-2-体系结构"><a href="#4-2-体系结构" class="headerlink" title="4.2 体系结构"></a>4.2 体系结构</h2><p>层次化的域间源地址验证方法，允许联盟管理结构依据实际情况灵活选取不同的划分原则和组合模式构建层次化的信任联盟体系结构。</p><p>首先以 AS 为单位成员，将部署本方法的所有 AS 按照相同属性聚合成多个最低层级信任联盟，然后再依据一定的划分原则聚合成更高层级的信任联盟，由此自下而上的不断聚合成更高层级的信任联盟。</p><h2 id="4-3-技术实现"><a href="#4-3-技术实现" class="headerlink" title="4.3 技术实现"></a>4.3 技术实现</h2><p>在控制层面，该方法需要由 RES、ACS 以及 AER&#x2F;TAER 系统工作完成验证策略的协商和决策，生成相应的验证控制规则和指令，控制数据报文的验证动作。</p><p>技术层面考虑以下 4 点关键设计：</p><ul><li><p>状态机的周期更替机制：确保生成标签在一定时期内的时效性、唯一性和可靠性；</p></li><li><p>时间同步：确保 AER、TAER 之间时间同步，实现状态机的同步；</p></li><li><p>安全信道：立足现有域间链路，采用开起 TCP 拦截和 Diffie-Hellman 协议结合的方式，通过 TCP 连接建立起验证规则信息交互的安全信道；</p></li><li><p>TAER 工作模式：允许 TAER 在进行标签替换的同时可依据网络安全等级灵活设置工作模式（直接模式或替换并验证模式）。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
      <category>SAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>SAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAVA-学习总结-2</title>
    <link href="/2023/07/27/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2/"/>
    <url>/2023/07/27/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文对 SAVA 进行详细总结，主要的结论和内容来自这两篇论文：</p><ul><li><p><a href="./%E6%9E%84%E5%BB%BA%E5%9F%BA%E4%BA%8E%E7%9C%9F%E5%AE%9EIPv6%E6%BA%90%E5%9C%B0%E5%9D%80%E9%AA%8C%E8%AF%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%8B%E4%B8%80%E4%BB%A3%E4%BA%92%E8%81%94%E7%BD%91_%E5%90%B4%E5%BB%BA%E5%B9%B3.pdf">构建基于真实IPv6源地址验证体系结构的下一代互联网_吴建平</a></p></li><li><p><a href="./SAVA.pdf">Building a next generation Internet with source address</a></p></li></ul><p>这两篇论文阐述了 SAVA 的架构和思路，奠定了 SAVA 的总体框架，值得学习和深究。</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>现有互联网的 IP 分组转发，主要基于目的 IP 地址，很少对分组的 IP 源地址的真实性进行检查，这使得分组的 IP 源地址容易伪造。网络攻击者常常通过伪造分组的 IP 源地址逃避承担责任。IP 源地址验证已经成为互联网面临的一个挑战性的问题。</p><p>目前在研究和工程领域已经有很多相关的努力，主要包括基于加密认证的技术，基于过滤的技术和基于追踪的技术。然而这些现有机制都没能在现有互联网上得到广泛的部署。不支持增量部署和缺乏对运营商的激励是主要的原因。</p><h2 id="真实-IPv6-源地址验证体系结构"><a href="#真实-IPv6-源地址验证体系结构" class="headerlink" title="真实 IPv6 源地址验证体系结构"></a>真实 IPv6 源地址验证体系结构</h2><p>文章提出了一种 “真实 IPv6 源地址验证体系结构” (SAVA: source address validation architecture)，用以在网络层提供一种透明的服务，以确保互联网中转发的每一个分组都使用 “真实IP 源地址”。</p><p>“真实 IP 源地址” 三重含义：</p><ul><li>经授权的：IP 源地址必须是经互联网 IP 地址管理机构分配授权的，不能伪造。</li><li>唯一的：IP 源地址必须全局唯一，除了对全局唯一性不做要求的特殊情形以外。</li><li>可追溯性：网络中转发的 IP 分组，可以根据其 IP 源地址找到其所有者和位置。</li></ul><p>这一体系结构可以使得网络中，携带真实源 IP 地址的分组容易被最终，携带 IP 源地址的分组无法转发，被丢弃。</p><p>此外，该体系结构拥有以下好处：</p><ul><li><p>可以实现更惊喜粒度的网络管理和计费：由于实现全局唯一的 IP 地址到用户应用的映射更加容易，网络管理系统可以更容易对端到端的应用实现计费，如同现有的电话网络一样。</p></li><li><p>安全认证可以得到一定程度的简化：传统的认证多基于加密方法。如果实现真实 IPv6 源地址验证体系结构，真实 IPv6 源地址和上层实体间的映射可以为认证提供帮助。</p></li><li><p>新的互联网应用：例如 P2P 应用和基于 SIP 的大规模多媒体引用，由于采用了全局唯一的 IP 源地址，可以简化实现，提高性能，更方便部署。</p></li></ul><h1 id="1-相关研究"><a href="#1-相关研究" class="headerlink" title="1 相关研究"></a>1 相关研究</h1><p>与源地址验证相关的研究工作可以分为 3 类：加密认证的方法、预先的过滤方法、事后的追踪方法。</p><h2 id="加密认证方法"><a href="#加密认证方法" class="headerlink" title="加密认证方法"></a>加密认证方法</h2><ul><li><p>IPSec：端到端方法，大规模部署依赖于 PKI；</p></li><li><p>SPM：自治系统到自治系统的方法，每一对互相通信的自治系统拥有一堆单独的临时的密钥做地址验证；</p></li></ul><h2 id="过滤方法"><a href="#过滤方法" class="headerlink" title="过滤方法"></a>过滤方法</h2><p>过滤方法是一种预先处置的方法，它利用预先生成的验证规则，在路由器上过滤伪造源地址的分组。</p><ul><li><p>入口过滤：需要在边界网络全局部署；</p></li><li><p>DPF：将验证规则的部署位置从边界网络扩展到了核心网络，并且支持增量部署，但是它只能获得 IP 前缀粒度的地址验证；</p></li><li><p>SAVE：设计了一个新的协议在全网传递源地址验证规则，但是协议不分层，可部署性和可扩展性收到制约</p></li></ul><p>这些过滤方法的一个共同问题在于，他们无法处理一个接入子网内的地址伪造的情形，那时 IP 地址前缀是相同的、真实的。</p><h2 id="追溯方法"><a href="#追溯方法" class="headerlink" title="追溯方法"></a>追溯方法</h2><p>追溯方法是一种事后处置的方法，分组转法师，记录路径信息，并从目的端追踪伪造源地址分组的起源。</p><ul><li><p>SPIE：在路由器上记录路径信息；</p></li><li><p>iTrace 和 iTrace-CP：利用 ICMP 消息保留路径信息；</p></li><li><p>PPM 和 DPM：直接使用 IP 分组记录路径信息；</p></li></ul><p>事后处置的设计思想，复杂的追溯算法是这类方法的主要缺陷。</p><h1 id="2-真实-IPv6-源地址验证体系结构"><a href="#2-真实-IPv6-源地址验证体系结构" class="headerlink" title="2 真实 IPv6 源地址验证体系结构"></a>2 真实 IPv6 源地址验证体系结构</h1><h2 id="2-1-设计原则"><a href="#2-1-设计原则" class="headerlink" title="2.1 设计原则"></a>2.1 设计原则</h2><p>真实 IPv6 源地址验证体系结构的设计中，考虑以下设计原则：</p><ul><li><p>性能。真实 IPv6 源地址验证体系结构的部署不应降低现有路由和交换设备的分组转发<br>性能。 </p></li><li><p>可扩展性。真实 IPv6 源地址验证体系结构应该支持在整个互联网的大规模部署。 </p></li><li><p>多重防御。真实 IPv6 源地址验证体系结构应该支持分层的、部署在网络不同位置的、满足不同粒度需求的源地址验证。 </p></li><li><p>松耦合。真实 IPv6 源地址验证体系结构应允许不同运营商可以采用各自不同的实现，系统各个部分相互独立，每个部分可以实现各自粒度的真实地址检查，每个部分的功能不依赖其他部分的实现。 </p></li><li><p>支持增量部署。真实 IPv6 源地址验证体系结构应该支持在全网渐进的、增量的部署.部分部署时仍可以获得一定程度的真实源地址验证效果。 </p></li><li><p>激励运营商。真实 IPv6 源地址验证体系结构的设计应体现谁部署谁受益的原则，部署真实 IPv6 源地址验证机制的运营商可以更加容易地发现和追踪网络中伪造源地址的分组，保护自己的网络。</p></li></ul><h2 id="2-2-体系结构"><a href="#2-2-体系结构" class="headerlink" title="2.2 体系结构"></a>2.2 体系结构</h2><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-2023-07-27-11-30-45.png" alt="真实 IPv6 源地址验证体系结构"></p><p>要实现全完的真实源 IPv6 源地址验证，依赖单一的方法，部署在单一层次的位置是不现实的。如图所示，IPv6 源地址验证体系结构分为 3 个层次：接入子网真实 IPv6 源地址验证、自治系统内真实 IPv6 源地址验证、自治系统间真实 IPv6 源地址验证。</p><h3 id="2-2-1-接入子网真实-IPv6-源地址验证"><a href="#2-2-1-接入子网真实-IPv6-源地址验证" class="headerlink" title="2.2.1 接入子网真实 IPv6 源地址验证"></a>2.2.1 接入子网真实 IPv6 源地址验证</h3><p>这个部分，实现端系统 IP 地址一级的细粒度的真实 IPv6 源地址验证。如果没有这一级验证，一个主机仍然可以伪造 IP 前缀相同的同意子网内其他主机的地址。</p><p>接入子网真实 IPv6 源地址验证具有一下特点：</p><ul><li>所有相关网络设备在同一个网络管理结构管理控制下；</li><li>解决方案与接入子网的管理分配和控制策略密切相关；</li><li>解决方案与端系统的接入方式密切相关；</li></ul><p>针对目前网络中大量端系统通过交换机接入网络的情形，采用的解决方案的主要是思想是在交换机的端口和真实有效的 IP 地址之间实现动态绑定。</p><h3 id="2-2-2-自治系统内真实-IPv6-源地址验证"><a href="#2-2-2-自治系统内真实-IPv6-源地址验证" class="headerlink" title="2.2.2 自治系统内真实 IPv6 源地址验证"></a>2.2.2 自治系统内真实 IPv6 源地址验证</h3><p>自治系统内实现 IP 地址前缀粒度的真实 IPv6 源地址验证。</p><p>因为自治系统内的网络设备都在同一个管理结构管理之下，主要的验证机制只需要部署在运营商网络和接入网络的边界。</p><p>主要的解决思想是，在路由器上部署入口过滤验证规则，这些规则把每一个路由器的接口和一组真实有效的 IP 地址前缀关联起来。</p><p>入口过滤是一个主要的采用的方案。</p><h3 id="2-2-3-自治系统间真实-IPv6-源地址验证"><a href="#2-2-3-自治系统间真实-IPv6-源地址验证" class="headerlink" title="2.2.3 自治系统间真实 IPv6 源地址验证"></a>2.2.3 自治系统间真实 IPv6 源地址验证</h3><p>这个部分最复杂，目标是实现自治系统粒度的真实 IPv6 源地址验证。</p><p>自治系统间真实 IPv6 源地址验证具有如下特点：</p><ul><li><p>需要在不同自治系统间协同工作；</p></li><li><p>机制必须简单轻权，不给自治系统间的高速通信带来明显影响；</p></li></ul><p>在互联网的边界，实现细粒度的端系统 IP 地址一级的验证；在高流量的核心网络中，通过简单并且可扩展的解决方案实现粗粒度的纸质系统一级的验证。</p><h2 id="2-3-支持真实-IPv6-源地址验证体系结构的网络节点"><a href="#2-3-支持真实-IPv6-源地址验证体系结构的网络节点" class="headerlink" title="2.3 支持真实 IPv6 源地址验证体系结构的网络节点"></a>2.3 支持真实 IPv6 源地址验证体系结构的网络节点</h2><p>真实 IPv6 源地验证体系结构通过部署在各个网络节点上的解决方案来上实现。这些网络节点可以是交换机，路由器或者网关。</p><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-2023-07-27-12-03-02.png" alt="支持真实源 IPv6 源地址验证体系结构的网络节点结构"></p><p>如图显示了一个支持真实 IPv6 源地址验证体系结构的网络节点的结构，逻辑部分组成有：</p><ul><li><p>转发信息数据库：保存分组转发的路由和交换信息；</p></li><li><p>源地址验证信息数据库：保存实现源地址验证的验证规则信息；</p></li><li><p>路由和交换协议：在网络节点间相互交换转发信息，更新转发信息数据库；</p></li><li><p>源地址验证协议：在网络节点间互相交换源地址验证信息，更新源地址验证信息数据库；</p></li><li><p>转发引擎：依照转发信息数据库，转发 IP 分组；</p></li><li><p>源地址验证引擎：依照源地址验证数据库检查待转发分组源地址的真实性，只有检查源地址真实，才交友转发引擎转发；</p></li></ul><p>转发信息数据库， 路由和交换协议,以及转发引擎是现有转发功能的主要组成部分。而源地址验证信息数据库， 源地址验证协议和源地址验证引擎则实现了新增的源地址验证功能.</p><p>源地址验证协议模块是一个控制平面的模块，可以通过软件实现，或者实现在现有网络路由交换设备中，或者实现在单独的控制服务器中。源地址验证引擎模块是一个数据平面的模块，这一模块通常实现在路由和交换设备的线卡中。</p><h1 id="3-自治系统间真实-IPv6-源地址验证"><a href="#3-自治系统间真实-IPv6-源地址验证" class="headerlink" title="3 自治系统间真实 IPv6 源地址验证"></a>3 自治系统间真实 IPv6 源地址验证</h1><h2 id="3-1-方案概述"><a href="#3-1-方案概述" class="headerlink" title="3.1 方案概述"></a>3.1 方案概述</h2><p>所有的支持真实 IPv6 源地址验证体系结构的自治系统共同组成一个信任联盟，自治系统间真实 IPv6 源地址验证可以划分为两种情形：</p><ul><li><p>两个支持真实 IPv6 源地址验证体系结构的自治系统直接互联，简称 “ 直接互联”。</p></li><li><p>两个支持真实 IPv6 源地址验证体系结构的自治系统不直接互联，中间经过不部署真实 IPv6 源地址验证体系结构的自治系统，简称 “非直接互联”。</p></li></ul><p>要生成源地址验证信息数据库中的验证规则，在网络设备（路由器，交换机）间需要交换信息，根据这些交换信息类别的不同，相应的真实 IPv6 源地址验证机制可以划分为两类：</p><ul><li><p>基于路径或路由信息的机制：验证规则的生成来自分组转发经过的路径或路由信息。这类方法的好处是验证规则直接以 IP 地址前缀的形式表示，缺陷是生成验证规则的网络节点之间需要直接互联，共同配合生成验证规则。</p></li><li><p>基于标记或签名信息的机制：通过增加副驾的标记或者签名信息来验证 IP 分组源地址的真实性。这类方案的好处是生成验证规则的网络节点之间不需要直接互联，缺陷是签名和标记信息增加了额外的处理开销。</p></li></ul><p>论文主要关注 “直接互联” 的情形，然后提供了 “非直接互联” 的情形的解决方案。</p><h2 id="3-2-直接互联"><a href="#3-2-直接互联" class="headerlink" title="3.2 直接互联"></a>3.2 直接互联</h2><p>对于里那个支持真实 IPv6 源地址验证体系结构的自治系统直接互联的情形，我们设计了一种基于自治系统互联关系生成验证规则的方案。</p><p>这一验证方案的思路如下：</p><ul><li><p>自治系统边界路由器的每一个接口建立一个验证规则表，这个验证规则表，将一组真实有效的 IP 地址前缀和路由器接口关联起来。</p></li><li><p>验证规则的生成是基于自治系统互联关系。</p></li><li><p>自治系统的互联关系决定了域间路由的策略，域间路由策略决定了 BGP 路由的配置，而 BGP 路由表是生成域间转发表的主要信息。</p></li><li><p>自治系统互联关系相对稳定。</p></li></ul><p>系统主要由 3 个部分组成：验证规则生成引擎（VRGE），验证引擎（VE）和 AS 编号到 IPv6 地址前缀映射服务器（AIMS），如图，验证规则（VR）由验证规则生成引擎生成，并最终以 IPv6 地址前缀的形式表示。</p><ul><li><p>VRGE 生成 VR，每一个支持真实 IPv6 源地址验证体系结构的自治系统有一个 VRGE，它和其他自治域的 VRGE 通信，交换 VR 信息；它和本自治域的 VE 通信，配置 VR 信息。</p></li><li><p>VE 加载 VRGE 生成的 VR，并利用这些 VR 验证转发的分组。</p></li><li><p>AIMS 维护者自治系统信号到其对应拥有的 IPv6 地址前缀信息的映射。</p></li></ul><p>自治系统（AS）间有 4 中关系：服务者到客户、客户到服务者、对等互联、兄弟互联。</p><p>对于一个 AS，VRO、VRC、VRS、VRP 和 VRE 分别被定义为来自本自治域、客户自治域、兄弟互联自治域、服务者自治域和对等互联自治域的验证规则。</p><p>EVRC，EVRS，EVRP 和 EVRE 分别被定义为一个自治系统要向它的客户自治域、兄弟互联自治域、服务者自治域和对等互联自治域传递的 VR。</p><ul><li>EVRC&#x3D;VRO ∪ VRC ∪ VRS ∪ VRP ∪ VRE；</li><li>EVRP&#x3D;VRO ∪ VRC ∪ VRS；</li><li>EVRS&#x3D;VRO ∪ VRC ∪ VRS ∪ VRP ∪ VRE；</li><li>EVRE&#x3D;VRO ∪ VRC ∪ VRS。</li></ul><p>即一个自治系统会把它拥有的、它客户的自治系统拥有的、它服务者自治系统拥有的、它兄弟互联自治系统拥有的、它对等互联自治系统拥有的 IP 地址前缀集合传递给它的客户自治系统和兄弟互联自治系统。而只将它所拥有的、它客户自治系统拥有的、它兄弟互联自治系统拥有的 IP 地址前缀集合传递给他的服务者自治系统和对等互联自治系统。</p><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-2023-07-27-16-01-19.png" alt="基于自治系统互联关基的自治系统间 IP 源地址验证方法"></p><p>基于 AIMS 的支持，只有自治系统编号在不同 VRGE 间传递，并在 VRGE 处被映射为地址前缀集合，降低了附加协议的传输开销。</p><p>自治系统互联关系相对稳定，避免了路由震荡带来的影响，只有当自治系统互联关系发生变化或者一个自治系统所拥有的地址前缀集合发生变化时，才会引起 VR 的更新。</p><h2 id="3-3-非直接互联"><a href="#3-3-非直接互联" class="headerlink" title="3.3 非直接互联"></a>3.3 非直接互联</h2><p>对于两个支持真实 IPv6 源地址验证体系结构的自治系统不直接互联的情形，使用一种基于轻权标记的自治系统间真实 IPv6 源地址验证方法。</p><p>基本思想如下：</p><ul><li><p>对于任何一对不直接相邻却都属于信任联盟的自治系统，它们拥有一对单独的零时标记。</p></li><li><p>当一个分组离开它自己发出的源自治系统，且目的地址也在另一个属于信任联盟的自治系统内，源自治系统的边界路由器依据目的地址，查询预先协商好的标记表，并把这个标记加在分组的一个 IPv6 协议扩展头上。</p></li><li><p>当一个分组到达目的自治系统，如果分组的源地址属于一个在信任联盟内的自治系统，目的自治系统的边界路由器根据分组 IP 源地址查找预先协商好的标记表，如果匹配，则去掉标记后转发给目的端，如果不匹配，则丢弃分组。</p></li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-2023-07-28-09-28-10.png" alt="基于标记的自治系统间真实 IPv6 源地址验证方法"></p><p>系统主要 3 个组成部分：注册服务器（REG）、自治系统控制服务器（ACS）和自治系统边界路由器（AER）</p><ul><li><p>REG 维护部署真实 IPv6 源地址验证体系结构的信任联盟的自治系统成员列表。响应 ACS 的请求，提供信任联盟成员列表，当成员列表发生变化时，通知 ACS。</p></li><li><p>每一个不部署这一机制的自治系统有一个 ACS。它和注册服务器通信获得更新的信任联盟成员列表，它和其他自治系统的 ACS 通信来交换协商标记信息，它和所有的边界路由器通信来配置由标记信息组成的验证规则。</p></li><li><p>AER 则负责在发送端将标记添加到分组中或者在接收端将标记检查和移除。</p></li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2-2023-07-28-09-33-35.png" alt="携带标记的 IPv6 扩展头格式"></p><p>标记附加在 IPv6 分组的一个扩展头上，目前使用 hop-by-hop 扩展头，运用一个 128 位的随机数来做标签。</p><p>论文中提到，在论文的文献 2 中，有猜测标记的方法，因此要增大标记长度和动态更新标记来增加标记的复杂性。</p><h1 id="下一步工作"><a href="#下一步工作" class="headerlink" title="下一步工作"></a>下一步工作</h1><p>论文中描述，接下来的工作是为支持真实 IPv6 源地址验证体系结构的自治系统建立合适的信任模型，并进一步改进和完善体系结构中各层次的解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
      <category>SAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>SAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW4-lazy-page-allocation</title>
    <link href="/2023/07/22/HW4-lazy-page-allocation/"/>
    <url>/2023/07/22/HW4-lazy-page-allocation/</url>
    
    <content type="html"><![CDATA[<p>操作系统可以使用页表硬件的许多巧妙技巧之一是堆内存的延迟分配。xv6 应用程序使用 sbrk() 系统调用向内核请求堆内存。在我们提供给的内核中，sbrk() 分配物理内存并将其映射到进程的虚拟地址空间。有些程序分配内存但从不使用它，例如实现大型稀疏数组。复杂的内核会延迟每个内存页面的分配，直到应用程序尝试使用该页面（如缺页错误）。在本练习中，将此延迟分配功能添加到 xv6。</p><p>作业链接：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html</a></p><h1 id="Part-One-Eliminate-allocation-from-sbrk"><a href="#Part-One-Eliminate-allocation-from-sbrk" class="headerlink" title="Part One: Eliminate allocation from sbrk()"></a>Part One: Eliminate allocation from sbrk()</h1><p>从 sbrk(n) 系统调用中，删除页分配。系统调用 sbrk(n) 增加进程空间 n bytes，然后返回新分配的区域的起始地址。</p><p>修改代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  myproc()-&gt;sz += n;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW4-lazy-page-allocation-2023-07-22-21-42-15.png" alt="结果"></p><h1 id="Part-Two-Lazy-allocation"><a href="#Part-Two-Lazy-allocation" class="headerlink" title="Part Two: Lazy allocation"></a>Part Two: Lazy allocation</h1><p>在 trap.c 中，添加对页错误的处理。</p><p>在 trap() 函数中，命名 char *mem，然后映射分配的物理页；如果映射之后还出现缺页错误，则会反复触发 T_PGFLT，然后反复分配一个页面来映射。</p><p>同时，将 mappages 的 static 删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_PGFLT:<br>   mem = kalloc();<br>   <span class="hljs-keyword">if</span>(mem != <span class="hljs-number">0</span>)&#123;<br>       uint va = PGROUNDDOWN(rcr2());<br>       <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span> ,PGSIZE);<br>       <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, uint size, uint pa, <span class="hljs-type">int</span> perm)</span>;<br>       <span class="hljs-keyword">if</span>(mappages(myproc()-&gt;pgdir, (<span class="hljs-type">void</span>*)va, PGSIZE, V2P(mem),  PTE_W|PTE_U)&gt;=<span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">break</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW4-lazy-page-allocation-2023-07-22-22-16-11.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-寻找两个正序数组的中位数</title>
    <link href="/2023/07/21/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2023/07/21/4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">https://leetcode.cn/problems/median-of-two-sorted-arrays/</a></p><p><code>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></p><p>给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。</p><p>算法的时间复杂度应该为 $ O(\log (m+n))$。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">示例 1：<br><br>输入：nums1 = [1,3], nums2 = [2]<br>输出：2.00000<br>解释：合并数组 = [1,2,3] ，中位数 2<br>示例 2：<br><br>输入：nums1 = [1,2], nums2 = [3,4]<br>输出：2.50000<br>解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5<br><br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">提示：<br><br>nums1.length == m<br>nums2.length == n<br>0 &lt;= m &lt;= 1000<br>0 &lt;= n &lt;= 1000<br>1 &lt;= m + n &lt;= 2000<br>-106 &lt;= nums1[i], nums2[i] &lt;= 106<br><br></code></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>中位数将整个合起来的数组分为两个部分，如果是偶数个，那么中间两个数的平均值；如果是奇数个，那么是中间一个数字。</p><p>因此可以进行二分搜索，怎么搜成了关键问题：一种思路是直接搜索中位数的值，然后判断符不符合，但是好像不满足题干要求；另一种是搜索数组内的中位数，构造很困难。</p><p>官方思路学习: <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/">https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/</a></p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">size</span>() &gt; nums2.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findMedianSortedArrays</span>(nums2,nums1);<br>        &#125;<br><br>        <span class="hljs-type">int</span> m = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> mid1,mid2;<br>        <span class="hljs-type">double</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = m;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; <br>        <span class="hljs-type">int</span> nums1_i_1 = <span class="hljs-number">0</span>, nums1_i = <span class="hljs-number">0</span>, nums2_j_1 = <span class="hljs-number">0</span>, nums2_j = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            i = (left + right) / <span class="hljs-number">2</span>;<br>            j = ( m + n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - i;<br><br>            nums1_i_1 = (i==<span class="hljs-number">0</span>?INT_MIN:nums1[i<span class="hljs-number">-1</span>]);<br>            nums1_i = (i==m?INT_MAX:nums1[i]);<br><br>            nums2_j_1 = (j==<span class="hljs-number">0</span>?INT_MIN:nums2[j<span class="hljs-number">-1</span>]);<br>            nums2_j = (j==n?INT_MAX:nums2[j]);<br><br>            <span class="hljs-keyword">if</span>(nums1_i_1 &lt;= nums2_j)&#123;<br>                mid1 = <span class="hljs-built_in">max</span>(nums1_i_1, nums2_j_1);<br>                mid2 = <span class="hljs-built_in">min</span>(nums1_i, nums2_j);<br>                left = i + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = i - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(( m + n ) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            ans = (mid1 + mid2) / <span class="hljs-number">2.0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ans = mid1;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-无重复字符串的最长子串</title>
    <link href="/2023/07/21/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2023/07/21/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p><p><code>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></p><p>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">示例 1:<br><br>输入: s = &quot;abcabcbb&quot;<br>输出: 3 <br>解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。<br>示例 2:<br><br>输入: s = &quot;bbbbb&quot;<br>输出: 1<br>解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。<br>示例 3:<br><br>输入: s = &quot;pwwkew&quot;<br>输出: 3<br>解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。<br><br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">提示：<br><br>0 &lt;= s.length &lt;= 5 * 104<br>s 由英文字母、数字、符号和空格组成<br><br></code></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>双指针查找：</p><ul><li>右指针不断往右扩充新的字符</li><li>左指针从左边儿不断删除字符</li></ul><p>注意：所有的变量需要初始化，否则会出现未知错误。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        std::map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-keyword">while</span>(right&lt;len &amp;&amp; mp[s[right]] == <span class="hljs-number">0</span>)&#123;<br>                mp[s[right]] = <span class="hljs-number">1</span>;<br>                right ++;<br>            &#125;<br>            tmp = right - left;<br>            <span class="hljs-keyword">if</span>(ans &lt; tmp)&#123;<br>                ans = tmp;<br>            &#125;<br>            mp[s[left]]  = <span class="hljs-number">0</span>;<br>            left ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SAVA 学习总结 1</title>
    <link href="/2023/07/20/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1/"/>
    <url>/2023/07/20/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1/</url>
    
    <content type="html"><![CDATA[<h1 id="源地址验证-SAV-技术白皮书学习"><a href="#源地址验证-SAV-技术白皮书学习" class="headerlink" title="源地址验证 SAV 技术白皮书学习"></a>源地址验证 SAV 技术白皮书学习</h1><p>源地址验证 SAVA：<a href="./6W100.pdf">白皮书</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="1-1-产生背景"><a href="#1-1-产生背景" class="headerlink" title="1.1 产生背景"></a>1.1 产生背景</h3><p>互联网设计之处没有考虑网络成员是否可信。网络设备只检验目的 IPv6 地址，并进行报文的转发，而不对转发报文的 IPv6 源地址的真实性进行任何验证，这使得伪造 IPv6 源地址的攻击大量出现。</p><p>基于 IPv6 源地址的网络计费、管理、监控和安全认证都无法正常进行，对互联网基础设施和上层应用造成了严重危害。</p><p>SAV（Source Address Validation，源地址验证）是一种真实 IPv6 源地址验证体系结构，能够实现在 IPv6 环境下的 IPv6 源地址验证、真实身份溯源，对非法攻击流量进行阻断，提升 IPv6 网络的安全性。</p><h3 id="1-2-技术优点"><a href="#1-2-技术优点" class="headerlink" title="1.2 技术优点"></a>1.2 技术优点</h3><p>SAV 技术能够在互联网中实现不同粒度的 IPv6 源地址验证，对互联网的安全和应用提供如下便利：</p><ul><li><p>易于追踪攻击事件，定位攻击者。确保源地址的真实性，可以防止攻击者隐匿自己的身份和位置，使得攻击行为的溯源变得简单。</p></li><li><p>可以解决基于伪造源地址的攻击。如今许多大规模的网络攻击手段都基于伪造源地址技术（比如 DDoS），消除了伪造源地址的报文即消除了这些攻击，网络环境将变得更加安全。</p></li><li><p>支持基于源地址的网络计费和管理。报文源地址的真实性，为基于源地址的网络计费、管理、监控以及安全认证等业务正常准确运行提供了保证。</p></li></ul><h3 id="1-3-体系结构"><a href="#1-3-体系结构" class="headerlink" title="1.3 体系结构"></a>1.3 体系结构</h3><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-12-03-23.png" alt="SAV 体系结构"></p><p>SAV 支持分层部署在网络的不同位置、满足不同粒度需求的原地址验证。根据在网络中部署位置的不同，SAV 体系包含如下三种技术：</p><ul><li><p>SAVI(Source Address Validation Improvement，源地址有效性验证)：部署在接入网，在接入层面提供主机粒度的源地址验证，保证接入主机合法性。</p></li><li><p>SAVA(Source Address Validation Architecture，源地址验证架构)：部署在骨干网连接接入网的边界设备上，在管理域内提供 IPv6 前缀粒度的保护能力，以保护核心设备不被仿冒源地址的非法主机攻击。</p></li><li><p>SMA(State Machine based Anti-spoofing，基于状态机的伪造源地址检查)：部署在 AS 间，在 AS 域间提供 AS 粒度的源地址验证能力，以保护本 AS 内的主机和服务器不被仿冒源地址的非法主机攻击。</p></li></ul><h2 id="2-SAVI-技术实现"><a href="#2-SAVI-技术实现" class="headerlink" title="2 SAVI 技术实现"></a>2 SAVI 技术实现</h2><h3 id="2-1-SAVI-简介"><a href="#2-1-SAVI-简介" class="headerlink" title="2.1 SAVI 简介"></a>2.1 SAVI 简介</h3><p>SAVI 功能可以用于过滤接收口上收到的 IPv6 报文，可以防止 IPv6 源地址非法的 DHCPv6 协议报文、ND 协议报文和 IPv6 数据报文形成攻击。</p><p>配合其他安全功能，可在设备上生成 IPv6 地址与客户端接入端口的绑定表项，根据该绑定表项对报文 IPv6 源地址进行检查。如果报文信息与某绑定表项匹配，则认为该报文为合法报文，正常转发；否则将该报文丢弃。</p><p>与 SAVI 配合使用的安全功能包裹 DHCPv6 Snooping、ND Snooping 和 IP Source Guard 中 IPv6 静态绑定表项功能。</p><ul><li><p>DHCPv6 Snooping 是 DHCPv6 的一种安全特性，用来保证客户端从合法的服务器获取 IPv6 地址，并可以记录 DHCPv6 客户端 IPv6 地址与 MAC 地址的对应关系。</p></li><li><p>ND Snooping 功能用于二层交换网络环境，设备通过侦听 ND 或者数据报文来创建 ND Snooping 表项，该表项内容包括报文的源 IPv6 地址、源 MAC 地址、所属 VLAN 和报文入端口等信息。</p></li><li><p>IP Source Guard 功能用于对接口收到的报文进行过滤控制，通常配置在接入用户侧的接口上，以防止非法用户报文通过，从而限制了对网络资源的非法使用（比如非法主机仿冒合法用户 IP 接入网络），提高了接口的安全性。</p></li></ul><h3 id="2-2-SAVI-运行机制"><a href="#2-2-SAVI-运行机制" class="headerlink" title="2.2 SAVI 运行机制"></a>2.2 SAVI 运行机制</h3><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-15-44-50.png" alt="SAVI 运行机制"></p><p>如图所示，SAVI 与 DHCPv6 Snooping 配合使用。 DHCPv6 client1 通过 DHCPv6 自动方式获取 IPv6 地址， Switch 上开启了 DHCPv6 Snooping 功能和 SAVI 功能。</p><ul><li><p>1、DHCPv6 client1 广播 DHCPv6 报文，Switch 将请求报文通过信任端口发送给 DHCPv6 Server。DHCPv6 Server 将含有 IPv6 地址信息的 DHCPv6 Reply 报文回复给 Switch。</p></li><li><p>2、Switch 上的配置的 DHCPv6 Snooping 功能通过监听 DHCPv6 client1 与 DHCPv6 Server 之间交互的 DHCPv6 报文，记录 DHCPv6 Snooping 表项，该表项包括 DHCPv6 client1 的 MAC 地址、获得到的 IPv6 地址、Switch 与 DHCPv6 client1 连接的端口及该端口所属的 VLAN 等信息。</p></li><li><p>3、Switch 根据记录的 DHCPv6 Snooping 表项信息生成 DHCPv6 Snooping 绑定表项。比如，Switch 通过监听 client1 和 DHCPv6 Server 之间的 DHCPv6 报文，获取到 client1 的 MAC 地址为 2-2-2、client1 从 DHCPv6 server 分配到的 IPv6 地址为 100::1、Switch 与 client1 相连的接口为 Inerface A、Interface A 所属 VLAN 为 VLAN 10，根据这些信息生成了一条 DHCPv6 Snooping 绑定表项。</p></li><li><p>4、假设此时 client2 想要仿冒 client1 的 IPv6 源地址发送攻击报文，Switch 收到报文后，查找 DHCPv6 Snooping 的绑定表项发现没有与之匹配的表项，无法通过报文合法性检查，因此该报文将被丢弃，防止了非法报文形成的攻击。</p></li></ul><h3 id="2-3-SAVI-典型应用场景"><a href="#2-3-SAVI-典型应用场景" class="headerlink" title="2.3 SAVI 典型应用场景"></a>2.3 SAVI 典型应用场景</h3><ul><li>1.DHCPv6-Only 场景</li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-16-53-35.png" alt="DHCPv6-Only 场景典型组网图"></p><ul><li>2.SLAAC-Only</li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-16-54-18.png" alt="SLAAC-Only 场景典型组网图"></p><ul><li>3.DHCPv6 与 SLAAC 混合场景</li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-16-54-51.png" alt="DHCPv6 与 SLAAC 混合场景典型组网图"></p><h2 id="3-SAVA-技术实现"><a href="#3-SAVA-技术实现" class="headerlink" title="3 SAVA 技术实现"></a>3 SAVA 技术实现</h2><h3 id="3-1-SAVA产生背景"><a href="#3-1-SAVA产生背景" class="headerlink" title="3.1 SAVA产生背景"></a>3.1 SAVA产生背景</h3><p>在 IPv6 网络中，IPv6 uRPF（unicast Reverse Path Forwarding，单播反向路径转发）功能可以用来防范基于 IPv6 源地址欺骗的攻击。在多接入（同一接入网络通过多台边界设备接入骨干网）的组网中，当出现路由不对称（即报文进入设备的入接口和设备去往报文 IPv6 源地址的出接口不一致）时，若在边界设备 A 和 B 的 Interface 1 接口上均开启严格型 uRPF 功能，边界设备 A 和 B 会将接入网络中合法的用户报文错误地判断为 IPv6 源地址伪造报文，将其丢弃。</p><p>SAVA 可以解决此类场景下合法报文被误判为伪造报文的问题。</p><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-18-46-37.png" alt="SAVA 产生背景"></p><h3 id="3-2-SAVA-简介"><a href="#3-2-SAVA-简介" class="headerlink" title="3.2 SAVA 简介"></a>3.2 SAVA 简介</h3><p>SAVA 是一种根据设备的路由信息检查攻击报文的技术，用来防范基于 IPv6 源地址欺骗的攻击，主要部署在与接入网相连的骨干网内边界设备上。在设备的接入网侧接口上开启 SAVA 功能后，设备会为该接入网络中的所有的网络前缀生成 SAVA 表项。该接口收到 IPv6 报文后，如果存在报文 IPv6源地址对应的 SAVA 表项，则认为该 IPv6 源地址合法，转发该报文；否则，表示报文 IPv6 源地址不应该存在于接入网络中，报文非法，被丢弃。</p><h3 id="3-3-SAVA-运行机制"><a href="#3-3-SAVA-运行机制" class="headerlink" title="3.3 SAVA 运行机制"></a>3.3 SAVA 运行机制</h3><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-18-48-38.png" alt="SAVA 表项生成过程"></p><p>边界设备 A 和边界设备 B 各自与接入网相连的接口上均开启 SAVA 功能，同时边界设备 B 上配置了同步远端路由条目的 Tag。以边界设备 B 为例，SAVA 表项生成过程如图所示，分为如下几个步骤：</p><ul><li><p>1、边界设备 A 和 B 分别从本地学习的、到达接入网络的路由信息中获取用户前缀，这些路由信息包括与接入网络相连的直连路由、静态路由和动态路由。本例中以静态路由为例来说明。</p></li><li><p>2、边界设备 A 为本地学习的、到达接入网络的路由信息通过路由策略配置特定路由信息的 Tag，并将此路由信息引入骨干网的动态路由协议中。</p></li><li><p>3、边界设备 B 通过动态路由协议学习到设备 A 发布的带有 Tag 的路由信息。如果路由信息中的 Tag 值与边界设备 B 上配置的同步远端路由条目的 Tag 值相同，则边界设备 B 从该路由信息中获取边界设备 A 学习到的合法用户前缀信息，用于生成 SAVA 表项。</p></li><li><p>4、边界设备 B 将根据本地路由和远端同步路由获取到的所有的合法用户前缀信息来生成与该接口绑定的 SAVA 表项。SAVA 表项信息包含合法用户前缀、前缀长度和绑定的接口。</p></li></ul><h3 id="3-4-SAVA-典型应用场景"><a href="#3-4-SAVA-典型应用场景" class="headerlink" title="3.4 SAVA 典型应用场景"></a>3.4 SAVA 典型应用场景</h3><ul><li>边界设备与接入网络直接连接场景</li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-18-55-30.png" alt="边界设备与接入网络直连场景典型组网图"></p><ul><li>边界设备与接入网络非直连场景</li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-18-56-19.png" alt="边界设备与接入网案例非直连场景典型组网图"></p><ul><li>边界设备与接入网络非直连跨 AS 场景</li></ul><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-18-57-03.png" alt="边界设备与接入网络非直连跨 AS 场景典型组网图"></p><h2 id="4-SMA-技术实现"><a href="#4-SMA-技术实现" class="headerlink" title="4 SMA 技术实现"></a>4 SMA 技术实现</h2><h3 id="4-1-SMA-简介"><a href="#4-1-SMA-简介" class="headerlink" title="4.1 SMA 简介"></a>4.1 SMA 简介</h3><p>SMA 是一种 IPv6 自治系统间端到端的源地址验证方案，通过在 AS 之间建立信任联盟来进行 IPv6 源地址的验证。在地址域的边界设备 AER 上部署 SMA 功能，在 AER 上检查报文的源 IPv6 地址和报文标签，实现防止伪造源 IPv6 地址的攻击。</p><h3 id="4-2-SMA-体系结构"><a href="#4-2-SMA-体系结构" class="headerlink" title="4.2 SMA 体系结构"></a>4.2 SMA 体系结构</h3><p>SMA 体系主要由 ACS（AS Control Server，AS 控制服务器）和 AER（AS Edge Router，AS 边界路由器）构成。</p><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-23-19-22-30.png" alt="SMA 体系结构"></p><h3 id="4-3-SMA-基本概念"><a href="#4-3-SMA-基本概念" class="headerlink" title="4.3 SMA 基本概念"></a>4.3 SMA 基本概念</h3><ul><li><p>子信任联盟：彼此信任的一组AD（Addrees Domain，地址域）组成的集合，通过子信任联盟号来标识，如图中的sub-alliance 1。</p></li><li><p>信任联盟：SMA 体系中所有 AD 的集合。</p></li><li><p>AD（Address Domain，地址域）：同一个机构下所管理的所有IP 地址部署的范围，是子信任联盟管理的对象，通过地址域编号来标识，比如，上图中的AD 1101、AD 1200 和 AD 1201。同一个子联盟内的不同的地址域可以分成不同的地址域层级，最多可以划分为4 层。比如，上图中的 Level 0、Level 1 和Level 2。其中，Level 0 为最高地址级别，Level 2 为最低地址级别。例如，首先以县市为单位划分多个一级地址域，再以机构为单位划分多个二级地址域（比如学校、企事业单位），以楼宇或部门为单位划分三级地址域。</p><ul><li><p>边界地址域：当前层级的地址域中与其他层级相连的地址域。如 AD 1201。</p></li><li><p>非边界地址域：除了边界地址域的其他地址域。如 AD 1101 和 AD 1200。</p></li></ul></li></ul><p>当一个地址域划分了更低级别的地址域后，原地址域中所有的设备都必须从属于更低级别的地址域中。如图所示，Level 0 的地址域中划分了低一级别的地址域 Level 1，那么属于 Level 0 的所有设备都必须从属于划分后的 Level 1 地址域。</p><ul><li><p>ACS（AS Control Server，AS 控制服务器）：每个层级的地址域都需要有相应的ACS，用于和其它地址域内的ACS 交互信息，并向本地址域内的AER 宣告、更新注册信息、前缀信息以及状态机信息。具体来讲，ACS 具有如下功能： </p><ul><li><p>与属于相同信任联盟中各子信任联盟的其他ACS 建立连接，交互各地址域内的IPv6 地址前缀、状态机等信息。 </p></li><li><p>向本地址域AER 宣告和更新联盟映射关系、地址前缀信息以及状态机生成的标签信息。</p></li></ul></li><li><p>AER（AS Edge Router，AS 边界路由器）：负责接收ACS 通告的IPv6 地址前缀、标签等信息，并在地址域之间转发报文。一个AER 可以是多个不同层级地址域的边界路由器。AER 上的接口可配置为如下两种类型： </p><ul><li><p>Ingress 接口：连接到本地址域内部未开启SMA 功能的路由器的接口。 </p></li><li><p>Egress 接口：连接到其他地址域的AER 的Egress 接口。</p></li></ul></li></ul><h3 id="4-4-SMA-运行机制"><a href="#4-4-SMA-运行机制" class="headerlink" title="4.4 SMA 运行机制"></a>4.4 SMA 运行机制</h3><p>SMA 通过在AER 上检查报文的源IPv6 地址和报文标签实现对伪造源IPv6 地址攻击的防御。报文在通过地址域边界时需要根据地址域级别替换SMA 标签。报文离开地址域时，根据源 IPv6 地址和当前 AER 同属的最低级别地址域替换标签；报文进入地址域时，根据目的 IPv6 地址和当前 AER 同属的最低级别地址域替换标签。 </p><h4 id="1-AER-接收报文时的处理过程"><a href="#1-AER-接收报文时的处理过程" class="headerlink" title="1. AER 接收报文时的处理过程"></a>1. AER 接收报文时的处理过程</h4><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-27-09-37-46.png" alt="AER 接收报文时的处理过程"></p><h4 id="2-AER-发送报文时的处理过程"><a href="#2-AER-发送报文时的处理过程" class="headerlink" title="2. AER 发送报文时的处理过程"></a>2. AER 发送报文时的处理过程</h4><p><img src="https://imgs.bencorn.com/imgs/SAVA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2023-07-27-09-54-45.png" alt="AER 发送报文时的处理过程"></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
      <category>SAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>SAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-2</title>
    <link href="/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2/"/>
    <url>/2023/07/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2/</url>
    
    <content type="html"><![CDATA[<p>继续计算机网络的总结，这个部分总结第二章的相关内容。本章总结计算机应用层的常见协议，并且进行一些例子的学习。</p><p>电子书附上：<a href="./network.pdf">计算机网络自顶向下（第七版）</a></p><h1 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h1><p>网络应用程序，通常是编写在多台端系统上运行，可以用 C、Java 或 Python 等编写。编写这类应用，不需要再网络核心设备如软路由或链路层交换机上运行，而只需要在端系统上运行，这样的方式使得应用软件迅速研发和部署。</p><h2 id="2-1-1-网络应用程序体系结构"><a href="#2-1-1-网络应用程序体系结构" class="headerlink" title="2.1.1 网络应用程序体系结构"></a>2.1.1 网络应用程序体系结构</h2><p>应用程序的体系结构与网络的体系结构不同。</p><ul><li><p>从应用程序研发者的角度来看，网络体系结构时固定的，并为应用程序提供了特定的服务集合。</p></li><li><p>从另一方面来看，应用程序体系结构(application architecture)由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。</p></li></ul><p>选择应用程序体系结构时，应用程序研发者可能利用现代网络应用程序中所使用的两种主流体系结构之一：客户-服务器体系结构或对等(P2P)体系结构。</p><h3 id="客户-服务器体系结构"><a href="#客户-服务器体系结构" class="headerlink" title="客户-服务器体系结构"></a>客户-服务器体系结构</h3><p>在客户-服务器体系结构(client-server architecture)中，有一个总是打开的主机称为服务器，服务器服务来自许多其他客户的主机请求。</p><p>具有客户-服务器体系结构的应用程序有：Web、FTP、Telnet、电子邮件</p><h3 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h3><p>在一个P2P体系结构(P2P architecture)中，对位于数据中心的专用服务器有最小的(或者没有)依赖。相反，应用程序在间接连接的主机之间使用直接通信，这些主机对被称为对等方。</p><p>流行的流量密集型应用都是P2P体系结构：文件共享(BitTorrent)、对等方协助下载加速器(迅雷)、因特网电话和视频会议(如Skype)。</p><p>P2P体系结构拥有特性——自扩展性。</p><p>例如,在一个P2P文件共享应用中，尽管每个对等方都由于请求文件产生工作负载，但每个对等方通过向其他对等方分发文件也为系统增加服务能力。P2P体系结构也是有成本效率的, 因为它们通常不需要庞大的服务器基础设施和服务器带宽（这与具有数据中心的客户-服务器设计形成鲜明对比）。然而，未来P2P应用由于高度非集中式结构，面临安全性、性能和可靠性等挑战。</p><h2 id="2-1-2-进程通信"><a href="#2-1-2-进程通信" class="headerlink" title="2.1.2 进程通信"></a>2.1.2 进程通信</h2><p>在构建网络应用程序钱，需要对多个端系统上的程序是如何通信的进行了解。操作系统的角度来看，进行通信的实际上是进程 (process) 而不是程序。</p><p>在不同的端系统上，通过跨越计算机网络交换报文而相互通信。发送进程生成报文并向网络中发送报文，接收进程接收这些报文并可能通过回送报文进行响应。</p><h3 id="1-客户和服务器进程"><a href="#1-客户和服务器进程" class="headerlink" title="1.客户和服务器进程"></a>1.客户和服务器进程</h3><p>在一对进程之间的通信回话场景中，发起通信(即在该回话开始时发起与其他进程的联系)的进程被标识为客户，在回话开始时等待联系的进程是服务器。</p><h3 id="2-进程与计算机网络之间的接口"><a href="#2-进程与计算机网络之间的接口" class="headerlink" title="2.进程与计算机网络之间的接口"></a>2.进程与计算机网络之间的接口</h3><p>进程通过一个成为套接字(socket)的软件接口想网络发送报文和从网络接收报文。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-2023-07-20-21-43-21.png" alt="应用进程、套接字和下面的运输协议"></p><p>如图所示，套接字是一台主机内应用层和运输层之间的接口。应用程序只能控制套接字在应用层端的一切，对该套接字的运输层端几乎没有控制权。应用开发者可以选择运输层协议，和设置少数运输层参数。</p><h3 id="3-进程寻址"><a href="#3-进程寻址" class="headerlink" title="3.进程寻址"></a>3.进程寻址</h3><p>在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址：</p><ul><li>主机的地址；</li><li>在目的主机中指定接收进程的标识符；</li></ul><p>在因特网中，主机由其 IP 地址 (IP address) 标识。主机上通过目的地端口号(port number)来表示接收进程。</p><p>周知端口号：<a href="http://www.iana.org/">http://www.iana.org</a></p><h2 id="2-1-3-可供应用程序使用的运输服务"><a href="#2-1-3-可供应用程序使用的运输服务" class="headerlink" title="2.1.3 可供应用程序使用的运输服务"></a>2.1.3 可供应用程序使用的运输服务</h2><p>一个运输层协议能够为调用他的应用程序提供什么样的服务呢？大体上能从四个方面对应用程序服务要求进行分类：可靠数据传输、吞吐量、定时和安全性。</p><h3 id="1-可靠数据传输"><a href="#1-可靠数据传输" class="headerlink" title="1.可靠数据传输"></a>1.可靠数据传输</h3>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-两数相加</title>
    <link href="/2023/07/20/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <url>/2023/07/20/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p><p><code>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></p><p>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位 数字。<br>请你将两个数相加，并以相同形式返回一个表示和的链表。<br>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><img src="https://imgs.bencorn.com/imgs/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-2023-07-20-09-59-15.png" alt="实例 1"></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">示例1：<br><br>输入：l1 = [2,4,3], l2 = [5,6,4]<br>输出：[7,0,8]<br>解释：342 + 465 = 807.<br><br>示例 2：<br><br>输入：l1 = [0], l2 = [0]<br>输出：[0]<br><br>示例 3：<br><br>输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]<br>输出：[8,9,9,9,0,0,0,1]<br><br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">提示：<br><br>每个链表中的节点数在范围 [1, 100] 内<br>0 &lt;= Node.val &lt;= 9<br>题目数据保证列表表示的数字不含前导零<br></code></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>模拟两个数的加法，然后对数字的顺序进行处理。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode *ans = <span class="hljs-literal">nullptr</span>;<br>        ListNode *ret = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> inc = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span>(l1 || l2)&#123;<br>            <span class="hljs-keyword">if</span>(l1)&#123;<br>                inc = inc + l1-&gt;val;<br>                l1 = l1-&gt;next;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(l2)&#123;<br>                inc = inc + l2-&gt;val;<br>                l2 = l2-&gt;next;<br>            &#125;<br><br>            ListNode *tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(inc % <span class="hljs-number">10</span>, ans);<br>            inc = inc / <span class="hljs-number">10</span>;<br>            ans = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(inc)&#123;<br>             ListNode *tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(inc, ans);<br>             ans = tmp;<br>        &#125;<br><br>        ListNode *l = ans, *tmp;<br>        <span class="hljs-keyword">while</span>(l)&#123;<br>            tmp = l;<br>            l = l-&gt;next;<br>            tmp-&gt;next = ret;<br>            ret = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW3-system-calls</title>
    <link href="/2023/07/20/HW3-system-calls/"/>
    <url>/2023/07/20/HW3-system-calls/</url>
    
    <content type="html"><![CDATA[<p>为 xv6 添加一个系统调用。</p><h1 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h1><p>第一个任务是修改 xv6 内核，为每个系统调用打印出一行。打印系统调用的名称和返回值就足够，不需要打印系统调用参数。</p><p>完成过后，会看到类似于以下的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">fork -&gt; 2<br>exec -&gt; 0<br>open -&gt; 3<br>close -&gt; 0<br>$write -&gt; 1<br> write -&gt; 1<br></code></pre></td></tr></table></figure><p>提示：修改 syscall.c 文件中的 syscall() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *syscalls_name[] = &#123;<br>[SYS_fork]    <span class="hljs-string">&quot;fork&quot;</span>,<br>[SYS_exit]    <span class="hljs-string">&quot;exit&quot;</span>,<br>[SYS_wait]    <span class="hljs-string">&quot;wait&quot;</span>,<br>[SYS_pipe]    <span class="hljs-string">&quot;pipe&quot;</span>,<br>[SYS_read]    <span class="hljs-string">&quot;read&quot;</span>,<br>[SYS_kill]    <span class="hljs-string">&quot;kill&quot;</span>,<br>[SYS_exec]    <span class="hljs-string">&quot;exec&quot;</span>,<br>[SYS_fstat]   <span class="hljs-string">&quot;fstat&quot;</span>,<br>[SYS_chdir]   <span class="hljs-string">&quot;chdir&quot;</span>,<br>[SYS_dup]     <span class="hljs-string">&quot;dup&quot;</span>,<br>[SYS_getpid]  <span class="hljs-string">&quot;getpid&quot;</span>,<br>[SYS_sbrk]    <span class="hljs-string">&quot;sbrk&quot;</span>,<br>[SYS_sleep]   <span class="hljs-string">&quot;sleep&quot;</span>,<br>[SYS_uptime]  <span class="hljs-string">&quot;uptime&quot;</span>,<br>[SYS_open]    <span class="hljs-string">&quot;open&quot;</span>,<br>[SYS_write]   <span class="hljs-string">&quot;write&quot;</span>,<br>[SYS_mknod]   <span class="hljs-string">&quot;mknod&quot;</span>,<br>[SYS_unlink]  <span class="hljs-string">&quot;unlink&quot;</span>,<br>[SYS_link]    <span class="hljs-string">&quot;link&quot;</span>,<br>[SYS_mkdir]   <span class="hljs-string">&quot;mkdir&quot;</span>,<br>[SYS_close]   <span class="hljs-string">&quot;close&quot;</span>,<br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  num = curproc-&gt;tf-&gt;eax;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    curproc-&gt;tf-&gt;eax = syscalls[num]();<br>    <span class="hljs-comment">// solution</span><br>    cprintf(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, syscalls_name[num], curproc-&gt;tf-&gt;eax);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            curproc-&gt;pid, curproc-&gt;name, num);<br>    curproc-&gt;tf-&gt;eax = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW3-system-calls-2023-07-20-08-09-16.png" alt="result"></p><h1 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h1><p>添加一个系统调用，这个系统调用可以获取当前的 UTC 时间，并且返回给用户程序。cmostime() 等接口 在 lapic.c 文件中定义好了。</p><p><img src="https://imgs.bencorn.com/imgs/HW3-system-calls-2023-07-20-09-06-13.png" alt="查看 uptime 系统调用"></p><p>参照 uptime 系统调用，然后挨着在每个地方添加相应的内容。</p><ul><li>syscall.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>...<br>[SYS_date]    sys_date,<br>...<br>[SYS_date]    <span class="hljs-string">&quot;date&quot;</span>,<br></code></pre></td></tr></table></figure><ul><li>syscall.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_date   22</span><br></code></pre></td></tr></table></figure><ul><li>sysproc.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(argptr(<span class="hljs-number">0</span>,r,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> rtcdate)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  cmostime(r);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>user.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">date</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rtcdate *r)</span>;<br></code></pre></td></tr></table></figure><ul><li>usys.S</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">SYSCALL(date)<br></code></pre></td></tr></table></figure><p>然后再添加一个用户程序 date.c，来调用该系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span> <span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (date(&amp;r)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;date failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// your code to print the time in any format you like...</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d-%d-%d %d:%d:%d UTC\n&quot;</span>, r.year, r.month, r.day, r.hour, r.minute, r.second);<br>  <span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile 里添加具体的应用程序。</p><p><img src="https://imgs.bencorn.com/imgs/HW3-system-calls-2023-07-20-09-52-16.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C-语法总结</title>
    <link href="/2023/07/19/C-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/19/C-%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个部分，总结一下，自己在使用 C 语言的过程中，遇到的一些类似语法糖，或者各种使用方法。多总结，多回顾，慢慢的积累肯定是没错的。纠结了很久才开始写这个总结，希望以后自己遇到更多的与 C 语言相关的用法也可以添加进来。</p><p><a href="./C-language.pdf">C程序设计语言</a></p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h2><p>在C语言中，指针的指针（double pointer）可以用于处理需要修改指针本身的情况。它允许我们通过传递指针变量的地址来修改指针的值，进而改变指针所指向的内存地址。</p><p>使用指针的指针的常见场景有：</p><ul><li><p>函数参数传递：当我们需要修改一个指针的值，并使其在函数外部的作用域中保持修改后的值时，可以使用指针的指针作为函数参数。这样可以直接修改指针本身，而不仅仅是修改指针所指向的数据。</p></li><li><p>动态内存分配：在使用动态内存分配函数（如malloc、calloc等）分配内存时，返回的是所分配内存的首地址，而这个地址需要存储在一个指针变量中。如果我们需要在函数外部修改这个指针变量，就需要传递指针的指针。</p></li></ul><p>以下是一个简单的示例，演示了如何使用指针的指针来修改指针的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">changePointer</span><span class="hljs-params">(<span class="hljs-type">int</span> **ptr)</span> &#123;<br>    <span class="hljs-type">int</span> *newPtr = <span class="hljs-literal">NULL</span>;<br>    newPtr = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    *newPtr = <span class="hljs-number">100</span>;  <span class="hljs-comment">// 修改指针所指向的内存的值</span><br>    *ptr = newPtr;  <span class="hljs-comment">// 修改指针本身的值</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> *ptr = <span class="hljs-literal">NULL</span>;<br>    changePointer(&amp;ptr);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *ptr);  <span class="hljs-comment">// 输出：100</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，changePointer函数接受一个指针的指针作为参数，通过修改指针的指针，将其指向新分配的内存。在main函数中，我们可以看到指针ptr的值被成功修改为指向100的内存地址。</p><p>指针的指针提供了更为灵活的内存管理和数据结构操作的能力，但同时也需要谨慎使用，以避免潜在的错误和内存泄漏问题。</p><p><code>未完待续。。。</code></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-1</title>
    <link href="/2023/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/"/>
    <url>/2023/07/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1/</url>
    
    <content type="html"><![CDATA[<p>由于科研需要，重新研读《计算机网络（自顶向下）》，好好学习计算机网络的整体知识。本文主要是对第一章的内容进行总结，其中主要包含一些核心概念和示意图，并且完成部分实验。</p><p>电子书附上：<a href="./network.pdf">计算机网络自顶向下（第七版）</a></p><h1 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h1><p>书上从两个角度来问答这个问题：</p><ul><li>一、因特网的具体构成：构成因特网的具体硬件和软件组件。</li><li>二、分布式应用提供服务的联网基础设施来描述因特网。</li></ul><h2 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h2><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-16-21-35-37.png" alt="因特网的一些部件"></p><p>总结一下这一章的许多概念：</p><ul><li><p>主机(host)&#x2F;端系统(end system)：与因特网相连接的设备；</p></li><li><p>通信链路(communication link)：由物理媒体组成的链路，包括电缆、铜线、光纤、无线电频谱；</p></li><li><p>分组(packet)：一台端系统向另一台端系统发送数据时，发送系统将数据分段，并为每段加上首部字节，由此形成的信息，这些分组通过网络发送到目的端系统，然后装配成原始数据；</p></li><li><p>传输速率(transmission rate)：比特&#x2F;秒，链路的传输度量；</p></li><li><p>路径(route&#x2F;path)：一个分组所经历的一系列通信链路和分组交换机成为通过该网络的路径；</p></li><li><p>因特网服务提供商(Intenet Service Provider, ISP)</p></li><li><p>协议(protocol)：端系统、分组交换机和其他因特网部件控制因特网中信息的接收和发送，TCP(Transmission Control Protocol，传输控制协议)和IP(Internet Protocol，网际协议)协议是最常用的两个；</p></li><li><p>请求评论(Request For Comment，RFC)：IETF（因特网工程任务组，Internet Engineering Task Force）的标准文档；</p></li></ul><h2 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h2><p>从为应用程序提供服务的基础设施的角度来描述因特网。</p><ul><li><p>分布式应用程序(distributed application)：多个相互交换数据的端系统，如即时讯息、实时道路信息、在线社交网络。。。。等等；</p></li><li><p>套接字接口(socket interface)：与因特网相连的端系统提供，规定了运行在一个端系统上的程序请求因特网基础设施想运行在另一个端系统上的特定的目的地程序交付数据的方式。</p></li></ul><h2 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h2><p>下面进行计算机网络的协议总结：</p><h3 id="1-人类活动的类比"><a href="#1-人类活动的类比" class="headerlink" title="1.人类活动的类比"></a>1.人类活动的类比</h3><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-12-01-51.png" alt="人类活动和计算机网络协议"></p><p>本小节对网络与两个人的沟通过程进行类比，两个人的沟通方式，就像两台计算机的交互方式，都隐含着一定的暗示与约束条件等。</p><h3 id="2-网络协议"><a href="#2-网络协议" class="headerlink" title="2.网络协议"></a>2.网络协议</h3><ul><li>网络协议的实体：交换报文和采取动作的设备的硬件或软件组织；</li><li>协议(Protocol)：定义了再两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接收一条报文或其他事件所采取的动作。</li></ul><p>因特网广泛的使用协议，不同的协议完成不同的通信任务。</p><h1 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h1><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-12-06-33.png" alt="端系统交互"></p><ul><li>端系统：也称为主机(host)，因为他们运行应用程序，主机&#x3D;端系统。</li></ul><p>主机有时也可以分为两类，客户(client)和服务器(server)：</p><ul><li>客户：通常是桌面PC、移动PC和智能手机等；</li><li>服务器：通常是强大的机器，存储和发布 Web 页面、流视频、中继电子邮件等；</li></ul><p>现在，大部分提供搜索结果、电子邮件、Web 页面和视频的服务器都属于大型数据中心(data center)。</p><h2 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h2><ul><li><p>接入网：将端系统物理连接到其边缘路由器(edge router)的网络；</p></li><li><p>边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器；</p></li></ul><h3 id="1-家庭接入：DSL、电缆、FTTH、拨号、卫星"><a href="#1-家庭接入：DSL、电缆、FTTH、拨号、卫星" class="headerlink" title="1.家庭接入：DSL、电缆、FTTH、拨号、卫星"></a>1.家庭接入：DSL、电缆、FTTH、拨号、卫星</h3><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-12-14-10.png" alt="接入网"></p><p>宽带住宅接入的两种流行类型：数字用户线(Digital Subscriber Line，DSL)和电缆，不过我国推进的宽带下乡政策，大家使用的都是光纤到户。住户通常从提供本地电话接入的本地电话公司处获得DSL因特网接入。因此，当使用DSL时，用户的本地电话公司也是它的ISP。</p><p>每个用户的 DSL 调制解调器使用现有的电话线（即双绞铜线）与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的 DSL 调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局；来自许多家庭的模拟信号在DSLAM处被转换回数字形式。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-12-14-34.png" alt="DSL 因特网接入"></p><p>家庭电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码：</p><ul><li><p>高速下行信道，位于50kHz到1 MHz频段；</p></li><li><p>中速上行信道，位于4kHz到50kHz频段；</p></li><li><p>普通的双向电话信道，位于0到4kHz频段。</p></li></ul><p>这种方法使单根 DSL 线路看起来像有 3 根单独的线路一样，因此一个电话呼叫和一个因特网连接能够同时共享 DSL 链路。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-12-43-05.png" alt="FTTH 因特网接入"></p><p>另一种接入方式就是光纤接入(Fiber To The Home，FTTH)。</p><p>每个家庭具有一个光纤网络端接器(Optical Network Terminator, ONT)，它由专门的光纤连接到邻近的分配器(splitter) 。该分配器把一些家庭(通常少于100个)集结到一根共享的光纤，该光纤再连接到本地电话和公司的中心局中的光纤线路端接器(Optical Line Tenninator, OLT)。 该 OLT 提供了光信号和电信号之间的转换，经过本地电话公司路由器与因特网相连。在家庭中，用户将一台家庭路由器(通常是无线路由器)与ONT相连，并经过这台家庭路由器接入因特网。在 PON 体系结构中，所有从 OLT 发送到分配器的分组在分配器(类似于一个电缆头端)处复制。</p><h3 id="2-企业（和家庭）接入：以太网和-WIFI"><a href="#2-企业（和家庭）接入：以太网和-WIFI" class="headerlink" title="2.企业（和家庭）接入：以太网和 WIFI"></a>2.企业（和家庭）接入：以太网和 WIFI</h3><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-13-29-53.png" alt="以太网因特网接入"></p><h3 id="3-广域无线接入：3G-和-LTE"><a href="#3-广域无线接入：3G-和-LTE" class="headerlink" title="3.广域无线接入：3G 和 LTE"></a>3.广域无线接入：3G 和 LTE</h3><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-13-59-00.png" alt="家庭网络示意图"></p><p>教材上还在讲 3G，现在都 4G、5G 啦，不过接入的方式还是没有改变。</p><h2 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h2><p>当一个数据比特，从发射器-接收器之间传输，通过跨越一种物理媒体(physical medium)传输电磁波或光脉冲来实现。</p><p>物理媒体可具有多种形状和形式，并且对于每个发射器-接收器对而言不必具有相同的类型。</p><p>物理媒体分成两种类型：导引型媒体(guided media)和非导引型媒体 (unguided media) o对于导引型媒体, 电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。对于非导引型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中。</p><h3 id="1-双绞铜线"><a href="#1-双绞铜线" class="headerlink" title="1.双绞铜线"></a>1.双绞铜线</h3><p>无屏蔽双绞线(Unshielded Twisted Pair, UTP)常用在建筑物内的计算机网络中，即用于局域网(LAN)中。目前局域网中的双绞线的数据速率从 10Mbps 到 10Gbpso 所能达到的数据传输速率取决于线的粗细以及传输方和接收方之间的距离。</p><h3 id="2-同轴电缆"><a href="#2-同轴电缆" class="headerlink" title="2.同轴电缆"></a>2.同轴电缆</h3><p>同轴电缆能被用作导引型共享媒体(shared medium)。特别是，许多端系统能够直接与该电缆相连，每个端系统都能接收由其他端系统发送的内容。</p><h3 id="3-光纤"><a href="#3-光纤" class="headerlink" title="3.光纤"></a>3.光纤</h3><p>光纤是一种细而柔软的、能够导引光脉冲的媒体，每个脉冲表示一个比特。一根光纤能够支持极高的比特速率，高达数十甚至数百Gbps。它们不受电磁干扰，长达 100km 的光缆信号衰减极低，并且很难窃听。</p><h3 id="4-陆地无线电信道"><a href="#4-陆地无线电信道" class="headerlink" title="4.陆地无线电信道"></a>4.陆地无线电信道</h3><p>无线电信道承载电磁频谱中的信号。它不需要安装物理线路，并具有穿透墙壁、提供与移动用户的连接以及长距离承载信号的能力，因而成为一种有吸引力的媒体。</p><h3 id="5-卫星无线电信道"><a href="#5-卫星无线电信道" class="headerlink" title="5.卫星无线电信道"></a>5.卫星无线电信道</h3><p>一颗通信卫星连接地球上的两个或多个微波发射器&#x2F;接收器，它们被称为地面站。该卫星在一个频段上接收传输，使用一个转发器再生信号，并在另一个频率上发射信号。通信中常使用两类卫星：同步卫星（geostationary satellite）和近地轨道（Low-Earth Orbiting, LEO）卫星。</p><h1 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h1><p>这个部分总结一下网络的核心，深入了解分组交换和链路构成等。</p><h2 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1 分组交换"></a>1.3.1 分组交换</h2><p>网络应用中，端系统彼此交换报文(message)。报文能够包含协议设计者需要的任何东西。报文可以执行一种控制功能，也可以包含数据。</p><p>为了从源端系统向目的系统发送一个报文，源将长报文划分为较小的数据块，称之为分组(packet)。</p><p>在源和目的地之间，每个分组都通过通信链路和分组交换机(packet switch)传送。交换机主要有两类：路由器(router)和链路层交换机(link-layer switch)。</p><p>分组以等于该链路最大传输速率的速度传输通过通信链路。因此，如果某源端系统或分组交换机经过一条链路发送一个 $L$ 比特的分组，链路的传输速率为 $R$ 比特&#x2F;秒，则传输该分组的时间为 $L&#x2F;R$ 秒。</p><h3 id="1-存储转发传输"><a href="#1-存储转发传输" class="headerlink" title="1.存储转发传输"></a>1.存储转发传输</h3><p>多数分组交换机是在链路的输入端使用存储转发传输(store-and-forward transmission)机制。</p><ul><li>存储转发传输：指在交换机能够开始向输岀链路传输该分组的第一个比特之前，必须接收到整个分组。</li></ul><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-15-28-06.png" alt="存储转发分组交换"></p><p>如图所示，路由器应用了存储转发机制，所以它先缓存分组 1 的比特，当分组 1 的所有比特到达过后，才开始向输出链路传输该分组。</p><p>下面进行源开始发送分组，到目的地接收到整个分组所经过的时间分析。这里忽略掉传播时延——指这些比特以接近光速跨越线路所需要的时间。</p><p>1、源在 0 时刻开始传输；<br>2、在时刻 $ L&#x2F;R $ 秒，因为该路由器刚好接收到整个分组，所以它可以向目的地出链路传输分组；<br>3、在时刻 $ 2L&#x2F;R $ 秒，路由器已经传输了整个分组，并且整个分组已经被目的地接收。</p><p>所以，总时延是 $ 2L&#x2F;R $。如果交换机一旦比特到达就转发比特，不必首先收到整个分组，则因为比特没有在路由器保存，总时延将是 $ L&#x2F;R $。</p><p>现在我们来计算从源开始发送第一个分组到目的地接收到所有三个分组所需的时间。与前面一样，在时刻 L&#x2F;R ,路由器开始转发第一个分组。而在时刻厶&#x2F;R源也开始发送第二个分组，因为它已经完成了第一个分组的完整发送。因此，在时刻2L&#x2F;R,目的地已经收到第一个分组并且路由器已经收到第二个分组。类似地，在时刻 3L&#x2F;R，目的地已经收到前两个分组并且路由器已经收到第三个分组。最后，在时刻4厶&#x2F;R,目的地已经收到所有 3 个分组!</p><p>我们现在来考虑下列一般情况：通过由 N 条速率均为R的链路组成的路径（所以,在源和目的地之间有 N-1 台路由器），从源到目的地发送一个分组。应用如上相同的逻辑, 我们看到端到端时延是：</p><p>$$<br>    d_{端到端} &#x3D; N\frac{L}{R}<br>$$</p><h3 id="2-排队时延和分组丢失"><a href="#2-排队时延和分组丢失" class="headerlink" title="2.排队时延和分组丢失"></a>2.排队时延和分组丢失</h3><p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存(output buffer)，也称为输出队列(output queue)，它用于存储路由器准备发往那条链路的分组。</p><p>如果到达的分组需要传输到某条链路，发现该链路正在忙于传输其他分组，该到达分组必须在输出缓存中等待。因此除了春初转发时延以外，分组还要承受输出缓存的排队时延(queuing delay)。这些时延是变化的，变化的程度取决于网络的拥塞程度。</p><p>因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。在这种情况下，就会出现分组丢失(丢包)(packet loss)，到达的分组或已经排队的分组之一将被丢弃。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-17-16-53-46.png" alt="分组交换"></p><h3 id="3-转发表和路由选择协议"><a href="#3-转发表和路由选择协议" class="headerlink" title="3.转发表和路由选择协议"></a>3.转发表和路由选择协议</h3><p>在因特网中，每个端系统具有一个称为IP地址的地址。当源主机要向目的端系统发送一个分组时，源在该分组的首部包含了目的地的IP地址。</p><p>如同邮政地址那样，该地址具有一种等级结构。当一个分组到达网络中的路由器时，路由器检查该分组的目的地址的一部分，并向一台相邻路由器转发该分组。更特别的是，每台路由器具有一个转发表(forwarding table),用于将目的地址(或目的地址的一部分)映射成为输岀链路。</p><p>当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当<br>的出链路。路由器则将分组导向该出链路。</p><p>因特网具备一下特殊的路由选择协议(routing protocol)，用于自动的设置这些转发表。</p><h2 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h2><p>通过网络链路和交换机移动数据有两种基本方法：电路交换(circuit switching)和分组交换(packet switching)。</p><p>在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源(缓存，链路传输速率)。</p><p>在分组交换网络中，这些资源则不是预留的；会话的报文按需使用这些资源，其后果可能是不得不等待（即排队）接入通信线路。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-12-35-46.png" alt="电路交换网络"></p><p>打电话例子：当一个人向另一个人打电话的时候，电话链路预留一部分传输容量，建立一条真实的连接。这样预留带宽资源可以保证恒定的速率向接收方传送数据。</p><h3 id="1-电路交换网络中的复用"><a href="#1-电路交换网络中的复用" class="headerlink" title="1.电路交换网络中的复用"></a>1.电路交换网络中的复用</h3><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-12-37-52.png" alt="FDM 和 TDM"></p><ul><li><p>频分复用(Frequency-Division Multiplexing，FDM)：对于FDM,链路的频谱由跨越链路创建的<br>所有连接共享。</p></li><li><p>时分复用(Time-Division Multiplexing，TDM)：时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。</p></li></ul><h3 id="2-分组交换与电路交换的对比"><a href="#2-分组交换与电路交换的对比" class="headerlink" title="2.分组交换与电路交换的对比"></a>2.分组交换与电路交换的对比</h3><p>分组交换性能可以优于电路交换的性能。目前，网络普遍朝着分组交换的方向发展。</p><h2 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h2><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-12-44-30.png" alt="ISP 互联"></p><p>因特网是一个网络的网络，结构复杂，含有多层的 ISP 组成。</p><h1 id="1-4-分组交换网中的时延、丢包和吞吐量"><a href="#1-4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包和吞吐量"></a>1.4 分组交换网中的时延、丢包和吞吐量</h1><p>这个部分讨论时延、丢包和吞吐量。书上说，这个部分可以写上千篇博士论文！</p><h2 id="1-4-1-分组交换网络中的时延概述"><a href="#1-4-1-分组交换网络中的时延概述" class="headerlink" title="1.4.1 分组交换网络中的时延概述"></a>1.4.1 分组交换网络中的时延概述</h2><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-12-48-54.png" alt="路由器A的节点时延"></p><p>时延的类型：</p><ul><li><p>处理时延(nodal processing delay)：检查分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。处理时延<br>也能够包括其他因素，如检查比特级别的差错所需要的时间，该差错岀现在从上游节点向路由器A传输这些分组比特的过程中。高速路由器的处理时延通常是微秒或更低的数量级。</p></li><li><p>排队时延(queuing delay)：在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。如果该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延为0。另一方面，如果流量很大，并且许多其他分组也在等待传输，该排队时延将很长。</p></li><li><p>传输时延(transmission delay)：假定分组以先到先服务方式传输——这在分组交换网中是常见的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。</p></li><li><p>传播时延(propagation delay)：一旦一个比特被推向链路，该比特需要向路由器B传播。从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播。该传播速率取决于该链路的物理媒体（即光纤、双绞铜线等），其速率范围是2xlO8-3xlO8m&#x2F;S,这等于或略小于光速。</p></li><li><p>传输时延和传播时延的比较：传输时延是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。另一方面，传播时延是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的函数，而与分组长度或链路传输速率无关。</p></li></ul><p>如果令 $d_{proc}$、$d_{queue}$、$d_{trans}$、$d_{prop}$ 分别为处理时延、排队时延、传输时延、传播时延，则节点的总时延由下式给定：</p><p>$$<br>d_{nodal} &#x3D; d_{proc} + d_{queue}+d_{trans}+d_{prop}<br>$$</p><h2 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h2><p>排队时延 $d_{queue}$ 较为复杂，人们通常使用统计量来度量排队时延，如平均排队时延，排队时延的方差和排队时延超过某些特定值的概率。</p><ul><li>流量强度：a 为分组到达队列的平均速率，R 是传输速率，假定所有分组都是 L 比特组成，比率 $La&#x2F;R$ 被称为流量强度。</li></ul><p>如果 $ La&#x2F;R &gt; 1$，则比特到达队列的平均速率超过从该队列传输岀去的速率。在这种不幸的情况下，该队列趋向于无限增加，并且排队时延将趋向无穷大！因此，流量工程中的一条金科玉律是：设计系统时流量强度不能大于1。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-13-22-16.png" alt="平均排队时延与流量强度的关系"></p><p>现在考虑 $La&#x2F;R \leq 1$ 时的情况。这时，到达流量的性质影响排队时延。例如，如果分组周期性到达，即每 $ L&#x2F;R $ 秒到达一个分组，则每个分组将到达一个空队列中，不会有排队时延。另一方面，如果分组以突发形式到达而不是周期性到达，则可能会有很大的平均排队时延。例如，假定每 $ (L&#x2F;R)N $秒同时到达 N 个分组。则传输的第一个分组没有排队时延; 传输的第二个分组就有厶&#x2F;R秒的排队时延；更为一般地，第几个传输的分组具有 $(n-1)L &#x2F; R$ 秒的排队时延。</p><p>周期性到达，很多时候都是学术性质的研究，通常到达队列的过程是随机的，及到达并不遵循任何模式，分组之间的时间间隔是随机的。</p><p><code>丢包</code></p><p>在现实中，一条链路钱的队列只有有限的容量，随着流量强度接近1，排队时延并不真正趋向无穷大。</p><p>到达的分组发现一个满的队列。由于没有地方可以存储这个分组，路由器将丢弃该分组，该分组将会丢失。</p><p>因此，一个节点的性能，不仅仅根据时延来度量，而且根据丢包的概率来度量。</p><h2 id="1-4-3-端到端时延"><a href="#1-4-3-端到端时延" class="headerlink" title="1.4.3 端到端时延"></a>1.4.3 端到端时延</h2><p>总结一个式子：假设源主机和目的主机间有 N-1 台路由器。假设网络无拥塞。</p><p>$$<br> d_{end-end} &#x3D; N(d_{proc} &#x3D; d_{trans} + d_{prop})<br>$$</p><h3 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a>Traceroute</h3><p>RFC 1393详细的描述了 Traceroute。可以访问具体的网站：<a href="http://www.traceroute.org/">http://www.traceroute.org</a></p><p>RFC中文文档：<a href="https://docs.huihoo.com/rfc/">https://docs.huihoo.com/rfc/</a></p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-13-39-13.png" alt="traceroute 例子"></p><h2 id="1-4-4-计算机网络中的吞吐量"><a href="#1-4-4-计算机网络中的吞吐量" class="headerlink" title="1.4.4 计算机网络中的吞吐量"></a>1.4.4 计算机网络中的吞吐量</h2><p>吞吐量是计算机网络中的一个至关重要的性能测度。</p><ul><li><p>瞬时吞吐量：主机B接收到文件的速率(bps计)；</p></li><li><p>平均吞吐量：主机B接收到大小为F比特文件的时间为T秒，则文件传输的平均吞吐量为 F&#x2F;T bps。</p></li></ul><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-13-41-34.png" alt="一个文件从服务器到客户的吞吐量"></p><ul><li>瓶颈链路(bottleneck link)：一条链路的端到端吞吐量，由链路中最小速率决定，成为瓶颈链路的传输速率。</li></ul><p>如上述的传输链路，传输一个 F 比特大小的文件，所需要的时间是 $ F &#x2F; min{R_{c}, R_{a}}$。<br>而长为 N 的链路中，吞吐量则是 $min{ R_{1}, R_{2},…,R_{N},}$</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-13-40-19.png" alt="端到端吞吐量"></p><h1 id="1-5-协议的层次及其服务模型"><a href="#1-5-协议的层次及其服务模型" class="headerlink" title="1.5 协议的层次及其服务模型"></a>1.5 协议的层次及其服务模型</h1><p>本部分对协议进行总结，学习分层体系结构和封装。</p><h2 id="1-5-1-分层的体系结构"><a href="#1-5-1-分层的体系结构" class="headerlink" title="1.5.1 分层的体系结构"></a>1.5.1 分层的体系结构</h2><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-13-48-48.png" alt="航线功能的水平分层"></p><p>利用分层的体系结构，我们可以为庞大而复杂的系统定义良好的特定部分。</p><h3 id="1-协议分层"><a href="#1-协议分层" class="headerlink" title="1.协议分层"></a>1.协议分层</h3><p>网络的设计者以分层(layer)的方式组织协议以及实现这些协议的网络硬件和软件。综合各个层次的所有协议，被称为协议栈(protocol stack)。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-13-56-56.png" alt="因特网协议栈和 OSI 参考模型"></p><h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p>应用层是网络应用程序及它们的应用层协议存留的地方。因特网的应用层包括许多协议，例如HTTP （它提供了 Web 文档的请求和传送）、SMTP （它提供了电子邮件报文的传输）和FTP （它提供两个端系统之间的文件传送）。我们将看到，某些网络功能，如将像 WWW.ietf.org 这样对人友好的端系统名字转换为32比特的网络地址，也是借助于特定的应用层协议即域名系统（DNS）完成的。</p><p>应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为报文（message）。</p><h4 id="（2）运输层"><a href="#（2）运输层" class="headerlink" title="（2）运输层"></a>（2）运输层</h4><p>因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，有两种运输协议，即TCP和UDP,利用其中的任一个都能运输应用层报文。</p><p>TCP向它的应用程序提供了面向连接的服务。这种服务包括了应用层报文向目的地的确保传递和流量控制（即发送方&#x2F;接收方速率匹配）。TCP也将长报文划分为短报文，并提供拥塞控制机制，因此当网络 拥塞时，源抑制其传输速率。</p><p>UDP协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。</p><p>我们把运输层的分组称为报文段 (segment) 。</p><h4 id="（3）网络层"><a href="#（3）网络层" class="headerlink" title="（3）网络层"></a>（3）网络层</h4><p>因特网的网络层负责将称为数据报（datagram）的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（TCP或UDP）向网络层递交运输层报文段和目的地址，就像你通过邮政服务寄信件时提供一个目的地址一样。</p><p>因特网的网络层包括著名的网际协议 IP,该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。IP 仅有一个，所有具有网络层的因特网组件必须运行 IP。</p><p>因特网的网络层也包括决定路由的路由选择协议，它根据该路由将数据报从源传输到目的地。因特网具有许多路由选择协议。如我们在 1.3 节所见，因特网是一个网络的网络，并且在一个网络中，其网络管理者能够运行所希望的任何路由选择协议。尽管网络层包括了网际协议和一些路由选择协议，但通常把它简单地称为 IP 层，这反映了 IP 是将因特网连接在一起的黏合剂这样的事实。 </p><h4 id="（4）链路层"><a href="#（4）链路层" class="headerlink" title="（4）链路层"></a>（4）链路层</h4><p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。为了将分组从一个节点（主机或路由器）移动到路径上的下一个节点，网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在该下一个节点，链路层将数据报上传给网络层。</p><p>由链路层提供的服务取决于应用于该链路的特定链路层协议。例如，某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点。值得注意的是，这种可靠的传递服务不同于 TCP 的可靠传递服务，TCP 提供从一个端系统到另一个端系统的可靠交付。链路层的例子包括以太网、WiFi 和电缆接入网的DOCSIS 协议。因为数据报从源到目的地传送通常需要经过几条链路，一个数据报可能被沿途不同链路上的不同链路层协议处理。例如，一个数据报可能被一段链路上的以太网和下一段链路上的 PPP 所处理。网络层将受到来自每个不同的链路层协议的不同服务。在本书中，我们把链路层分组称为帧（frame）</p><h4 id="（5）物理层"><a href="#（5）物理层" class="headerlink" title="（5）物理层"></a>（5）物理层</h4><p>虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点。在这层中的协议仍然是链路相关的，并且进一步与该链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。例如，以太网具有许多物理层协议：一个是关于双绞铜线的，另一个是关于同轴电缆的，还有一个是关于光纤的，等等。在每种场合中，跨越这些链路移动一个比特是以不同的方式进行的。</p><h2 id="1-2-2-封装"><a href="#1-2-2-封装" class="headerlink" title="1.2.2 封装"></a>1.2.2 封装</h2><p>如下图所示，数据从发送端系统的协议栈向下，沿着中间的链路层交换机和路由器的协议栈上上下下，然后向上到达接收端系统的协议栈。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-14-04-53.png" alt="主机、路由器和链路层交换机的封装功能"></p><p><code>封装</code></p><ul><li><p>在发送主机端，一个应用层报文（application-layer message）被传送给运输层。</p></li><li><p>在最简单的情况下,运输层收取到报文并附上附加信息（所谓运输层首部信息，首部将被接收端的运输层使用。</p></li><li><p>应用层报文和运输层首部信息一道构成了运输层报文段（transport-layer segment）。运输层报文段因此封装了应用层报文。附加的信息也许包括了下列信息: 允许接收端运输层向上向适当的应用程序交付报文的信息；差错检测位信息，该信息让接收方能够判断报文中的比特是否在途中已被改变。</p></li><li><p>运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报（network-layer datagram）。</p></li><li><p>该数据报接下来被传递给链路层，链路层增加它自己的链路层首部信息并生成链路层帧（link-layer frame）。</p></li></ul><p>所以我们看到，在每一层，一个分组具有两种类型的字段：首部字段和有效载荷字段（payload field）。有效载荷通常是来自上一层的分组。</p><h1 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h1><p>在 WSL 或者别的 Linux 上，进行 wireshark 的安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install wireshark -y<br>sudo wireshark<br></code></pre></td></tr></table></figure><p>然后我们选则监听的网卡，进行数据包的监听和查看。下面的图片是，使用 ping <a href="http://www.baidu.com/">www.baidu.com</a> 的时候，监听网卡获取到的数据包画面。</p><p><img src="https://imgs.bencorn.com/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-2023-07-18-15-00-18.png" alt="wireshark实验"></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-Memory</title>
    <link href="/2023/07/05/xv6-Memory/"/>
    <url>/2023/07/05/xv6-Memory/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个部分，我们来学习一下 xv6 是如何进行内存的管理的，了解最简单的管理方式，为后续学习 Linux 内存管理哪些打个小基础。</p><p>xv6 <a href="./book-rev11.pdf">这儿有源文件</a> 是一个 UNIX 风格的操作系统。后续的代码，我会按照顺序，对其进行拆分，和一些自己理解的说明，其实基本上内容都是在 xv6 的这本书里。</p><h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><p>x86 的指令操纵的都是虚拟地址（virtual address），而硬件 RAM 物理内存（physical address），则是每个存储空间有一个物理地址。x86 页表硬件将虚拟地址和物理地址进行一一映射。</p><p>x86 页表逻辑上是一个大小为 2^20 的数组，每个数组想被称为一个页表条目(page table entry, PTEs)。每个 PTE 包含 20-bit 物理页号（physical page number, PPN）和一些标志 flag。页表硬件将虚拟地址的高 20-bit 作为索引在页表中寻找一个 PTE，然后将高 20-bit 的地址替换为 PTE 中对应内存单元中保存的 PPN；同时，页表硬件将虚拟地址中的低 12-bit 直接复制到物理内存中的低 12-bit 的位置，然后和前边儿的 20-bit 组合起来形成一个地址，这个地址就是虚拟地址对应的实际的物理地址，然后硬件系统就可以通过该物理地址进行内存数据的访问。通过这样的步骤，就可以得到一个页大小 2^12（4096）bytes。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Memory-2023-07-09-21-30-21.png" alt="x86 page table hardware"></p><p>如图所示，虚拟地址到物理地址的转换实际分为了两个步骤。页表在物理内存中保存为两级树的形式，树的根部是一个 4096 字节的页目录（page directory），包含 1024 个页表页（page table pages）。这些页表页都包含一个 1024 大小的 32-bit 的页表条目（PTEs）。</p><p>页表硬件会使用虚拟地址的高地址的 10-bits 在页目录表中选择条目，然后使用接下来的 10-bits 在二级页表中选择页表条目。如果页目录表（page directory entry）和页表条目（PTE）都没有的话，页表硬件会报错。</p><p>每个 PTE 会包含标志位，页表硬件通过这些标志位来知晓如何使用虚拟地址。</p><ul><li>PTE_P：表明PTE是否存在，如果否会报错；</li><li>PTE_W：表明指令是否可以对页进行写操作，如果否，那么只允许读和取指令；</li><li>PTE_U：表明用户程序允许使用该页；</li></ul><p>这些标志位的具体信息，可以在 <code>mmu.h</code> 中看到，这些 16 进制的数，转化为二进制过后就可以得到相应的标志位为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Page table/directory entry flags.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_P           0x001   <span class="hljs-comment">// Present</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_W           0x002   <span class="hljs-comment">// Writeable</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_U           0x004   <span class="hljs-comment">// User</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_PS          0x080   <span class="hljs-comment">// Page Size</span></span><br></code></pre></td></tr></table></figure><p>关于术语的一些注释。 物理内存是指DRAM中的存储单元。 物理内存的一个字节有一个地址，称为物理地址。 指令仅使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件以读取或写入存储。 在这个级别的讨论中，没有虚拟内存之类的东西，只有虚拟地址。</p><h1 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h1><p>这个部分我们讨论 xv6 的进程地址空间。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># By convention, the _start symbol specifies the ELF entry point.<br># Since we haven<span class="hljs-string">&#x27;t set up virtual memory yet, our entry point is</span><br><span class="hljs-string"># the physical address of &#x27;</span>entry<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">.globl _start</span><br><span class="hljs-string">_start = V2P_WO(entry)</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Entering xv6 on boot processor, with paging off.</span><br><span class="hljs-string">.globl entry</span><br><span class="hljs-string">entry:</span><br><span class="hljs-string">  # Turn on page size extension for 4Mbyte pages</span><br><span class="hljs-string">  movl    %cr4, %eax</span><br><span class="hljs-string">  orl     $(CR4_PSE), %eax</span><br><span class="hljs-string">  movl    %eax, %cr4</span><br><span class="hljs-string">  # Set page directory</span><br><span class="hljs-string">  movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="hljs-string">  movl    %eax, %cr3</span><br><span class="hljs-string">  # Turn on paging.</span><br><span class="hljs-string">  movl    %cr0, %eax</span><br><span class="hljs-string">  orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="hljs-string">  movl    %eax, %cr0</span><br><span class="hljs-string"></span><br><span class="hljs-string">  # Set up the stack pointer.</span><br><span class="hljs-string">  movl $(stack + KSTACKSIZE), %esp</span><br><span class="hljs-string"></span><br><span class="hljs-string">  # Jump to main(), and switch to executing at</span><br><span class="hljs-string">  # high addresses. The indirect call is needed because</span><br><span class="hljs-string">  # the assembler produces a PC-relative instruction</span><br><span class="hljs-string">  # for a direct jump.</span><br><span class="hljs-string">  mov $main, %eax</span><br><span class="hljs-string">  jmp *%eax</span><br><span class="hljs-string"></span><br><span class="hljs-string">.comm stack, KSTACKSIZE</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>由entry创建的页表有足够的映射来允许内核的C代码开始运行。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Allocate one page table for the machine for the kernel address</span><br><span class="hljs-comment">// space for scheduler processes.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kvmalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  kpgdir = setupkvm();<br>  switchkvm();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然而，main 立即通过调用 kvmalloc 更改为新的页表，因为内核有一个更详细的计划来描述进程地址空间。</p><p>每个进程有一个单独的页表，并且 xv6 告知页表硬件，当 xv6 切换进程的时候切换页表。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Memory-2023-07-10-20-44-02.png" alt="Layout of the virtual address space of a process and the layout of the physical address space. Note that if a machine has more than 2 Gbyte of physical memory, xv6 can use only the memory that fits between KERNBASE and 0xFE00000"></p><p>如图所示，一个进程的用户内存从虚拟地址 0 开始，一直增长到 <code>KERNBASE </code> 的位置，允许一个进程寻址最多 2G。</p><p>在 <code>memlayout.h</code> 中，有描述 xv6 的内存布局，和一些将虚拟地址转化到虚拟地址的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Memory layout</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXTMEM  0x100000            <span class="hljs-comment">// Start of extended memory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHYSTOP 0xE000000           <span class="hljs-comment">// Top physical memory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVSPACE 0xFE000000         <span class="hljs-comment">// Other devices are at high addresses</span></span><br><br><span class="hljs-comment">// Key addresses for address space layout (see kmap in vm.c for layout)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80000000         <span class="hljs-comment">// First kernel virtual address</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNLINK (KERNBASE+EXTMEM)  <span class="hljs-comment">// Address where kernel is linked</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2P(a) (((uint) (a)) - KERNBASE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> P2V(a) ((void *)(((char *) (a)) + KERNBASE))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2P_WO(x) ((x) - KERNBASE)    <span class="hljs-comment">// same as V2P, but without casts</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> P2V_WO(x) ((x) + KERNBASE)    <span class="hljs-comment">// same as P2V, but without casts</span></span><br><br></code></pre></td></tr></table></figure><p>当一个进程向 xv6 申请内存的时候，xv6 首先寻找空闲的物理页（physical page），然后添加 PTEs 到进程的页表，该 PTEs 指向新的物理页。xv6 设置 <code>PTE_U PTE_W PTE_P</code> 标志位在这些 PTEs中。绝大部分进程不会使用完所有的用户进程空间，xv6 让 未使用的PTEs的 <code>PTE_P</code> 清零。不同的进程页表将用户地址转换为不同的物理内存，所以每个进程都有私有的用户内存。</p><p>xv6 包含了内核在每个进程的页表中运行所需的所有映射； 这些映射都出现在 KERNBASE 之上。它将虚拟地址 KERNBASE:KERNBASE+PHYSTOP 映射到 0:PHYSTOP。 这种映射的原因之一是内核可以使用自己的指令和数据。 另一个原因是内核有时需要能够写入物理内存的给定页面，例如在创建页表页面时； 让每个物理页都出现在可预测的虚拟地址处使这变得很方便。 这种安排的一个缺陷是 xv6 无法使用超过 2 GB 的物理内存，因为地址空间的内核部分是 2 GB。 因此，xv6 要求 PHYSTOP 小于 2 GB，即使计算机具有超过 2 GB 的物理内存。</p><p>一些使用内存映射 I&#x2F;O 的设备出现在从 0xFE000000 开始的物理地址处，因此 xv6 页表包括它们的直接映射。 因此，PHYSTOP 必须小于 2 GB - 16 MB（对于设备内存）。</p><p>xv6 不会将高于 KERNBASE 的 PTEs 中设置 PTE_U 标志，所以只有内核可以使用他们。</p><p>让每个进程的页表都包含用户内存和整个内核的映射，在系统调用和中断期间从用户代码切换到内核代码时很方便：这种切换不需要页表切换。 大多数情况下，内核没有自己的页表； 它几乎总是借用某个进程的页表。（其实这种管理方式是不安全的，Linux 现在都会维护内核页表，用户态切换带内核态的时候，也会从用户页表切换到内核页表）</p><p>回顾一下，xv6 确保每个进程只能使用自己的内存。 而且，每个进程都将其内存视为具有从零开始的连续虚拟地址，而进程的物理内存可以是不连续的。 xv6 通过仅在引用进程自己的内存的虚拟地址的 PTE 上设置 PTE_U 位来实现第一个。 它使用页表的能力来实现第二个，将连续的虚拟地址转换为恰好分配给进程的任何物理页。</p><h2 id="Code：createing-an-address-space"><a href="#Code：createing-an-address-space" class="headerlink" title="Code：createing an address space"></a>Code：createing an address space</h2><p>main 调用 kvmalloc 创建并切换到具有内核运行所需的 KERNBASE 以上映射的页表。 大部分工作发生在 setupkvm 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up kernel part of a page table.</span><br><span class="hljs-type">pde_t</span>*<br><span class="hljs-title function_">setupkvm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">pde_t</span> *pgdir;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmap</span> *<span class="hljs-title">k</span>;</span><br><br>  <span class="hljs-keyword">if</span>((pgdir = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(pgdir, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">if</span> (P2V(PHYSTOP) &gt; (<span class="hljs-type">void</span>*)DEVSPACE)<br>    panic(<span class="hljs-string">&quot;PHYSTOP too high&quot;</span>);<br>  <span class="hljs-keyword">for</span>(k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++)<br>    <span class="hljs-keyword">if</span>(mappages(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,<br>                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class="hljs-number">0</span>) &#123;<br>      freevm(pgdir);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> pgdir;<br>&#125;<br></code></pre></td></tr></table></figure><p>它首先分配一个内存页来保存页目录。 然后它调用mappages 来安装内核所需的翻译，这些映射在 kmap 数组中进行了描述。 这些翻译包括内核的指令和数据、直至 PHYSTOP 的物理内存以及实际上是 I&#x2F;O 设备的内存范围。 setupkvm 不会为用户内存安装任何映射； 这将在稍后发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to</span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not</span><br><span class="hljs-comment">// be page-aligned.</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, uint size, uint pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  <span class="hljs-type">char</span> *a, *last;<br>  <span class="hljs-type">pte_t</span> *pte;<br><br>  a = (<span class="hljs-type">char</span>*)PGROUNDDOWN((uint)va);<br>  last = (<span class="hljs-type">char</span>*)PGROUNDDOWN(((uint)va) + size - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walkpgdir(pgdir, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_P)<br>      panic(<span class="hljs-string">&quot;remap&quot;</span>);<br>    *pte = pa | perm | PTE_P;<br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mappages 将一系列虚拟地址到对应的物理地址范围的映射安装到页表中。 它以页面大小间隔为范围内的每个虚拟地址单独执行此操作。 对于每个要映射的虚拟地址，mappages 调用 walkpgdir 来查找该地址的 PTE 地址。 然后它初始化 PTE 以保存相关的物理页号、期望的权限 (PTE_W 和&#x2F;或 PTE_U) 以及 PTE_P 以将 PTE 标记为有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pgdir</span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,</span><br><span class="hljs-comment">// create any required page table pages.</span><br><span class="hljs-type">static</span> <span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">walkpgdir</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>  <span class="hljs-type">pde_t</span> *pde;<br>  <span class="hljs-type">pte_t</span> *pgtab;<br><br>  pde = &amp;pgdir[PDX(va)];<br>  <span class="hljs-keyword">if</span>(*pde &amp; PTE_P)&#123;<br>    pgtab = (<span class="hljs-type">pte_t</span>*)P2V(PTE_ADDR(*pde));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>(!alloc || (pgtab = (<span class="hljs-type">pte_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// Make sure all those PTE_P bits are zero.</span><br>    <span class="hljs-built_in">memset</span>(pgtab, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-comment">// The permissions here are overly generous, but they can</span><br>    <span class="hljs-comment">// be further restricted by the permissions in the page table</span><br>    <span class="hljs-comment">// entries, if necessary.</span><br>    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &amp;pgtab[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure><p>walkpgdir  模仿 x86 分页硬件在 PTE 中查找虚拟地址的操作。 walkpgdir 使用虚拟地址的高 10 位来查找页目录条目。 如果页目录项不存在，则所需的页表页尚未分配； 如果设置了 alloc 参数，walkpgdir 会分配它并将其物理地址放入页目录中。 最后，它使用虚拟地址的接下来的 10 位来查找页表页中 PTE 的地址。</p><h1 id="Physical-memory-allocation"><a href="#Physical-memory-allocation" class="headerlink" title="Physical memory allocation"></a>Physical memory allocation</h1><p>这个部分看一看物理内存的分配。</p><p>内核必须在运行时为页表、进程用户内存、内核堆栈和管道缓冲区分配和释放物理内存。</p><p>xv6 使用 kernel 结尾到 PHYSTOP 之间的物理内存，来为运行过程中进行内存分配。每一次分配，都是按照 4096-byte 大小的页进行。并且通过链表来跟踪每个页的使用情况。</p><p>物理内存分配包括从链表中删除一个页，释放物理内存则是添加空闲页到链表。</p><p>存在一个引导问题：必须映射所有物理内存以便分配器初始化空闲列表，但是使用这些映射创建页表涉及分配页表页面。 xv6 通过在进入期间使用单独的页面分配器来解决这个问题，该分配器在内核数据段末尾之后分配内存。 该分配器不支持释放，并且受到 entrypgdir 中 4 MB 映射的限制，但这足以分配第一个内核页表。</p><h2 id="Code：Physical-memory-allocator"><a href="#Code：Physical-memory-allocator" class="headerlink" title="Code：Physical memory allocator"></a>Code：Physical memory allocator</h2><p>分配器的数据结构是可用于分配的物理内存页的空闲列表。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">int</span> use_lock;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br><br></code></pre></td></tr></table></figure><p>每个空闲页面的列表元素都是一个struct run。分配器从哪里获取内存来保存该数据结构？ 它将每个空闲页面的运行结构存储在空闲页面本身中，因为那里没有存储任何其他内容。 空闲列表受自旋锁保护。 链表和锁包装在一个结构中，以明确锁保护结构中的字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Bootstrap processor starts running C code here.</span><br><span class="hljs-comment">// Allocate a real stack and switch to it, first</span><br><span class="hljs-comment">// doing some setup required for memory allocator to work.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  kinit1(end, P2V(<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)); <span class="hljs-comment">// phys page allocator</span><br>  kvmalloc();      <span class="hljs-comment">// kernel page table</span><br>  mpinit();        <span class="hljs-comment">// detect other processors</span><br>  lapicinit();     <span class="hljs-comment">// interrupt controller</span><br>  seginit();       <span class="hljs-comment">// segment descriptors</span><br>  picinit();       <span class="hljs-comment">// disable pic</span><br>  ioapicinit();    <span class="hljs-comment">// another interrupt controller</span><br>  consoleinit();   <span class="hljs-comment">// console hardware</span><br>  uartinit();      <span class="hljs-comment">// serial port</span><br>  pinit();         <span class="hljs-comment">// process table</span><br>  tvinit();        <span class="hljs-comment">// trap vectors</span><br>  binit();         <span class="hljs-comment">// buffer cache</span><br>  fileinit();      <span class="hljs-comment">// file table</span><br>  ideinit();       <span class="hljs-comment">// disk </span><br>  startothers();   <span class="hljs-comment">// start other processors</span><br>  kinit2(P2V(<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>), P2V(PHYSTOP)); <span class="hljs-comment">// must come after startothers()</span><br>  userinit();      <span class="hljs-comment">// first user process</span><br>  mpmain();        <span class="hljs-comment">// finish this processor&#x27;s setup</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数 main 调用 kinit1 和 kinit2 来初始化分配器。 进行两次调用的原因是，对于 main 的大部分调用来说，不能使用锁或超过 4 MB 的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialization happens in two phases.</span><br><span class="hljs-comment">// 1. main() calls kinit1() while still using entrypgdir to place just</span><br><span class="hljs-comment">// the pages mapped by entrypgdir on free list.</span><br><span class="hljs-comment">// 2. main() calls kinit2() with the rest of the physical pages</span><br><span class="hljs-comment">// after installing a full page table that maps them on all cores.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kinit1</span><span class="hljs-params">(<span class="hljs-type">void</span> *vstart, <span class="hljs-type">void</span> *vend)</span><br>&#123;<br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  kmem.use_lock = <span class="hljs-number">0</span>;<br>  freerange(vstart, vend);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kinit2</span><span class="hljs-params">(<span class="hljs-type">void</span> *vstart, <span class="hljs-type">void</span> *vend)</span><br>&#123;<br>  freerange(vstart, vend);<br>  kmem.use_lock = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>kinit1 为前 4 MB 建立无锁的分配，kinit2 则是对剩下的更多的内存添加锁服务。</p><p>main 函数应该决定多少物理内存是可用的，但是在 x86 上比较困难。取而代之的，它假设一台电脑拥有 224 MB（PHYSTOP）的物理内存，并且使用所有的 kernel 结束位置到 PHYSTOP 的物理内存作为初始空闲内存池。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *vstart, <span class="hljs-type">void</span> *vend)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint)vstart);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)vend; p += PGSIZE)<br>    kfree(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>kinit1 和 kinit2 调用 <code>freerange</code> 接口添加内存到空闲链表，这个步骤是通过对每一个物理页调用 <code>kfree</code> 来实现。一个 PTE 只能指向一个对齐 4096-byte 的物理地址，所以会使用 <code>PGROUNDUP</code> 来保证对齐。分配器 allocator 初始是没有内存的，这些调用通过 <code>kfree</code> 准备好一些内存来给分配器使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//PAGEBREAK: 21</span><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">char</span> *v)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>((uint)v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">1</span>, PGSIZE);<br><br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    acquire(&amp;kmem.lock);<br>  r = (<span class="hljs-keyword">struct</span> run*)v;<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    release(&amp;kmem.lock);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>kfree</code> 功能将一个物理内存页进行释放，并且将其添加到空闲内存链表内。这个步骤是需要进行原子操作的，因此会使用原子锁进行控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">char</span>*<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r)<br>    kmem.freelist = r-&gt;next;<br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>*)r;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>kalloc</code> 则是分配一个 4096-byte 大小的物理内存，并且返回一个指向该内存页初始地址的指针。如果返回 0 的话，则是没有内存可以分配了。</p><p>值得注意的是，分配器 allocator 通过虚拟地址映射来指向一个物理页，所以 <code>kinit </code> 使用 <code>P2V(PHYSTOP)</code> 来将物理地址 PHYSTOP 翻译成一个虚拟地址。分配器有时将地址视为整数以便对其进行算术（例如，遍历 kinit 中的所有页面），有时将地址用作读写内存的指针（例如，操作存储在每个页面中的运行结构）； 地址的双重使用是分配器代码充满 C 类型转换的主要原因。 另一个原因是释放和分配本质上改变了内存的类型。</p><h1 id="User-part-of-an-address-space"><a href="#User-part-of-an-address-space" class="headerlink" title="User part of an address space"></a>User part of an address space</h1><p><img src="https://imgs.bencorn.com/imgs/xv6-Memory-2023-07-15-09-18-00.png" alt="Memory layout of a user process with its initial stack"></p><p>如图所示，xv6 进程的用户内存空间分布。每一个用户进程都从地址 0 开始。地址空间的地步是用户程序的具体内容 text，data，stack。堆 heap 在栈 stack 的上方，进程可以通过 <code>sbrk</code> 来扩展堆的大小。值得注意的是，text，data，stack 在进程地址空间内是连续的，但是 xv6 可以自由的为这些部分使用非连续的物理页。例如，当 xv6 扩展进程的 heap 时，可以使用任何空闲的物理页来构建新的虚拟页，然后使用页表硬件，通过编程将虚拟页映射到物理页。这种灵活性是使用分页硬件的主要优点。</p><p>堆栈是一个页，并显示由 <code>exec</code> 创建的初始内容。 包含命令行参数的字符串以及指向它们的指针数组位于堆栈的最顶部。 就在其下方是允许程序在 <code>main</code> 处启动的值，就像函数调用 <code>main(argc, argv)</code> 刚刚启动一样。 为了保护堆栈从堆栈页增长，xv6 在堆栈的正下方放置了一个保护页。 保护页未映射，因此如果堆栈超出堆栈页，硬件将生成异常，因为它无法转换错误地址。 Linux等操作系统可能会为堆栈分配更多空间，以便它可以增长到超过一页。</p><h2 id="Code：sbrk"><a href="#Code：sbrk" class="headerlink" title="Code：sbrk"></a>Code：sbrk</h2><p>sbrk 是一个系统调用，它可以为一个进程收缩或者增加内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  <span class="hljs-keyword">if</span>(growproc(n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>该系统调用通过函数 <code>growproc</code> 来实现。如果 n 是正数，<code>growproc</code> 会分配一个或更多的物理页，并且映射他们到进程地址空间的顶部。如果 n 是负数，则会从进程地址空间的顶部取消一个或更多的页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Grow current process&#x27;s memory by n bytes.</span><br><span class="hljs-comment">// Return 0 on success, -1 on failure.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">growproc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  sz = curproc-&gt;sz;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = allocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = deallocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  curproc-&gt;sz = sz;<br>  switchuvm(curproc);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了进行这些更改，xv6 修改了进程的页表。 进程的页表存储在内存中，因此内核可以使用普通的赋值语句更新页表，这就是 allocuvm 和 deallocuvm 所做的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate page tables and physical memory to grow process from oldsz to</span><br><span class="hljs-comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">allocuvm</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span><br>&#123;<br>  <span class="hljs-type">char</span> *mem;<br>  uint a;<br><br>  <span class="hljs-keyword">if</span>(newsz &gt;= KERNBASE)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(newsz &lt; oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  a = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span>(; a &lt; newsz; a += PGSIZE)&#123;<br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      cprintf(<span class="hljs-string">&quot;allocuvm out of memory\n&quot;</span>);<br>      deallocuvm(pgdir, newsz, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-keyword">if</span>(mappages(pgdir, (<span class="hljs-type">char</span>*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; <span class="hljs-number">0</span>)&#123;<br>      cprintf(<span class="hljs-string">&quot;allocuvm out of memory (2)\n&quot;</span>);<br>      deallocuvm(pgdir, newsz, oldsz);<br>      kfree(mem);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>allocuvm</code> 分配一个物理页，并且添加一个映射到页表内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Deallocate user pages to bring the process size from oldsz to</span><br><span class="hljs-comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span><br><span class="hljs-comment">// need to be less than oldsz.  oldsz can be larger than the actual</span><br><span class="hljs-comment">// process size.  Returns the new process size.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">deallocuvm</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint a, pa;<br><br>  <span class="hljs-keyword">if</span>(newsz &gt;= oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  a = PGROUNDUP(newsz);<br>  <span class="hljs-keyword">for</span>(; a  &lt; oldsz; a += PGSIZE)&#123;<br>    pte = walkpgdir(pgdir, (<span class="hljs-type">char</span>*)a, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(!pte)<br>      a = PGADDR(PDX(a) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) - PGSIZE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*pte &amp; PTE_P) != <span class="hljs-number">0</span>)&#123;<br>      pa = PTE_ADDR(*pte);<br>      <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>        panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br>      <span class="hljs-type">char</span> *v = P2V(pa);<br>      kfree(v);<br>      *pte = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>deallocuvm</code> 删除页表中的映射关系。并且调整具体的内存大小的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Switch TSS and h/w page table to correspond to process p.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">switchuvm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;switchuvm: no process&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;kstack == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;switchuvm: no kstack&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;pgdir == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;switchuvm: no pgdir&quot;</span>);<br><br>  pushcli();<br>  mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts,<br>                                <span class="hljs-keyword">sizeof</span>(mycpu()-&gt;ts)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  mycpu()-&gt;gdt[SEG_TSS].s = <span class="hljs-number">0</span>;<br>  mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="hljs-number">3</span>;<br>  mycpu()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;<br>  <span class="hljs-comment">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span><br>  <span class="hljs-comment">// forbids I/O instructions (e.g., inb and outb) from user space</span><br>  mycpu()-&gt;ts.iomb = (ushort) <span class="hljs-number">0xFFFF</span>;<br>  ltr(SEG_TSS &lt;&lt; <span class="hljs-number">3</span>);<br>  lcr3(V2P(p-&gt;pgdir));  <span class="hljs-comment">// switch to process&#x27;s address space</span><br>  popcli();<br>&#125;<br></code></pre></td></tr></table></figure><p>x86 硬件将页表条目缓存在 Translation Look-aside Buffer(TLB) 中，当 xv6 更改页表时，它必须使缓存的条目无效。如果它没有使缓存的条目无效，那么在稍后的某个时刻，TLB 可能会使用旧的映射，指向同时已分配给另一个进程的物理页，因此，进程可能能在其他进程的内存上修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">lcr3</span><span class="hljs-params">(uint val)</span><br>&#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %0,%%cr3&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span> (val))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>xv6 通过重新加载 cr3（保存当前页表地址的寄存器）来使过时的缓存条目无效。</p><h2 id="Code：exec"><a href="#Code：exec" class="headerlink" title="Code：exec"></a>Code：exec</h2><p><code>exec</code> 是创建地址空间的用户部分的系统调用。它从文件系统中存储的文件初始化地址空间的用户部分。</p><p><code>exec</code> 使用 <code>namei</code> 打开命名二进制路径。然后，它读取 ELF 标头。 xv6 应用程序使用 elf 格式，在 elf.h 中定义。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Format of an ELF executable file</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="hljs-comment">// &quot;\x7FELF&quot; in little endian</span></span><br><br><span class="hljs-comment">// File header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> &#123;</span><br>  uint magic;  <span class="hljs-comment">// must equal ELF_MAGIC</span><br>  uchar elf[<span class="hljs-number">12</span>];<br>  ushort type;<br>  ushort machine;<br>  uint version;<br>  uint entry;<br>  uint phoff;<br>  uint shoff;<br>  uint flags;<br>  ushort ehsize;<br>  ushort phentsize;<br>  ushort phnum;<br>  ushort shentsize;<br>  ushort shnum;<br>  ushort shstrndx;<br>&#125;;<br><br><span class="hljs-comment">// Program section header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> &#123;</span><br>  uint type;<br>  uint off;<br>  uint vaddr;<br>  uint paddr;<br>  uint filesz;<br>  uint memsz;<br>  uint flags;<br>  uint align;<br>&#125;;<br><br><span class="hljs-comment">// Values for Proghdr type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD           1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ      4</span><br><br></code></pre></td></tr></table></figure><p>ELF 二进制文件由 ELF 头 struct elfhdr 组成，后面跟着一系列程序段头 struct proghdr。 每个 proghdr 描述了必须加载到内存中的应用程序的一部分； xv6 程序只有一个程序节标头，但其他系统可能有单独的指令和数据节。</p><p>第一步是快速检查该文件是否可能包含 ELF 二进制文件。 ELF 二进制文件以四字节“幻数 ”0x7F、“E”、“L”、“F” 或 ELF_MAGIC 开头。 如果 ELF 标头具有正确的幻数，则 exec 会假定二进制文件格式良好。</p><p><code>exec</code> 使用 setupkvm 分配一个没有用户映射的新页表，使用 allocuvm 为每个 ELF 段分配内存，并使用 loaduvm 将每个段加载到内存中。 allocuvm 检查请求的虚拟地址是否低于 KERNBASE。 loaduvm 使用 walkpgdir 查找已定位内存的物理地址，在该地址写入 ELF 段的每个页面，并使用 readi 从文件中读取。</p><p>&#x2F;init（使用 exec 创建的第一个用户程序）的程序节标头如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># objdump -p _init</span><br>_init:  file format elf32-i386<br>Program Header:<br>  LOAD off 0x00000054 vaddr 0x00000000 paddr 0x00000000 align 2**2<br>    filesz 0x000008c0 memsz 0x000008cc flags rwx<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>xv6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-两数之和</title>
    <link href="/2023/06/14/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2023/06/14/1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h1><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/two-sum">https://leetcode.cn/problems/two-sum</a></p><p><code>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</code></p><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">示例 1：<br><br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。<br><br>示例 2：<br><br>输入：nums = [3,2,4], target = 6<br>输出：[1,2]<br><br>示例 3：<br><br>输入：nums = [3,3], target = 6<br>输出：[0,1]<br></code></pre></td></tr></table></figure><p> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">提示：<br><br>2 &lt;= nums.length &lt;= 104<br>-109 &lt;= nums[i] &lt;= 109<br>-109 &lt;= target &lt;= 109<br>只会存在一个有效答案<br> <br></code></pre></td></tr></table></figure><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h1><p>首先想到的是暴力求解，采用两层 for 循环进行构造，因此算法时间复杂度 $O(n^2)$。可能是测试数据比较简单，暴力求解也可以 AC。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-type">int</span> i,j;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; len; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(j = i + <span class="hljs-number">1</span>; j &lt; len; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] + nums[j] == target)&#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(i);<br>                    ans.<span class="hljs-built_in">push_back</span>(j);<br>                    <span class="hljs-keyword">return</span> ans;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h1><p>思考能不能减少查找次数，一方面是通过二分的思想，降低到 $\log(n)$ 的复杂程度。另外一方面，如果数字很小，可以使用数组映射，想到使用 hash 表的方式。</p><p>比较困难的地方在于，C 语言没有 STL 库，得手动实现一部分 hash 表的功能。</p><h2 id="AC-代码-1"><a href="#AC-代码-1" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> tmp, num;<br>        map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash_table;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>            num = nums[i];<br>            <br>            tmp = target - num;<br>            <span class="hljs-keyword">if</span>(hash_table.<span class="hljs-built_in">count</span>(tmp) &gt; <span class="hljs-number">0</span>)&#123;<br>                ans.<span class="hljs-built_in">push_back</span>(hash_table[tmp]);<br>                ans.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-keyword">return</span> ans;<br>            &#125;<br><br>            hash_table[num] = i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过此题，学习到了如何使用 hash 表，来加速查找。<br>同时学习使用了 C++ map 的一个查找某个 key 的方法。需要值得注意的是，map 的 count 方法和 find 方法，时间复杂度都是 $\log(n)$，它们是使用红黑树实现的查找。而 find 方法找到过后，需要与迭代器的结尾进行比较，因此如果是查找某个 key 的话 count 方法比 find 方法高效。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minikube-创建集群</title>
    <link href="/2023/06/06/Minikube-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/06/06/Minikube-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>学习和复现一些小练习，从最基础的开始捏。从最基本的使用 K8S 开始，通过使用 Minikube 创建集群。<br>学习地址链接：<a href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/</a></p><h1 id="Kubernetes-集群"><a href="#Kubernetes-集群" class="headerlink" title="Kubernetes 集群"></a>Kubernetes 集群</h1><p>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。 Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。 Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源:</p><ul><li>Control Plane 调度整个集群</li><li>Nodes 负责运行应用</li></ul><p><img src="https://imgs.bencorn.com/imgs/Minikube-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4-2023-06-06-22-39-38.png" alt="集群图"></p><p>Control Plane 负责管理整个集群。 Control Plane 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色。每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Control Plane 通信的代理。 Node 还应该具有用于​​处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>Control Plane 管理集群，Node 用于托管正在运行的应用。</p><p>在 Kubernetes 上部署应用时，你告诉 Control Plane 启动应用容器。 Control Plane 就编排容器在集群的 Node 上运行。 Node 使用 Control Plane 暴露的 Kubernetes API 与 Control Plane 通信。终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h1 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h1><ul><li>目标：将一个示例应用部署到 Minikube。运行应用程序。查看应用日志。</li><li>环境：Ubuntu 20.04，自用笔记本</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载安装 minikube，链接：<a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb<br>sudo dpkg -i minikube_latest_amd64.deb<br></code></pre></td></tr></table></figure><p>安装完成过后，尝试启动一个集群。在 root 权限下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start<br></code></pre></td></tr></table></figure><p>如果不出意外的话，这个时候会出现没有 driver 的报错，这个时候可以按照链接里边儿的说明进行修复。这个地方，我准备采用 docker 来作为底层的 driver。链接：<a href="https://minikube.sigs.k8s.io/docs/drivers/docker/">https://minikube.sigs.k8s.io/docs/drivers/docker/</a></p><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><p>链接：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p><p>删除之前存在的一些依赖，包括 containerd、runc 等，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-get remove <span class="hljs-variable">$pkg</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>然后我们使用 apt repo 来进行安装，便于后续的更新。首先安装一些辅助的工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install ca-certificates curl gnupg<br></code></pre></td></tr></table></figure><p>添加 docker official GPG key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo install -m 0755 -d /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br>sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg<br></code></pre></td></tr></table></figure><p>添加 docker 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \<br>  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><p>安装 docker engine，并且运行验证，更新 docker 的时候也使用这些命令。可能会出现下载比较缓慢的情况，最好是有 ipv6，兴许会下载较快。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br>sudo docker run hello-world<br></code></pre></td></tr></table></figure><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>使用 docker 作为 driver 启动，或者可以设置 docker 作为默认 driver。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start --driver=docker  <br>minikube config <span class="hljs-built_in">set</span> driver docker<br></code></pre></td></tr></table></figure><p>然后这个时候，如果在 sudo su 模式下当做 minikube 的 driver，会提示报错；但是如果直接运行，又会使用 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock 的权限不够，因此需要将本机的用户添加到 docker 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span> &amp;&amp; newgrp docker<br></code></pre></td></tr></table></figure><p>如果不出意外的话，应该是可以运行起来了，而且会下载一些个相关的镜像,我只能说网速是真的慢。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>链接：<a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><ul><li>启动集群：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start --driver=docker<br></code></pre></td></tr></table></figure><ul><li>集群交互，通过 kubectl 与集群进行交互。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- get po -A<br>minikube kubectl -- get pods -A<br>minikube dashboard<br></code></pre></td></tr></table></figure><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>通过三种不同的方式来创建和部署应用。</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>创建一个简单的服务，并进行部署，将端口暴露到8080：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- create deployment hello-minikube --image=kicbase/echo-server:1.0<br>minikube kubectl -- expose deployment hello-minikube --<span class="hljs-built_in">type</span>=NodePort --port=8080<br></code></pre></td></tr></table></figure><p>稍等一会儿，然后观察部署情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- get services hello-minikube<br></code></pre></td></tr></table></figure><p>可以让 minikube 启动一个浏览器来观察：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube service hello-minikube<br></code></pre></td></tr></table></figure><p>可以使用 kubectl 来转发端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- port-forward service/hello-minikube 7080:8080<br></code></pre></td></tr></table></figure><p>这个时候，刚刚部署的这个服务，可以在 <a href="http://localhost:7080/">http://localhost:7080/</a> 上访问到了。</p><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>创建一个 LoadBalancer 负载均衡器，并且将其路由到集群外部可访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- create deployment balanced --image=kicbase/echo-server:1.0<br>minikube kubectl -- expose deployment balanced --<span class="hljs-built_in">type</span>=LoadBalancer --port=8080<br></code></pre></td></tr></table></figure><p>在另外一个 shell 窗口中，开起 tunnel 来为已部署的实例进行负载 IP 的路由。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube tunnel<br></code></pre></td></tr></table></figure><p>可以通过下列命令找到，已经可以路由访问的外部 IP 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl get services balanced<br></code></pre></td></tr></table></figure><p>现在该服务可以在 &lt;external&#x3D;ip&gt;:8080 中访问到。</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>开起 ingress addon 机制测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> ingress<br></code></pre></td></tr></table></figure><p>下边给出一个例子，创建一个 echo-server 服务并且一个 ingress 路由到这个服务。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">foo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo-app</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;kicbase/echo-server:1.0&#x27;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">foo</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bar-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">bar</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">bar-app</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;kicbase/echo-server:1.0&#x27;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bar-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">bar</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">http:</span><br>        <span class="hljs-attr">paths:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/foo</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">service:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">foo-service</span><br>                <span class="hljs-attr">port:</span><br>                  <span class="hljs-attr">number:</span> <span class="hljs-number">8080</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/bar</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">service:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">bar-service</span><br>                <span class="hljs-attr">port:</span><br>                  <span class="hljs-attr">number:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>K8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-Boot</title>
    <link href="/2023/04/25/xv6-Boot/"/>
    <url>/2023/04/25/xv6-Boot/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>学习 xv6 的同时，对照 Linux 0.11 源代码进行理解，希望自己能够有所提升吧。顺便给自己立一个 flag，看能不能花两个月的时间啃完。</p><p>xv6 <a href="./book-rev11.pdf">这儿有源文件</a> 是一个 UNIX 风格的操作系统。后续的代码，我会按照顺序，对其进行拆分，和一些自己理解的说明，其实基本上内容都是在 xv6 的这本书里。</p><h1 id="The-boot-loader"><a href="#The-boot-loader" class="headerlink" title="The boot loader"></a>The boot loader</h1><p>xv6 是基于 X86 的，可以参考的芯片手册是 i386。在实验部分有细讲。当 X86 的机子开机的时候，PC 会首先执行 BIOS（Basic Input&#x2F;Output System）程序，BIOS 是保存在主板上的非易失性存储器上。</p><p>BIOS 的任务是准备好 PC 的硬件，然后将控制权转移给操作系统。BIOS 首先会把控制权转移给保存在启动盘的第一个 512 字节的扇区内的代码，也就是 boot loader：一些汇编代码组成的指令，它主要把内核加载到内存。BIOS 把启动扇区内的 boot loader 加载到内存地址为 0x7c00 的地方，然后将处理器的 pc（%ip） 设置为该地址。</p><p>当 boot loader 开始执行，处理器模拟 Intel 8088 模式（16-bit 实模式）运行，并且 boot loader 的任务就是处理器设置成为现代处理器模式（32-bit 保护模式）。然后 boot loader 从磁盘把 xv6 的内核加载到内存，把控制权转交给内核。xv6 的 boot loader 分为两个文件，分别是 bootasm.S 和 bootmain.c</p><h2 id="Code-Assembly-bootstrap"><a href="#Code-Assembly-bootstrap" class="headerlink" title="Code: Assembly bootstrap"></a>Code: Assembly bootstrap</h2><p>boot loader 的第一条指令是 cli，它的作用是关中断（中断：硬件提供的调用操作系统的中断处理函数的机制）。为啥要关中断呢？现代处理器的 BIOS 实际上是一个小型的操作系统，BIOS 在运行的时候，可能也会使用一些中断处理函数来初始化硬件。但是，在运行 boot loader 的时候，BIOS 已经没有运行了，原来定义的中断处理函数例程不应该再被使用，所以就要先关中断。所以，也会猜到，当 xv6 操作系统就绪的时候，中断应该会再次被打开，而此时的中断服务例程是由 xv6 提供。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">#include <span class="hljs-string">&quot;asm.h&quot;</span><br>#include <span class="hljs-string">&quot;memlayout.h&quot;</span><br>#include <span class="hljs-string">&quot;mmu.h&quot;</span><br><br># Start the first <span class="hljs-meta">CPU</span>: switch to <span class="hljs-number">32</span>-bit protected mode, jump <span class="hljs-keyword">into</span> C.<br># The BIOS loads this code from the first sector of the hard disk <span class="hljs-keyword">into</span><br># memory <span class="hljs-meta">at</span> physical address <span class="hljs-number">0x7c00</span> <span class="hljs-keyword">and</span> starts executing <span class="hljs-keyword">in</span> real mode<br># with %cs=<span class="hljs-number">0</span> %ip=7c00.<br><span class="hljs-meta"></span><br><span class="hljs-meta">.code16</span>                       # Assemble for <span class="hljs-number">16</span>-bit mode<br><span class="hljs-meta">.globl</span> start<br><span class="hljs-symbol">start:</span><br>  <span class="hljs-keyword">cli</span>                         # BIOS enabled interrupts<span class="hljs-comment">; disable</span><br></code></pre></td></tr></table></figure><p>接下来就是老生常谈了，X86 的特点了，兼容性带来的一系列的特殊东西。<br>具体的细节可以查询这个手册：<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></p><p>现在，X86 处理器是运行在实模式的，它实际上是模拟 Intel 8088 运行机制。实模式下有以下特征，总共有 8 个 16-bit 的通用寄存器，但是 CPU 进行内存访问使用的是 20-bit 的地址。所以段寄存器 <code>%cs，%ds，%es，%ss</code>为 16-bit 的寄存器们提供额外的 4-bit 的寻址，来凑齐 20-bit，这样的机制是处理器本身的硬件结构设计导致的，至于为什么，估计是为了兼容性导致的了。当程序在访问内存的时候，处理器会自动将段寄存器的值乘以 16，然后加上这些寄存器里的内存地址。内存使用的种类通常会指明使用哪个寄存器：指令的获取使用代码段寄存器<code>%cs</code>，数据的读写使用数据段寄存器<code>%ds</code>。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Boot-2023-04-26-11-08-04.png" alt="relationship between logical，linear，physical address"></p><p>xv6 是假设 X86 的指令，对其内存操作数是使用的虚拟地址（virtual address），但是一条 X86 指令实际上使用的是逻辑地址（logical address）。一条逻辑地址包含段选择子（segment selector）和偏移（offset），可以写作<code>segment:offset</code>。常见的情况是，段是隐式的，程序实际上只操作偏移量。段处理相关的硬件，将逻辑地址转换为线性地址（linear address）。如果页相关的硬件支持打开的话，那么页处理相关的硬件将会把线性地址转换为物理地址（physical address）；如果页没有启用，那么处理器会将线性地址，直接当做物理地址来使用。</p><p>说明：虚拟地址就是程序操纵的地址，出于历史原因被这样叫做。其他三个地址概念是 Intel 处理器出现的硬件上的概念。</p><p>boot loader 是没有使用页机制的，逻辑地址被直接转换为线性地址，线性地址直接当做物理地址使用。xv6 配置硬件将逻辑地址翻译为线性地址，并且不做任何改变，所以此时的逻辑地址和线性地址是相等的。xv6 的虚拟地址是和 X86 的逻辑地址是相同的，并且和线性地址相同。（虽然很奇怪，段机制没有使用上的感觉，xv6 的逻辑是这样的）当页机制开起的时候，线性地址转换为物理地址就成了我们后续唯一需要重点关注的。</p><p>BIOS 并没有保证<code>%ds，%es，%ss</code>的值为某个特定的值，因此第一件事情就是对每个段寄存器清零。那为什么要用<code>xorw %ax,%ax</code>，而不是<code>movw $0,%ax</code>呢，在逻辑电路上边儿表示的话，应该是会更快一点。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># <span class="hljs-meta">Zero</span> data <span class="hljs-meta">segment</span> registers <span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-keyword">and</span> <span class="hljs-built_in">SS</span>.<br>xorw    %ax,%ax             # Set %ax to <span class="hljs-meta">zero</span><br>movw    %ax,%ds             # -&gt; Data <span class="hljs-meta">Segment</span><br>movw    %ax,%es             # -&gt; Extra <span class="hljs-meta">Segment</span><br>movw    %ax,%ss             # -&gt; Stack <span class="hljs-meta">Segment</span><br></code></pre></td></tr></table></figure><p>地址<code>segment:offset</code>可以达到 21-bit 的物理地址，但是 Intel 8088 只能使用 20-bit 的内存地址，所以丢弃掉了高地址<code>0xffff0 + 0xffff = 0x10ffef</code>,但是虚拟地址<code>0xffff:0xffff</code>指向物理地址的<code>0x0ffef</code>。早期的依赖硬件的一些软件会选择忽略到第 21 位地址，IBM 提供了一种方式让硬件更加的灵活。它是这样操作的，如果键盘控制器的输出端口的第 2 个bit位是关着的，那么第 21 位物理地址总是清零；如果是开着的，那么第 21 位地址是正常的。boot loader 必须将第 21 位地址位变为可用，把键盘控制器端口<code>0x64</code>和<code>0x60</code>设置为开起，即可达到该效果。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> # Physical address line A20 is tied to <span class="hljs-meta">zero</span> so that the first PCs <br>  # with <span class="hljs-number">2</span> MB would run software that assumed <span class="hljs-number">1</span> MB.  Undo that.<br><span class="hljs-symbol">seta20.1:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.1</span><br><br>  movb    <span class="hljs-number">$0</span>xd1,%al               # <span class="hljs-number">0xd1</span> -&gt; port <span class="hljs-number">0x64</span><br>  outb    %al,<span class="hljs-number">$0</span>x64<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">seta20.2:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.2</span><br><br>  movb    <span class="hljs-number">$0</span>xdf,%al               # <span class="hljs-number">0xdf</span> -&gt; port <span class="hljs-number">0x60</span><br>  outb    %al,<span class="hljs-number">$0</span>x60<br></code></pre></td></tr></table></figure><p>实模式 16-bit 的通用寄存器和段寄存器，最多只能访问 1M 的内存，X86 处理器从 80286 开始支持保护模式，增加了寻址能力，然后 80386 支持 32-bit 模式， 让寻址、寄存器等支持 32 位。</p><p>保护模式下，段寄存器是一个到段描述符表（segment descriptor table）的索引。每个表条目都指定一个物理地址基址（base），一个最大虚拟地址的限制（limit），一个权限控制 bit （permission bits）等组成。权限控制位在保护模式下，让操作系统内核保证代码只能使用自己的内存，这样就可以起到保护作用。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Boot-2023-04-27-09-37-32.png" alt="Segment in protected mode"></p><p>xv6 基本上没使用段，它主要使用的是页机制。xv6 的 boot loader 设置好短描述符表 gdt，让每个表项的基地址都为 0，同时每个表项的最大可能的限制都设置为 4G。段描述符表有一个空的表项，一个执行代码段表项，一个数据段表项。代码段描述符有一个标志（flag）位设置，它可以表示代码是运行在 32-bit 模式的，当这个开起的时候，boot loader 进入保护模式，逻辑地址就一条一条的被映射成为物理地址（注意这个时候还没有开起页机制，线性地址就是当做物理地址用）。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># Bootstrap GDT<br><span class="hljs-meta">.p2align</span> <span class="hljs-number">2</span>                                # force <span class="hljs-number">4</span> <span class="hljs-built_in">byte</span> alignment<br><span class="hljs-symbol">gdt:</span><br>  SEG_NULLASM                             # null <span class="hljs-built_in">seg</span><br>  SEG_ASM(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)   # code <span class="hljs-built_in">seg</span><br>  SEG_ASM(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)         # data <span class="hljs-built_in">seg</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gdtdesc:</span><br><span class="hljs-meta">  .word</span>   (gdtdesc - gdt - <span class="hljs-number">1</span>)             # sizeof(gdt) - <span class="hljs-number">1</span><br><span class="hljs-meta">  .long</span>   gdt                             # address gdt<br><br></code></pre></td></tr></table></figure><p>boot loader 执行 <code>lgdt</code> 指令，将段描述符表的信息 <code>gdtdesc</code> 加载到全局描述符表寄存器（GDT register，简称 gdtr），寄存器的值指向全局描述符表 <code>gdt</code>。当 boot loader 加载了全局描述符表寄存器，boot loader 通过将寄存器 <code>%cr0</code> 的 1 bit（CR0_PE） 位设置开起保护模式。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># Switch from real to protected mode.  Use a bootstrap GDT that makes<br># virtual addresses map directly to physical addresses so that the<br># effective memory map doesn<span class="hljs-string">&#x27;t change during the transition.</span><br><span class="hljs-string">lgdt    gdtdesc</span><br><span class="hljs-string">movl    %cr0, %eax</span><br><span class="hljs-string">orl     $CR0_PE, %eax</span><br><span class="hljs-string">movl    %eax, %cr0</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>开起保护模式过后，处理器不是立马就是在保护模式了，也并不是立刻就改变处理器是如何将逻辑地址转换成物理地址的。这个时候，只有当处理器从GDT读取并加载一个新的值到段寄存器，然后它才会改变内部的段机制相关的设置。由于我们不可以直接手动设置 <code>%cs</code>段寄存器，因此只有执行代码 <code>ljmp</code> 长跳转指令，才能保证段选择子被定义。长跳转所跳转的指令继续执行，由于此时 <code>%cs</code> 指向的代码段是 32-bit 的，所以处理器切换到 32-bit 模式。</p><p>此时，boot loader将处理器的运行模式，从 8088 模式，切换到 80286 模式，最后切换到了 80386 模式。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># PAGEBREAK!<br># Complete the transition to <span class="hljs-number">32</span>-bit protected mode by using a long <span class="hljs-keyword">jmp</span><br># to reload %cs <span class="hljs-keyword">and</span> %eip.  The <span class="hljs-meta">segment</span> descriptors are set <span class="hljs-meta">up</span> with no<br># translation, so that the mapping is still the identity mapping.<br>ljmp    $(SEG_KCODE&lt;&lt;<span class="hljs-number">3</span>), $start32<br><br></code></pre></td></tr></table></figure><p>进入 32-bit 模式过后，boot loader 第一件事情，是设置代码段寄存器的值为 <code>SEG_KDATA</code>。现在逻辑地址仍然是直接映射到物理地址的，这个时候为了支持C代码的运行，需要在未使用的内存区域，建立好堆栈。目前，内存中从 0xa0000 到 0x100000 是设备内存区，然后 xv6 的内核将放置在 0x100000。boot loader 则是放置在 0x7c00 到 0x7e00（512 bytes）的区域。其他的任何空闲的区域都可以作为堆栈来使用，boot loader 选择 0x7c00 作为堆栈的栈顶，堆栈将从该地址开始往下压栈，一直直到 0x0000，这样可以很好的远离 boot loader。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta"></span><br><span class="hljs-meta">.code32</span>  # Tell assembler to generate <span class="hljs-number">32</span>-bit code now.<br><span class="hljs-symbol">start32:</span><br>  # Set <span class="hljs-meta">up</span> the protected-mode data <span class="hljs-meta">segment</span> registers<br>  movw    $(SEG_KDATA&lt;&lt;<span class="hljs-number">3</span>), %ax    # Our data <span class="hljs-meta">segment</span> selector<br>  movw    %ax, %ds                # -&gt; <span class="hljs-built_in">DS</span>: Data <span class="hljs-meta">Segment</span><br>  movw    %ax, %es                # -&gt; <span class="hljs-built_in">ES</span>: Extra <span class="hljs-meta">Segment</span><br>  movw    %ax, %ss                # -&gt; <span class="hljs-built_in">SS</span>: Stack <span class="hljs-meta">Segment</span><br>  movw    <span class="hljs-number">$0</span>, %ax                 # <span class="hljs-meta">Zero</span> segments <span class="hljs-keyword">not</span> ready for use<br>  movw    %ax, %fs                # -&gt; <span class="hljs-built_in">FS</span><br>  movw    %ax, %gs                # -&gt; <span class="hljs-built_in">GS</span><br><br></code></pre></td></tr></table></figure><p>最后，boot loader 调用 C 函数 bootmain。bootmain 的主要任务是，加载并且运行操作系统的内核。后续的代码主要是为了与模拟器做准备，call bootmain 它仅在出现问题时返回。在这种情况下，代码会在端口 0x8a00 上发送一些输出字。在真正的硬件上，没有设备连接到那个端口，所以这段代码什么都不做。如果引导加载程序在 PC 模拟器中运行，端口 0x8a00 连接到模拟器本身，并且可以将控制权传回模拟器。不管是否是模拟器，代码都会执行一个无限循环。真正的引导加载程序可能会首先尝试打印错误消息。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>  # Set <span class="hljs-meta">up</span> the stack pointer <span class="hljs-keyword">and</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">into</span> C.<br>  movl    $start, %esp<br>  <span class="hljs-keyword">call</span>    bootmain<br><br>  # If bootmain returns (it shouldn<span class="hljs-string">&#x27;t), trigger a Bochs</span><br><span class="hljs-string">  # breakpoint if running under Bochs, then loop.</span><br><span class="hljs-string">  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00</span><br><span class="hljs-string">  movw    %ax, %dx</span><br><span class="hljs-string">  outw    %ax, %dx</span><br><span class="hljs-string">  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00</span><br><span class="hljs-string">  outw    %ax, %dx</span><br><span class="hljs-string">spin:</span><br><span class="hljs-string">  jmp     spin</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="Code-C-bootstrap"><a href="#Code-C-bootstrap" class="headerlink" title="Code: C bootstrap"></a>Code: C bootstrap</h2><p>boot loader 的 C 语言部分，bootmain.c 主要是在磁盘的第二个扇区寻找可执行的内核，内核文件以 ELF 二进制文件的格式保存。读取内核二进制文件的时候，首先读取 ELF 的 header，bootmain 首先读取 ELF 文件的前 4096 bytes，将其拷贝到内存地址为 0x10000的位置。然后就是检测，将要读取的是否是 ELF 文件，如果不是，那么直接返回，bootasm.S定义好的错误处理进行处理；如果是的话，接着 header 后边的内容，从 phoff 字节开始写入到内存地址为 paddr 的位置。Bootmain 调用 readseg 从磁盘加载数据并调用 stosb 将段的剩余部分归零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Boot loader.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Part of the boot block, along with bootasm.S, which calls bootmain().</span><br><span class="hljs-comment">// bootasm.S has put the processor into protected 32-bit mode.</span><br><span class="hljs-comment">// bootmain() loads an ELF kernel image from the disk starting at</span><br><span class="hljs-comment">// sector 1 and then jumps to the kernel entry routine.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;elf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;x86.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTSIZE  512</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">readseg</span><span class="hljs-params">(uchar*, uint, uint)</span>;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bootmain</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> *<span class="hljs-title">elf</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br>  <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>);<br>  uchar* pa;<br><br>  elf = (<span class="hljs-keyword">struct</span> elfhdr*)<span class="hljs-number">0x10000</span>;  <span class="hljs-comment">// scratch space</span><br><br>  <span class="hljs-comment">// Read 1st page off disk</span><br>  readseg((uchar*)elf, <span class="hljs-number">4096</span>, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Is this an ELF executable?</span><br>  <span class="hljs-keyword">if</span>(elf-&gt;magic != ELF_MAGIC)<br>    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// let bootasm.S handle error</span><br><br>  <span class="hljs-comment">// Load each program segment (ignores ph flags).</span><br>  ph = (<span class="hljs-keyword">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);<br>  eph = ph + elf-&gt;phnum;<br>  <span class="hljs-keyword">for</span>(; ph &lt; eph; ph++)&#123;<br>    pa = (uchar*)ph-&gt;paddr;<br>    readseg(pa, ph-&gt;filesz, ph-&gt;off);<br>    <span class="hljs-keyword">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)<br>      stosb(pa + ph-&gt;filesz, <span class="hljs-number">0</span>, ph-&gt;memsz - ph-&gt;filesz);<br>  &#125;<br><br>  <span class="hljs-comment">// Call the entry point from the ELF header.</span><br>  <span class="hljs-comment">// Does not return!</span><br>  entry = (<span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span>))(elf-&gt;entry);<br>  entry();<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">waitdisk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// Wait for disk ready.</span><br>  <span class="hljs-keyword">while</span>((inb(<span class="hljs-number">0x1F7</span>) &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x40</span>)<br>    ;<br>&#125;<br><br><span class="hljs-comment">// Read a single sector at offset into dst.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, uint offset)</span><br>&#123;<br>  <span class="hljs-comment">// Issue command.</span><br>  waitdisk();<br>  outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// count = 1</span><br>  outb(<span class="hljs-number">0x1F3</span>, offset);<br>  outb(<span class="hljs-number">0x1F4</span>, offset &gt;&gt; <span class="hljs-number">8</span>);<br>  outb(<span class="hljs-number">0x1F5</span>, offset &gt;&gt; <span class="hljs-number">16</span>);<br>  outb(<span class="hljs-number">0x1F6</span>, (offset &gt;&gt; <span class="hljs-number">24</span>) | <span class="hljs-number">0xE0</span>);<br>  outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);  <span class="hljs-comment">// cmd 0x20 - read sectors</span><br><br>  <span class="hljs-comment">// Read data.</span><br>  waitdisk();<br>  insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE/<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span><br><span class="hljs-comment">// Might copy more than asked.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readseg</span><span class="hljs-params">(uchar* pa, uint count, uint offset)</span><br>&#123;<br>  uchar* epa;<br><br>  epa = pa + count;<br><br>  <span class="hljs-comment">// Round down to sector boundary.</span><br>  pa -= offset % SECTSIZE;<br><br>  <span class="hljs-comment">// Translate from bytes to sectors; kernel starts at sector 1.</span><br>  offset = (offset / SECTSIZE) + <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span><br>  <span class="hljs-comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span><br>  <span class="hljs-comment">// we load in increasing order.</span><br>  <span class="hljs-keyword">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)<br>    readsect(pa, offset);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bootmain 调用 readseg 从磁盘加载数据并调用 stosb 将段的剩余部分归零。Stosb 使用 x86 指令 rep stosb 来初始化内存块的每个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">stosb</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> data, <span class="hljs-type">int</span> cnt)</span><br>&#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cld; rep stosb&quot;</span> :</span><br><span class="hljs-params">               <span class="hljs-string">&quot;=D&quot;</span> (addr), <span class="hljs-string">&quot;=c&quot;</span> (cnt) :</span><br><span class="hljs-params">               <span class="hljs-string">&quot;0&quot;</span> (addr), <span class="hljs-string">&quot;1&quot;</span> (cnt), <span class="hljs-string">&quot;a&quot;</span> (data) :</span><br><span class="hljs-params">               <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>内核经过编译和链接，在虚拟地址为 0x80100000 中找到内核。因此，函数调用指令必须类似于 call 0x801xxxxx 的目标地址。这个地址在kernel.ld中配置0x80100000是一个比较高的地址，朝向32位地址空间的末尾； 第 2 章解释了做出这种选择的原因。 在这么高的地址可能没有任何物理内存。 一旦内核开始执行，它将设置分页硬件来映射虚拟地址 0x80100000 到 0x00100000 开始的物理地址；内核假定在这个低地址有物理内存。但是，这个时候 boot loader 未启用分页机制。于是，编写链接文件的时候，kernel.ld 指定 ELF paddr 从 0x00100000 开始，这会导致 boot loader 将内核复制到 0x00100000 低物理地址，当开起分页机制过后，分页硬件将会将 0x80100000 最终指向该地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">/* Simple linker script for the JOS kernel.<br>   See the GNU ld <span class="hljs-string">&#x27;info&#x27;</span> manual (<span class="hljs-string">&quot;info ld&quot;</span>) to learn the syntax. */<br><br>OUTPUT_FORMAT(<span class="hljs-string">&quot;elf32-i386&quot;</span>, <span class="hljs-string">&quot;elf32-i386&quot;</span>, <span class="hljs-string">&quot;elf32-i386&quot;</span>)<br>OUTPUT_ARCH(i386)<br>ENTRY(_start)<br><br>SECTIONS<br>&#123;<br>/* Link the kernel <span class="hljs-meta">at</span> this address: <span class="hljs-string">&quot;.&quot;</span> means the current address */<br>        /* Must be equal to KERNLINK */<br>. = <span class="hljs-number">0x80100000</span><span class="hljs-comment">;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.text</span> : <span class="hljs-meta">AT</span>(<span class="hljs-number">0x100000</span>) &#123;<br>*(.text .stub .text.* .gnu<span class="hljs-number">.</span>linkonce<span class="hljs-number">.</span>t.*)<br>&#125;<br><br>PROVIDE(etext = .)<span class="hljs-comment">;/* Define the &#x27;etext&#x27; symbol to this value */</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.rodata</span> : &#123;<br>*(.rodata .rodata.* .gnu<span class="hljs-number">.</span>linkonce<span class="hljs-number">.</span>r.*)<br>&#125;<br><br>/* Include debugging information <span class="hljs-keyword">in</span> kernel memory */<br><span class="hljs-meta">.stab</span> : &#123;<br>PROVIDE(__STAB_BEGIN__ = .)<span class="hljs-comment">;</span><br>*(.stab)<span class="hljs-comment">;</span><br>PROVIDE(__STAB_END__ = .)<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">.stabstr</span> : &#123;<br>PROVIDE(__STABSTR_BEGIN__ = .)<span class="hljs-comment">;</span><br>*(.stabstr)<span class="hljs-comment">;</span><br>PROVIDE(__STABSTR_END__ = .)<span class="hljs-comment">;</span><br>&#125;<br><br>/* Adjust the address for the data <span class="hljs-meta">segment</span> to the next page */<br>. = <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">0x1000</span>)<span class="hljs-comment">;</span><br><br>/* Conventionally, Unix linkers provide pseudo-symbols<br> * etext, edata, <span class="hljs-keyword">and</span> end, <span class="hljs-meta">at</span> the end of the text, data, <span class="hljs-keyword">and</span> bss.<br> * For the kernel mapping, we need the address <span class="hljs-meta">at</span> the beginning<br> * of the data <span class="hljs-meta">section</span>, but that<span class="hljs-string">&#x27;s not one of the conventional</span><br><span class="hljs-string"> * symbols, because the convention started before there was a</span><br><span class="hljs-string"> * read-only rodata section between text and data. */</span><br><span class="hljs-string">PROVIDE(data = .);</span><br><span class="hljs-string"></span><br><span class="hljs-string">/* The data segment */</span><br><span class="hljs-string">.data : &#123;</span><br><span class="hljs-string">*(.data)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">PROVIDE(edata = .);</span><br><span class="hljs-string"></span><br><span class="hljs-string">.bss : &#123;</span><br><span class="hljs-string">*(.bss)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">PROVIDE(end = .);</span><br><span class="hljs-string"></span><br><span class="hljs-string">/DISCARD/ : &#123;</span><br><span class="hljs-string">*(.eh_frame .note.GNU-stack)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>boot loader 的最后一步是调用内核的入口，也就是调用内核开始执行的地方。xv6 的入口地址是 0x10000c。<br><img src="https://imgs.bencorn.com/imgs/xv6-Boot-2023-04-27-19-55-32.png" alt="xv6 kernel entry point"></p><p>按照惯例，_start 符号指定 ELF 入口点，它在文件 entry.S 中定义。 由于xv6还没有设置虚拟内存，所以xv6的entry point就是entry的物理地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># By convention, the _start symbol specifies the ELF entry point.<br># Since we haven<span class="hljs-string">&#x27;t set up virtual memory yet, our entry point is</span><br><span class="hljs-string"># the physical address of &#x27;</span>entry<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">.globl _start</span><br><span class="hljs-string">_start = V2P_WO(entry)</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>到这个地方 xv6 的 boot loader 就基本上结束了，嗯，xv6 的设计的话，还是进行了简化，但是确实是可行的，其中段机制的使用很少，然后就是由于页机制迟迟没有打开，先是在物理内存上，把整个操作系统安排好了，再做页机制的映射，后续对照一下 linux 看一下是怎么做到的。</p>]]></content>
    
    
    <categories>
      
      <category>xv6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chronos和simplescalar安装</title>
    <link href="/2022/09/20/chronos%E5%92%8Csimplescalar%E5%AE%89%E8%A3%85/"/>
    <url>/2022/09/20/chronos%E5%92%8Csimplescalar%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="安装预先准备"><a href="#安装预先准备" class="headerlink" title="安装预先准备"></a>安装预先准备</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>ubuntu 9.04（32-bit）   Virtualbox</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p> <a href="https://uestc.feishu.cn/file/boxcnoDny8joPj3GnKWb2l6vtRe">ubuntu-9.04-desktop-i386.iso</a>        </p><h2 id="chronos安装包"><a href="#chronos安装包" class="headerlink" title="chronos安装包"></a>chronos安装包</h2><p><a href="https://uestc.feishu.cn/file/boxcnLYNkH68ZIZbNGTtE1uOBCg">chronos2.0版本安装包.zip</a> </p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225317.png" alt="虚拟机"></p><p>正常按照步骤安装系统</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225327.png" alt="安装系统"></p><p>安装好系统之后，切换源，教程如下，笔者使用的中科大源：</p><p><a href="https://mirrors.ustc.edu.cn/help/ubuntu-old-releases.html">https://mirrors.ustc.edu.cn/help/ubuntu-old-releases.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225345.png" alt="更换APT源"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/ubuntu-old-releases/g&#x27; /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>更换完源后，安装桌面工具,点击虚拟机客户端，生成插件到桌面并执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo sh VBoxLinuxAdditions.run<br></code></pre></td></tr></table></figure><p>安装相关工具包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo apt-get install vim<br>sudo apt upgrade<br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><h2 id="Chronos安装"><a href="#Chronos安装" class="headerlink" title="Chronos安装"></a>Chronos安装</h2><p>将chronos传入虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">scp ./chronos2.0.zip chronos@192.168.2.108<br></code></pre></td></tr></table></figure><p>创建chronos文件夹，simplescalar将安装包内容解压到此</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> simplescalar<br>unzip chronos2.0.zip<br><span class="hljs-built_in">mkdir</span> simplescalar<br><span class="hljs-built_in">mv</span> simplesim-3.0.tgz simplescalar/<br></code></pre></td></tr></table></figure><h3 id="安装Chronos2-0分析器"><a href="#安装Chronos2-0分析器" class="headerlink" title="安装Chronos2.0分析器"></a><strong>安装Chronos2.0分析器</strong></h3><p>添加全局路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">export</span> IDIR=<span class="hljs-variable">$HOME</span>/chronos<br></code></pre></td></tr></table></figure><p>安装相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install flex-old<br>sudo apt-get install bison<br>sudo apt-get install openjdk-6-* -y<br></code></pre></td></tr></table></figure><p>编译est 分析器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> est &amp;&amp; make<br><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">cd</span> gui &amp;&amp; make<br></code></pre></td></tr></table></figure><h3 id="安装lp-solve"><a href="#安装lp-solve" class="headerlink" title="安装lp_solve"></a><strong>安装lp_solve</strong></h3><p><strong>将其含有文件全部解压</strong></p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225400.png" alt="解压文件"></p><h3 id="安装simplescalar"><a href="#安装simplescalar" class="headerlink" title="安装simplescalar"></a><strong>安装simplescalar</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">cd</span> simplescalar <br>sudo apt-get install gcc-3.4<br></code></pre></td></tr></table></figure><p>添加simplescalar环境变量</p><p>先查看平台,看是i686或是i386</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">uname</span> -m<br><span class="hljs-built_in">export</span> CC=<span class="hljs-string">&quot;gcc-3.4&quot;</span><br><span class="hljs-built_in">export</span> HOST=i686-unknown-linux <br><span class="hljs-built_in">export</span> TARGET=sslittle-na-sstrix <br><span class="hljs-built_in">export</span> IDIR=<span class="hljs-variable">$HOME</span>/chronos/simplescalar<br></code></pre></td></tr></table></figure><p>解压simplescalar</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">tar xvf simpletools-2v0.tgz <br><span class="hljs-built_in">rm</span> -rf gcc-2.6.3<br>tar -xvzf simpleutils-990811.tar.gz<br></code></pre></td></tr></table></figure><h4 id="Simplescalar-utils编译安装"><a href="#Simplescalar-utils编译安装" class="headerlink" title="Simplescalar utils编译安装"></a><strong>Simplescalar utils编译安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">./configure --host=<span class="hljs-variable">$HOST</span> --target=<span class="hljs-variable">$TARGET</span> --with-gnu-as --with-gnu-ld --prefix=<span class="hljs-variable">$IDIR</span> <br>make CC=gcc-3.4 <br>sudo make install CC=gcc-3.4<br></code></pre></td></tr></table></figure><p>到此utils工具包安装完成</p><h4 id="Simplesim-3-0安装"><a href="#Simplesim-3-0安装" class="headerlink" title="Simplesim-3.0安装"></a><strong>Simplesim-3.0安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">make config-pisa<br>make CC=gcc-3.4<br></code></pre></td></tr></table></figure><h4 id="Simplescalar-gcc安装"><a href="#Simplescalar-gcc安装" class="headerlink" title="Simplescalar gcc安装"></a><strong>Simplescalar gcc安装</strong></h4><p>操作目录：gcc-2.7.2.3&#x2F;</p><p>PS:$IDIR&#x3D;&amp;HOME&#x2F;chronos&#x2F;simplescalar此时IDIR已改变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">tar xvzf gcc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$IDIR</span>/sslittle-na-sstrix/bin<br>./configure --host=<span class="hljs-variable">$HOST</span> --target=<span class="hljs-variable">$TARGET</span> --with-gnu-as --with-gnu-ld --prefix=<span class="hljs-variable">$IDIR</span>  <br><br>make LANGUAGES=<span class="hljs-string">&quot;c c++&quot;</span> CFLAGS=-O3 CC=gcc-3.4<br></code></pre></td></tr></table></figure><p>此时会报错：</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225419.png" alt="报错"></p><p>修改cxxmain.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">chmod</span> +w cxxmain.c<br></code></pre></td></tr></table></figure><p>在第cxxxmain.c 2978与2979行注释掉,修改后重新make：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">make clean <br>make <br></code></pre></td></tr></table></figure><p>备份相关文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">cd</span> sslittle-na-sstrix/include/sys <span class="hljs-built_in">cp</span> cdefs.h cdefs.h.bak<br><span class="hljs-built_in">cp</span> patched/sys/cdefs.h ../sslittle-na-sstrix/include/sys/<br>make enquire CC=gcc-3.4<br></code></pre></td></tr></table></figure><p>测试simlpescalar交叉编译的程序是否能够运行，用编译器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">../simplesim-3.0/sim-safe ./enquire -f &gt; float.h-cross<br></code></pre></td></tr></table></figure><p>出现以下结果则安装成功</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225436.png" alt="simplescalar安装成功"></p><p>将编译好的gcc安装到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo make install LANGUAGES=<span class="hljs-string">&quot;c c++&quot;</span> CFLAGS=-O3 CC=gcc-3.4 PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/chronos/simplescalar/bin<br></code></pre></td></tr></table></figure><p>测试simplescalar-gcc是否安装成功</p><p>写一个简单的c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stido.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>sudo make install LANGUAGES=<span class="hljs-string">&quot;c c++&quot;</span> CFLAGS=-O3 CC=gcc<span class="hljs-number">-3.4</span> PATH=$PATH:$HOME/chronos/simplescalar/bin<br>simplescalar/simplesim<span class="hljs-number">-3.0</span>/sim-safe a.out <br></code></pre></td></tr></table></figure><p>切换命令解释器以适配chronos</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">sudo mv /bin/sh sh.bak<br>sudo ln /bin/bash /bin/sh<br></code></pre></td></tr></table></figure><p>此环境默认jre为：</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920230155.png" alt="jre安装"></p><p>运行chronos</p><p>当前路径：chronos</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> gui<br>./gui.sh<br></code></pre></td></tr></table></figure><h1 id="软件运行结果"><a href="#软件运行结果" class="headerlink" title="软件运行结果"></a>软件运行结果</h1><p>出现如下界面：</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225446.png" alt="chronos运行"></p><p>到此安装成功，配置好相关文件即可运行。</p><p>运行结果展示如下：</p><h2 id="processor配置"><a href="#processor配置" class="headerlink" title="processor配置"></a>processor配置</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920230300.png" alt="processor配置"></p><h2 id="循环边界配置"><a href="#循环边界配置" class="headerlink" title="循环边界配置"></a>循环边界配置</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225505.png" alt="insertsort分析"></p><h2 id="WCET分析结果"><a href="#WCET分析结果" class="headerlink" title="WCET分析结果"></a>WCET分析结果</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225517.png" alt="分析结果1"></p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225531.png" alt="分析结果2"></p>]]></content>
    
    
    <categories>
      
      <category>WCET</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WCET</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW4 xv6 lazy page allocation</title>
    <link href="/2022/07/11/HW4-xv6-lazy-page-allocation/"/>
    <url>/2022/07/11/HW4-xv6-lazy-page-allocation/</url>
    
    <content type="html"><![CDATA[<h1 id="Homework-xv6-lazy-page-allocation"><a href="#Homework-xv6-lazy-page-allocation" class="headerlink" title="Homework: xv6 lazy page allocation"></a>Homework: xv6 lazy page allocation</h1><p> 本次作业要求实现一个对堆内存的延迟分配。</p><p> 实验链接：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html</a></p><h2 id="Part-One：Eliminate-allocation-from-sbrk"><a href="#Part-One：Eliminate-allocation-from-sbrk" class="headerlink" title="Part One：Eliminate allocation from sbrk()"></a>Part One：Eliminate allocation from sbrk()</h2><p> 第一个任务是删除掉sbrk(n)系统调用实现，在sysproc.c中，手动注释掉该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  <span class="hljs-comment">/*if(growproc(n) &lt; 0)</span><br><span class="hljs-comment">    return -1;</span><br><span class="hljs-comment">    */</span><br>  myproc()-&gt;sz += n;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p> 将<code>growproc(n)</code>给注释掉过后，会出现以下的问题，该中断可以在trap.c中找到，终中断号14，发生page fault，在虚拟地址的0x4004引起该错误。</p><p><img src="https://imgs.bencorn.com/imgs/2022/07/11/20220711152745.png" alt="page fault"></p><p> 为什么会发生该错误呢？当我们注销掉<code>growproc(n)</code>过后？首先，<code>growproc(n)</code>函数，如果n是正数，会分配1个或者多个的物理内存页，并且将他们映射到调用该系统调用的进程空间的顶部；如果n是负数，则会从进程地址空间取消一个或者多个页并且释放相对应的物理页。也就是说，虽然我们改了进程的地址空间大小，但是没有具体映射到物理内存，就会导致该虚拟内存页错误。</p><h2 id="Part-Two：Lazy-allocation"><a href="#Part-Two：Lazy-allocation" class="headerlink" title="Part Two：Lazy allocation"></a>Part Two：Lazy allocation</h2><p> 在trap.c中实现一个延迟分配，只需要当虚拟内存发生页错误的时候，再触发分配物理内存。</p><p> 首先，我们可以从cprintf中发现，发生错误的地址是保存在cr2寄存器中，我们需要将该地址读出来，然后拿到它地址开始到一整个内存页的大小，然后未这个虚拟内存也创建物理内存页，并且进行映射。按照这样的思路喝题目提示，我们可以进行响应的代码编写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// page fault implemation</span><br><br><span class="hljs-keyword">if</span>(tf-&gt;trapno == T_PGFLT)&#123;<br>    uint va = PGROUNDDOWN(rcr2());<br>    <span class="hljs-keyword">if</span>(va &lt; myproc()-&gt;sz)&#123;<br>        <span class="hljs-type">char</span> *mem = kalloc();<br>        <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>            cprintf(<span class="hljs-string">&quot;out of memory!\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    cprintf(<span class="hljs-string">&quot;kernel faulting in page at %x\n&quot;</span>, va);<br>    mappages(myproc()-&gt;pgdir, (<span class="hljs-type">char</span> *)va, PGSIZE, V2P(mem), PTE_W | PTE_U);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 此处的mappages函数，在vm.c中是一个静态的函数，因此需要将其static修改掉，并且在trap.c中添加其函数定义进行链接<code> int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);</code></p><p><img src="https://imgs.bencorn.com/imgs/2022/07/13/20220713171334.png" alt="lazy allocation结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW3 system calls</title>
    <link href="/2022/07/01/HW3-system-calls/"/>
    <url>/2022/07/01/HW3-system-calls/</url>
    
    <content type="html"><![CDATA[<h1 id="Homework-xv6-system-calls"><a href="#Homework-xv6-system-calls" class="headerlink" title="Homework: xv6 system calls"></a>Homework: xv6 system calls</h1><p> 参考boot homework中的内容，为xv6操作系统添加一个系统调用。</p><p> 链接：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html</a></p><h2 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h2><p> 修改xv6内核，为每个系统调用打印一行，打印系统调用的名称和返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">char</span> syscall_name[][<span class="hljs-number">10</span>] = &#123;<br>[SYS_fork]      <span class="hljs-string">&quot;fork&quot;</span>,<br>[SYS_exit]      <span class="hljs-string">&quot;exit&quot;</span>,<br>[SYS_wait]      <span class="hljs-string">&quot;wait&quot;</span>,<br>[SYS_pipe]      <span class="hljs-string">&quot;pipe&quot;</span>,<br>[SYS_read]      <span class="hljs-string">&quot;read&quot;</span>,<br>[SYS_kill]      <span class="hljs-string">&quot;kill&quot;</span>,<br>[SYS_exec]      <span class="hljs-string">&quot;exec&quot;</span>,<br>[SYS_fstat]     <span class="hljs-string">&quot;fstat&quot;</span>,<br>[SYS_chdir]     <span class="hljs-string">&quot;chdir&quot;</span>,<br>[SYS_dup]       <span class="hljs-string">&quot;dup&quot;</span>,<br>[SYS_getpid]    <span class="hljs-string">&quot;getpid&quot;</span>,<br>[SYS_sbrk]      <span class="hljs-string">&quot;sbrk&quot;</span>,<br>[SYS_sleep]     <span class="hljs-string">&quot;sleep&quot;</span>,<br>[SYS_uptime]    <span class="hljs-string">&quot;uptime&quot;</span>,<br>[SYS_open]      <span class="hljs-string">&quot;open&quot;</span>,<br>[SYS_write]     <span class="hljs-string">&quot;write&quot;</span>,<br>[SYS_mknod]     <span class="hljs-string">&quot;mknod&quot;</span>,<br>[SYS_unlink]    <span class="hljs-string">&quot;unlink&quot;</span>,<br>[SYS_link]      <span class="hljs-string">&quot;link&quot;</span>,<br>[SYS_mkdir]     <span class="hljs-string">&quot;mkdir&quot;</span>,<br>[SYS_close]     <span class="hljs-string">&quot;close&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> 首先类似于指针函数那样，准备一个名称数组，便于快速打印；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  num = curproc-&gt;tf-&gt;eax;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    curproc-&gt;tf-&gt;eax = syscalls[num]();<br>    cprintf(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, syscall_name[num], curproc-&gt;tf-&gt;eax);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            curproc-&gt;pid, curproc-&gt;name, num);<br>    curproc-&gt;tf-&gt;eax = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 然后添加打印具体的系统调用名称即可，根据x86的函数调用堆栈关系，返回值保存在eax寄存器之中，因此需要将进程页帧中的eax寄存器的值进行打印。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  num = curproc-&gt;tf-&gt;eax;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    curproc-&gt;tf-&gt;eax = syscalls[num]();<br>    cprintf(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, syscall_name[num], curproc-&gt;tf-&gt;eax);<br>    <span class="hljs-type">int</span> *fd;<br>    <span class="hljs-keyword">switch</span>(num)&#123;<br>        <span class="hljs-keyword">case</span> SYS_fork:<br>            cprintf(<span class="hljs-string">&quot;sys_fork no args\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SYS_exit:<br>            cprintf(<span class="hljs-string">&quot;sys_exit no args\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SYS_wait:<br>            cprintf(<span class="hljs-string">&quot;sys_wait no args\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SYS_pipe:<br>            <span class="hljs-keyword">if</span>(argptr(<span class="hljs-number">0</span>, (<span class="hljs-type">void</span>*)&amp;fd, <span class="hljs-number">2</span>*<span class="hljs-keyword">sizeof</span>(fd[<span class="hljs-number">0</span>]))&lt;<span class="hljs-number">0</span>)&#123;<br>                cprintf(<span class="hljs-string">&quot;error: sys_pipe cannot get the args\n&quot;</span>);<br>            &#125;<br>            cprintf(<span class="hljs-string">&quot;sys_pipe args: %p %p&quot;</span>,&amp;fd[<span class="hljs-number">0</span>],&amp;fd[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            curproc-&gt;pid, curproc-&gt;name, num);<br>    curproc-&gt;tf-&gt;eax = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 同样打印系统调用时的参数，仍然根据x86的堆栈关系，进行打印,具体的用法，在syscall.c的前边儿给出了几个辅助函数，进程的context内保存了%esp，通过从堆栈内部查找指定字节长度的值，来进行获取参数，同时参考具体的系统调用的程序来进行参数的获取于打印。</p><h2 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h2><p> 写一个用户态的应用，进行系统调用，给出具体的UTC时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span> <span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (date(&amp;r)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;date failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;UTC date: %d-%d-%d %d:%d:%d\n&quot;</span>, r.year, r.month, r.day, r.hour, r.minute, r.second);<br>  <span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p> 首先添加一个用户程序，进行系统调用，并且将具体的日期输出到标准输出端口。同时在Makefile里边儿添加用户调用的编译选项。</p><p><img src="https://imgs.bencorn.com/imgs/2022/07/06/20220706234759.png" alt="uptime 系统调用组成"></p><p> 参照uptime的系统调用组成部分，对每个文件内的内容进行添加，分别是：</p><ul><li>在user.h中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">date</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rtcdate*)</span>;<br></code></pre></td></tr></table></figure><ul><li>在usys.S中添加</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SYSCALL(date)<br></code></pre></td></tr></table></figure><ul><li>在syscall.h中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_date   22</span><br></code></pre></td></tr></table></figure><ul><li>在文件syscall.c中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// syscalls array add</span><br>[SYS_date]    sys_date,<br></code></pre></td></tr></table></figure><ul><li>在文件sysproc.c中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span>*;</span><br>    <span class="hljs-keyword">if</span> (argptr(<span class="hljs-number">0</span>, (<span class="hljs-type">char</span>**)&amp;r, <span class="hljs-keyword">sizeof</span>(*r)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    cmostime(r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 按照上述运行结果：</p><p><img src="https://imgs.bencorn.com/imgs/2022/07/06/20220706235454.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPP Labs</title>
    <link href="/2022/03/22/VPP-Labs/"/>
    <url>/2022/03/22/VPP-Labs/</url>
    
    <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ul><li>Debian 10</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc g++ vim cmake curl wget ifconfig bridge-utils -y<br></code></pre></td></tr></table></figure><ul><li>repo添加</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://packagecloud.io/install/repositories/fdio/release/script.deb.sh | sudo bash<br></code></pre></td></tr></table></figure><ul><li>安装VPP</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install vpp vpp-plugin-core vpp-plugin-dpdk -y<br><span class="hljs-comment"># 可选择的安装</span><br><span class="hljs-comment"># sudo apt-get install vpp vpp-plugin-core vpp-plugin-dpdk vpp-dbg vpp-dev vpp-ext-deps vpp-api-python vpp-api-java -y</span><br></code></pre></td></tr></table></figure><h1 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h1><h2 id="host-vpp连接实验"><a href="#host-vpp连接实验" class="headerlink" title="host-vpp连接实验"></a>host-vpp连接实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/interface.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/interface.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/03/22/20220322201107.jpeg" alt="Figure: Create Interface Topology"></p><p>根据如上的拓扑图，创建veth</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip <span class="hljs-built_in">link</span> add name vpp1out <span class="hljs-built_in">type</span> veth peer name vpp1host<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev vpp1out up<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev vpp1host up<br></code></pre></td></tr></table></figure><p>添加IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip addr add 10.10.1.1/24 dev vpp1host<br>ip addr show vpp1host<br></code></pre></td></tr></table></figure><p>创建vpp接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -eaf | grep vpp<br>sudo /usr/bin/vpp -c vpp1.conf<br></code></pre></td></tr></table></figure><p>vpp1.conf内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">unix <span class="hljs-punctuation">&#123;</span>cli-listen /run/vpp/cli-vpp1.sock<span class="hljs-punctuation">&#125;</span><br>api-segment <span class="hljs-punctuation">&#123;</span> prefix vpp1 <span class="hljs-punctuation">&#125;</span><br>plugins <span class="hljs-punctuation">&#123;</span> plugin dpdk_plugin.so <span class="hljs-punctuation">&#123;</span> disable <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>进入vpp1的shell界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vppctl -s /run/vpp/cli-vpp1.sock<br><span class="hljs-comment"># 创建接口</span><br>create host-interface name vpp1out<br>show hardware<br><span class="hljs-built_in">set</span> int state host-vpp1out up<br>show int<br><span class="hljs-comment"># 添加IP</span><br><span class="hljs-built_in">set</span> int ip address host-vpp1out 10.10.1.2/24<br>show int addr<br><br></code></pre></td></tr></table></figure><p>到此就完成了上述的创建链接的实验。</p><h2 id="trace-实验"><a href="#trace-实验" class="headerlink" title="trace 实验"></a>trace 实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/traces.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/traces.html</a></p><p>本实验沿用创建链接实验的环境，基本的trace命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看跟踪的buffer[max COUNT]</span><br>show trace<br><span class="hljs-comment"># 清除跟踪的buffer并且释放内存</span><br>clear trace<br><span class="hljs-comment"># 添加跟踪</span><br>trace add af-packet-input 10<br><span class="hljs-comment"># 可以跟踪的内容查看上述的链接</span><br></code></pre></td></tr></table></figure><h3 id="host2vpp"><a href="#host2vpp" class="headerlink" title="host2vpp"></a>host2vpp</h3><p>在vpp1的shell内选择上述跟踪的内容，在host上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 1 10.10.1.2<br></code></pre></td></tr></table></figure><p>然后回到vpp1的shell内查看跟踪情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show trace<br>clear trace<br></code></pre></td></tr></table></figure><h3 id="vpp2host"><a href="#vpp2host" class="headerlink" title="vpp2host"></a>vpp2host</h3><p>在vpp1的shell内执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping 10.10.1.1<br>show trace<br></code></pre></td></tr></table></figure><h3 id="ARP-Table"><a href="#ARP-Table" class="headerlink" title="ARP Table"></a>ARP Table</h3><p>在vpp1的shell内：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">show</span> ip <span class="hljs-built_in">neighbors</span><br></code></pre></td></tr></table></figure><h3 id="Routing-Table"><a href="#Routing-Table" class="headerlink" title="Routing Table"></a>Routing Table</h3><p>在vpp1的shell内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">show ip fib<br></code></pre></td></tr></table></figure><h2 id="连接两个VPP实例实验"><a href="#连接两个VPP实例实验" class="headerlink" title="连接两个VPP实例实验"></a>连接两个VPP实例实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/twovppinstances.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/twovppinstances.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/03/22/20220322201119.png" alt="Connect two FD.io VPP topology"></p><h3 id="vpp2-sock-创建"><a href="#vpp2-sock-创建" class="headerlink" title="vpp2.sock 创建"></a>vpp2.sock 创建</h3><p>本实验同样沿用vpp1的配置，我们类比创建vpp2链接，配置文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">unix &#123;cli-listen /run/vpp/cli-vpp2.sock&#125;<br>api-segment &#123; prefix vpp2 &#125;<br>plugins &#123; plugin dpdk_plugin.so &#123; <span class="hljs-built_in">disable</span> &#125; &#125;<br></code></pre></td></tr></table></figure><p>在host上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vpp -c vpp2.conf<br></code></pre></td></tr></table></figure><p>进入vpp2的shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#host执行</span><br>sudo vppctl -s /run/vpp/cli-vpp2.sock<br><span class="hljs-comment">#vpp shell执行</span><br>show version<br>quit<br></code></pre></td></tr></table></figure><h3 id="memif接口创建"><a href="#memif接口创建" class="headerlink" title="memif接口创建"></a>memif接口创建</h3><p>在vpp1端创建memif接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host执行</span><br>sudo vppctl -s /run/vpp/cli-vpp1.sock<br><span class="hljs-comment"># vpp shell执行</span><br>create interface memif <span class="hljs-built_in">id</span> 0 master<br><span class="hljs-built_in">set</span> int state memif0/0 up<br><span class="hljs-built_in">set</span> int ip address memif0/0 10.10.2.1/24<br></code></pre></td></tr></table></figure><p>在vpp2端创建memif端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host执行</span><br>sudo vppctl -s /run/vpp/cli-vpp2.sock<br><span class="hljs-comment"># vpp shell执行</span><br>create interface memif <span class="hljs-built_in">id</span> 0 slave<br><span class="hljs-built_in">set</span> int state memif0/0 up<br><span class="hljs-built_in">set</span> int ip address memif0/0 10.10.2.2/24<br><br></code></pre></td></tr></table></figure><p>在vpp1端ping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vpp1 shell执行</span><br>ping 10.10.2.2<br></code></pre></td></tr></table></figure><p>在vpp2端ping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vpp2 shell执行</span><br>ping 10.10.2.1<br></code></pre></td></tr></table></figure><h2 id="路由实验"><a href="#路由实验" class="headerlink" title="路由实验"></a>路由实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/routing.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/routing.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/03/22/20220322201125.png" alt="Connect two FD.io VPP topology"></p><p>实验沿用之前的环境，设置host上的路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip route add 10.10.2.0/24 via 10.10.1.2<br>ip route<br></code></pre></td></tr></table></figure><p>在vpp2上设置返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip route add 10.10.1.0/24  via 10.10.2.1<br></code></pre></td></tr></table></figure><p>在host上ping vpp2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping 10.10.2.2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project 1 Buffer Pool Manager</title>
    <link href="/2022/02/25/Project-1-Buffer-Pool-Manager/"/>
    <url>/2022/02/25/Project-1-Buffer-Pool-Manager/</url>
    
    <content type="html"><![CDATA[<h3 id="Lab-2-Summary"><a href="#Lab-2-Summary" class="headerlink" title="Lab 2 Summary"></a>Lab 2 Summary</h3><p> cmu15445第二个项目是关于在内存中实现buffer pool的，通过实现三个部分来加深对缓冲池的实现机制的理解，分别是LRU算法实现frame管理，单个buffer pool的管理，并行多个buffer pool的管理。</p><p> 实验地址：<a href="https://15445.courses.cs.cmu.edu/fall2021/project1/#buffer-pool-instance">https://15445.courses.cs.cmu.edu/fall2021/project1/#buffer-pool-instance</a></p><p> 首先谈一谈对整个page在磁盘和内存中的进出过程，理解到这些各部分过后，后续的实验就很好理解了；</p><p> 1、首先就是说DBMS不是直接去disk里拿到存储页儿，这个点儿但凡开始看这个课应该都可以理解；</p><p> 2、当执行某条SQL语句的时候，执行引擎先是去内存中的buffer pool里获取该页儿，这个时候会发生两种情况：</p><ul><li>当buffer pool内存在该页儿的时候，首先我们知道对页儿操作有两种，读和写，<code>但是写仍然是对于内存中buffer内的frame的修改，因此当多个线程操作的时候，有可能该缓存内的页儿没有写到disk内，因此这个时候该该页儿可能是dirty page</code>，所以这个时候就检测，如果该页儿时脏页儿，就先写回disk，然后再进行该页儿的操作，具体的操作由上层决定，返回指向该page的指针；</li><li>当buffer pool内不存在该页儿的时候，这个时候，buffer pool manager会从disk manager内从disk读取需要的page，然后缓存到buffer pool内，缓存进来过后，返回指向该page的指针给执行引擎；</li></ul><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170529.png" alt="DBMS Gets Page"></p><p> 3、如何管理好buffer pool内存中页儿的换进换出，通过策略性的控制，实现线程安全的线程控制：</p><ul><li>buffer pool：内存中的frame数组</li><li>page table：map[page_id] &#x3D; frame_id，page和frame的哈希表</li><li>replacer：控制页儿的置换与否</li><li>pin&#x2F;reference counter：正在使用该page的thread，pin_count为0的才会写回disk</li></ul><p> 当操作某个页儿的时候，不管是添加还是删除，还是从磁盘读取都要对该page进行pin操作，也就是说当前的页再被线程操作，不可以置换，而且这样的操作是原子的，因此得需要进行上锁。</p><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170604.png" alt="Buffer Pool Manager"></p><h3 id="LRU-Replacement-Policy"><a href="#LRU-Replacement-Policy" class="headerlink" title="LRU Replacement Policy"></a>LRU Replacement Policy</h3><h4 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h4><p> LRU置换算法，把使用频率最低的置换出去，体现在数据结构上就是队列的队尾给去掉，使用某个页儿时加入到队列的对头，当然再加入的时候得检测队列的大小是否超过容量；<code>LRUReplacer管理的是frame_id也就是确定buffer pool内的page是否可以被置换</code>，当我们把某些页儿给LRUReplacer时，通过lru策略管理他什么时候置换出去，而lru通过自身的算法优势来确定要victim哪些页儿；</p><ul><li>Victim：从buffer pool中置换出某个frame，victim要与buffer pool manager配合使用来置换页儿；</li><li>Pin：page有一个pin_count的数据结构来表示是否被线程使用，因此当某个page被pin的时候，表示正在被线程使用不可以被置换，因此对应到LRU就是这个page对应的frame不应该在可以被置换的队列内；</li><li>Unpin：该页儿可以被置换出去，因此将该page对应的frame加入可被置换的队列内，如果本身在的话就不用管了；</li></ul><p> LRU这个部分总结起来就是，这个部分是一种策略性的东西，是buffer pool manager的一个步骤，自身无法操作page那些的。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><h5 id="TODO-1-data-structure"><a href="#TODO-1-data-structure" class="headerlink" title="TODO 1 data structure"></a>TODO 1 data structure</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br> <span class="hljs-comment">// TODO(student): implement me!</span><br> std::mutex lru_latch_;<br> <span class="hljs-type">size_t</span> num_pages_;<br> std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; lru_list_;<br> std::unordered_map&lt;<span class="hljs-type">frame_id_t</span>, std::list&lt;<span class="hljs-type">frame_id_t</span>&gt;::iterator&gt; lru_map_&#123;&#125;;<br></code></pre></td></tr></table></figure><h5 id="TODO-2-constructor-and-destructor"><a href="#TODO-2-constructor-and-destructor" class="headerlink" title="TODO 2 constructor and destructor"></a>TODO 2 constructor and destructor</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">LRUReplacer::<span class="hljs-built_in">LRUReplacer</span>(<span class="hljs-type">size_t</span> num_pages) &#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  num_pages_ = num_pages;<br>&#125;<br><br>LRUReplacer::~<span class="hljs-built_in">LRUReplacer</span>() &#123;<br><span class="hljs-comment">// std::lock_guard&lt;std::mutex&gt; lock_guard(lru_latch_);</span><br>    <span class="hljs-comment">// 我人傻了，搞了2天，好蠢~~~</span><br>  lru_list_.<span class="hljs-built_in">clear</span>();<br>  lru_map_.<span class="hljs-built_in">clear</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="TODO-3-Victim"><a href="#TODO-3-Victim" class="headerlink" title="TODO 3 Victim"></a>TODO 3 Victim</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LRUReplacer::Victim</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> *frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (lru_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  *frame_id = lru_list_.<span class="hljs-built_in">back</span>();<br>  lru_map_.<span class="hljs-built_in">erase</span>(*frame_id);<br>  lru_list_.<span class="hljs-built_in">pop_back</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-4-Pin"><a href="#TODO-4-Pin" class="headerlink" title="TODO 4 Pin"></a>TODO 4 Pin</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LRUReplacer::Pin</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  <span class="hljs-keyword">auto</span> item = lru_map_.<span class="hljs-built_in">find</span>(frame_id);<br>  <span class="hljs-keyword">if</span> (item == lru_map_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  lru_list_.<span class="hljs-built_in">erase</span>(item-&gt;second);<br>  lru_map_.<span class="hljs-built_in">erase</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-5-Unpin"><a href="#TODO-5-Unpin" class="headerlink" title="TODO 5 Unpin"></a>TODO 5 Unpin</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LRUReplacer::Unpin</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (lru_list_.<span class="hljs-built_in">size</span>() &gt;= num_pages_) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (lru_map_.<span class="hljs-built_in">count</span>(frame_id) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  lru_list_.<span class="hljs-built_in">push_front</span>(frame_id);<br>  lru_map_[frame_id] = lru_list_.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make lru_replacer_test<br>./test/lru_replacer_test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170502.png" alt="LRU 本地测试"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --leak-check=full --suppressions=../build_support/valgrind.supp ./test/lru_replacer_test --gtest_filter=LRUReplacerTest.SimplePageTest<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170438.png" alt="LRU 内存检测"></p><h3 id="Buffer-Pool-Manager-Instance"><a href="#Buffer-Pool-Manager-Instance" class="headerlink" title="Buffer Pool Manager Instance"></a>Buffer Pool Manager Instance</h3><h4 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h4><p> Buffer Pool Manager主要实现几个功能，向disk写新的page，从disk里fetch page，刷新page等，这个部分千万千万反复看视频和PPT，当对page进行内容操作的时候会对该page进行pin，跟PPT上所说的一样。</p><h4 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h4><h5 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h5><h6 id="page-h"><a href="#page-h" class="headerlink" title="page.h"></a>page.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br> <span class="hljs-comment">/** Zeroes out the data that is held within the page. */</span><br> <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ResetMemory</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(data_, OFFSET_PAGE_START, PAGE_SIZE); &#125;<br><br> <span class="hljs-comment">/** The actual data that is stored within a page. */</span><br> <span class="hljs-type">char</span> data_[PAGE_SIZE]&#123;&#125;;<br> <span class="hljs-comment">/** The ID of this page. */</span><br> <span class="hljs-type">page_id_t</span> page_id_ = INVALID_PAGE_ID;<br> <span class="hljs-comment">/** The pin count of this page. */</span><br> <span class="hljs-type">int</span> pin_count_ = <span class="hljs-number">0</span>;<br> <span class="hljs-comment">/** True if the page is dirty, i.e. it is different from its corresponding page on disk. */</span><br> <span class="hljs-type">bool</span> is_dirty_ = <span class="hljs-literal">false</span>;<br> <span class="hljs-comment">/** Page latch. */</span><br> ReaderWriterLatch rwlatch_;<br></code></pre></td></tr></table></figure><h6 id="buffer-pool-manager-instance-h"><a href="#buffer-pool-manager-instance-h" class="headerlink" title="buffer_pool_manager_instance.h"></a>buffer_pool_manager_instance.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** Number of pages in the buffer pool. */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pool_size_;<br>  <span class="hljs-comment">/** How many instances are in the parallel BPM (if present, otherwise just 1 BPI) */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> num_instances_ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/** Index of this BPI in the parallel BPM (if present, otherwise just 0) */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> instance_index_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/** Each BPI maintains its own counter for page_ids to hand out, must ensure they mod back to its instance_index_ */</span><br>  std::atomic&lt;<span class="hljs-type">page_id_t</span>&gt; next_page_id_ = instance_index_;<br><br>  <span class="hljs-comment">/** Array of buffer pool pages. */</span><br>  Page *pages_;<br>  <span class="hljs-comment">/** Pointer to the disk manager. */</span><br>  DiskManager *disk_manager_ __attribute__((__unused__));<br>  <span class="hljs-comment">/** Pointer to the log manager. */</span><br>  LogManager *log_manager_ __attribute__((__unused__));<br>  <span class="hljs-comment">/** Page table for keeping track of buffer pool pages. */</span><br>  std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">frame_id_t</span>&gt; page_table_;<br>  <span class="hljs-comment">/** Replacer to find unpinned pages for replacement. */</span><br>  Replacer *replacer_;<br>  <span class="hljs-comment">/** List of free pages. */</span><br>  std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; free_list_;<br>  <span class="hljs-comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span><br>  std::mutex latch_;<br></code></pre></td></tr></table></figure><h6 id="disk-manager-h"><a href="#disk-manager-h" class="headerlink" title="disk_manager.h"></a>disk_manager.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Write a page to the database file.</span><br><span class="hljs-comment"> * @param page_id id of the page</span><br><span class="hljs-comment"> * @param page_data raw page data</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WritePage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *page_data)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Read a page from the database file.</span><br><span class="hljs-comment"> * @param page_id id of the page</span><br><span class="hljs-comment"> * @param[out] page_data output buffer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadPage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">char</span> *page_data)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="TODO-1-FlushPgImp"><a href="#TODO-1-FlushPgImp" class="headerlink" title="TODO 1 FlushPgImp"></a>TODO 1 FlushPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BufferPoolManagerInstance::FlushPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Make sure you call DiskManager::WritePage!</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (page_id == INVALID_PAGE_ID) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item == page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id = item-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-2-FlushAllPgsImp"><a href="#TODO-2-FlushAllPgsImp" class="headerlink" title="TODO 2 FlushAllPgsImp"></a>TODO 2 FlushAllPgsImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// You can do it!</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : page_table_) &#123;<br>    <span class="hljs-type">frame_id_t</span> frame_id = item.second;<br>    Page *page = &amp;pages_[frame_id];<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-3-NewPgImp"><a href="#TODO-3-NewPgImp" class="headerlink" title="TODO 3 NewPgImp"></a>TODO 3 NewPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call AllocatePage!</span><br>  <span class="hljs-comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span><br>  <span class="hljs-comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span><br>  <span class="hljs-comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span><br>  <span class="hljs-comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id;<br>  Page *page = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">if</span> (!free_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    frame_id = free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>    page = &amp;pages_[frame_id];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frame_id)) &#123;<br>    page = &amp;pages_[frame_id];<br>    <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    &#125;<br>    page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-type">page_id_t</span> new_page_id = <span class="hljs-built_in">AllocatePage</span>();<br>  page-&gt;page_id_ = new_page_id;<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>  page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br><br>  page_table_[page-&gt;<span class="hljs-built_in">GetPageId</span>()] = frame_id;<br>  *page_id = page-&gt;<span class="hljs-built_in">GetPageId</span>();<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br><br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-4-FetchPgImp"><a href="#TODO-4-FetchPgImp" class="headerlink" title="TODO 4 FetchPgImp"></a>TODO 4 FetchPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 1.     Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.1    If P exists, pin it and return it immediately.</span><br>  <span class="hljs-comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span><br>  <span class="hljs-comment">//        Note that pages are always found from the free list first.</span><br>  <span class="hljs-comment">// 2.     If R is dirty, write it back to the disk.</span><br>  <span class="hljs-comment">// 3.     Delete R from the page table and insert P.</span><br>  <span class="hljs-comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span><br><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-type">frame_id_t</span> frame_id;<br>  Page *page = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item != page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    frame_id = item-&gt;second;<br>    page = &amp;pages_[frame_id];<br>    page-&gt;pin_count_++;<br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>    <span class="hljs-keyword">return</span> page;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!free_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    frame_id = free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>    page = &amp;pages_[frame_id];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frame_id)) &#123;<br>    page = &amp;pages_[frame_id];<br>    <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    &#125;<br>    page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  page-&gt;page_id_ = page_id;<br>  page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  disk_manager_-&gt;<span class="hljs-built_in">ReadPage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>  page_table_[page-&gt;<span class="hljs-built_in">GetPageId</span>()] = frame_id;<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br><br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-5-DeletePgImp"><a href="#TODO-5-DeletePgImp" class="headerlink" title="TODO 5 DeletePgImp"></a>TODO 5 DeletePgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BufferPoolManagerInstance::DeletePgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call DeallocatePage!</span><br>  <span class="hljs-comment">// 1.   Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.   If P does not exist, return true.</span><br>  <span class="hljs-comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span><br>  <span class="hljs-comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span><br><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br><br>  <span class="hljs-built_in">DeallocatePage</span>(page_id);<br><br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item == page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id = item-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">GetPinCount</span>() != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>  &#125;<br><br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>  page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  page-&gt;pin_count_ = <span class="hljs-number">0</span>;<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br>  page-&gt;page_id_ = INVALID_PAGE_ID;<br>  free_list_.<span class="hljs-built_in">push_back</span>(frame_id);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-6-UnpinPgImp"><a href="#TODO-6-UnpinPgImp" class="headerlink" title="TODO 6 UnpinPgImp"></a>TODO 6 UnpinPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BufferPoolManagerInstance::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item == page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id = item-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">GetPinCount</span>() &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  page-&gt;pin_count_--;<br>  <span class="hljs-keyword">if</span> (is_dirty) &#123;<br>    page-&gt;is_dirty_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">GetPinCount</span>() &lt;= <span class="hljs-number">0</span>) &#123;<br>    replacer_-&gt;<span class="hljs-built_in">Unpin</span>(frame_id);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make buffer_pool_manager_instance_test<br>./test/buffer_pool_manager_instance_test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170639.png" alt="Buffer Pool Manager Instance 本地测试"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --leak-check=full --suppressions=../build_support/valgrind.supp ./test/buffer_pool_manager_instance_test --gtest_filter=BufferPoolManagerInstanceTest.BinaryDataTest:BufferPoolManagerInstanceTest.SampleTest<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170659.png" alt="Buffer Pool Manager Instance内存检测"></p><h3 id="Parallel-Buffer-Pool-Manager"><a href="#Parallel-Buffer-Pool-Manager" class="headerlink" title="Parallel Buffer Pool Manager"></a>Parallel Buffer Pool Manager</h3><h4 id="个人理解-2"><a href="#个人理解-2" class="headerlink" title="个人理解"></a>个人理解</h4><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228175932.png" alt="multiple buffer pools"></p><p> 并行buffer pool manager，这个部分其实是想让我们实现一个并行的数据库优化，也就是四个数据库优化中的第一个，multiple buffer pools，估计后边儿的实验老师会围绕这几个优化分别进行项目的制作，太牛b啊，这个部分的实现是采用了第二个Hash的方式来实现对每一个page的分配，也就是说当我们拿到一个page的时候，根据page_id来确定该page保存在那个buffer pool，注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">page_id_t</span> <span class="hljs-title">BufferPoolManagerInstance::AllocatePage</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">page_id_t</span> next_page_id = next_page_id_;<br>  next_page_id_ += num_instances_;<br>  <span class="hljs-built_in">ValidatePageId</span>(next_page_id);<br>  <span class="hljs-keyword">return</span> next_page_id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BufferPoolManagerInstance::ValidatePageId</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">page_id_t</span> page_id)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(page_id % num_instances_ == instance_index_);  <span class="hljs-comment">// allocated pages mod back to this BPI</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 通过观察上述的代码跟踪，可以分析得出，每次对page_id的分配就是对其进行hash取模来判断是存在哪个pool；然后为了达到并行，我们直接每个函数内操作该buffer pool instance内地数据就好了，其他的就是分配页儿的策略了，看如何达到比较好的性能，哈哈哈我不会，我就每次newpage的时候去每个instance挨个找，性能可能会极差。</p><h4 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h4><h5 id="TODO-1-Structure"><a href="#TODO-1-Structure" class="headerlink" title="TODO 1 Structure"></a>TODO 1 Structure</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br> std::mutex parallel_buffer_pool_latch_;<br> <span class="hljs-type">size_t</span> num_instance_;<br> <span class="hljs-type">size_t</span> pool_size_;<br> <span class="hljs-type">size_t</span> start_index_;<br> std::vector&lt;BufferPoolManagerInstance *&gt; buffer_pool_manager_;<br></code></pre></td></tr></table></figure><h5 id="TODO-2-Constructor"><a href="#TODO-2-Constructor" class="headerlink" title="TODO 2 Constructor"></a>TODO 2 Constructor</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">ParallelBufferPoolManager::<span class="hljs-built_in">ParallelBufferPoolManager</span>(<span class="hljs-type">size_t</span> num_instances, <span class="hljs-type">size_t</span> pool_size, DiskManager *disk_manager,<br>                                                     LogManager *log_manager) &#123;<br>  <span class="hljs-comment">// Allocate and create individual BufferPoolManagerInstances</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(parallel_buffer_pool_latch_)</span></span>;<br>  num_instance_ = num_instances;<br>  pool_size_ = pool_size;<br>  start_index_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instance_; ++i) &#123;<br>    buffer_pool_manager_.<span class="hljs-built_in">push_back</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferPoolManagerInstance</span>(pool_size_, num_instance_, i, disk_manager, log_manager));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-3-Destructor"><a href="#TODO-3-Destructor" class="headerlink" title="TODO 3 Destructor"></a>TODO 3 Destructor</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Update constructor to destruct all BufferPoolManagerInstances and deallocate any associated memory</span><br>ParallelBufferPoolManager::~<span class="hljs-built_in">ParallelBufferPoolManager</span>() &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instance_; ++i) &#123;<br>    <span class="hljs-keyword">delete</span> buffer_pool_manager_[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-4-GetPoolSize"><a href="#TODO-4-GetPoolSize" class="headerlink" title="TODO 4 GetPoolSize"></a>TODO 4 GetPoolSize</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ParallelBufferPoolManager::GetPoolSize</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Get size of all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">return</span> pool_size_ * num_instances_;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-5-GetBufferPoolManager"><a href="#TODO-5-GetBufferPoolManager" class="headerlink" title="TODO 5 GetBufferPoolManager"></a>TODO 5 GetBufferPoolManager</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BufferPoolManager *<span class="hljs-title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span><br>  <span class="hljs-keyword">return</span> buffer_pool_manager_[page_id % num_instance_];<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="TODO-6-FetchPgImp"><a href="#TODO-6-FetchPgImp" class="headerlink" title="TODO 6 FetchPgImp"></a>TODO 6 FetchPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">FetchPage</span>(page_id);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-7-UnpinPgImp"><a href="#TODO-7-UnpinPgImp" class="headerlink" title="TODO 7 UnpinPgImp"></a>TODO 7 UnpinPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-comment">// Unpin page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">UnpinPage</span>(page_id, is_dirty);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-8-FlushPgImp"><a href="#TODO-8-FlushPgImp" class="headerlink" title="TODO 8 FlushPgImp"></a>TODO 8 FlushPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::FlushPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Flush page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">FlushPage</span>(page_id);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-9-NewPgImp"><a href="#TODO-9-NewPgImp" class="headerlink" title="TODO 9 NewPgImp"></a>TODO 9 NewPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// create new page. We will request page allocation in a round robin manner from the underlying</span><br>  <span class="hljs-comment">// BufferPoolManagerInstances</span><br>  <span class="hljs-comment">// 1.   From a starting index of the BPMIs, call NewPageImpl until either 1) success and return 2) looped around to</span><br>  <span class="hljs-comment">// starting index and return nullptr</span><br>  <span class="hljs-comment">// 2.   Bump the starting index (mod number of instances) to start search at a different BPMI each time this function</span><br>  <span class="hljs-comment">// is called</span><br><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(parallel_buffer_pool_latch_)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = start_index_; i &lt; start_index_ + num_instance_; ++i) &#123;<br>    BufferPoolManager *manager = buffer_pool_manager_[i % num_instance_];<br>    Page *page = manager-&gt;<span class="hljs-built_in">NewPage</span>(page_id);<br>    <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>      start_index_ = (i + <span class="hljs-number">1</span>) % num_instance_;<br>      <span class="hljs-keyword">return</span> page;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-10-DeletePgImp"><a href="#TODO-10-DeletePgImp" class="headerlink" title="TODO 10 DeletePgImp"></a>TODO 10 DeletePgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::DeletePgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Delete page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">DeletePage</span>(page_id);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-11-FlushAllPgsImp"><a href="#TODO-11-FlushAllPgsImp" class="headerlink" title="TODO 11 FlushAllPgsImp"></a>TODO 11 FlushAllPgsImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// flush all pages from all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instance_; ++i) &#123;<br>    buffer_pool_manager_[i]-&gt;<span class="hljs-built_in">FlushAllPages</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Test-2"><a href="#Test-2" class="headerlink" title="Test"></a>Test</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make parallel_buffer_pool_manager_test<br>./test/parallel_buffer_pool_manager_test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170750.png" alt="Parallel Buffer Pool Manager 本地测试"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --leak-check=full --suppressions=../build_support/valgrind.supp ./test/parallel_buffer_pool_manager_test --gtest_filter=ParallelBufferPoolManagerTest.BinaryDataTest:ParallelBufferPoolManagerTest.Sample<br>Test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170817.png" alt="Parallel Buffer Pool Manager 内存测试"></p><h4 id="Gradescope"><a href="#Gradescope" class="headerlink" title="Gradescope"></a>Gradescope</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">make format<br>make check-lint<br>make check-clang-tidy<br><br>zip project1-submission.zip \<br>   src/include/buffer/lru_replacer.h \<br>   src/buffer/lru_replacer.cpp \<br>   src/include/buffer/buffer_pool_manager_instance.h \<br>   src/buffer/buffer_pool_manager_instance.cpp \<br>   src/include/buffer/parallel_buffer_pool_manager.h \<br>   src/buffer/parallel_buffer_pool_manager.cpp<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170844.png" alt="Gradescope"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 仿佛打开新世界的大门啊，嗯怎么说，总结几点需要注意的吧：</p><ul><li>LRU的析构函数（其他的也是）还是手动释放一下内存比较好，但是不要愚蠢</li><li>并行buffer pool的页分配，参照代码注释采用轮询的时候，可以考虑分配的更加均匀，反正我是上一次分配buffer pool的下一个来，挨着来找；可能一开始会比较均匀，但是最终由于读取那些page每个被访问的概率不一样，其实这也是假想的负载均衡，反正我象不太清楚，能大概的做一个global policy就好了，达到目的</li><li>然后就是反复看视频和PPT，加深理解</li></ul><p> 行，基本Over，继续学习，太菜了~</p>]]></content>
    
    
    <categories>
      
      <category>CMU15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sdn network orders</title>
    <link href="/2022/01/22/sdn-network-orders/"/>
    <url>/2022/01/22/sdn-network-orders/</url>
    
    <content type="html"><![CDATA[<h1 id="OVS"><a href="#OVS" class="headerlink" title="OVS"></a>OVS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">ovs-vsctl add-br br0<br>ovs-vsctl add-port veth0<br>ovs-vsctl del-port veth0<br>ovs-vsctl show<br><br>ovs-appctl fdb/show br0<br><br>ovs-ofctl dump-flows br0<br>ovs-ofctl add-flow br0 action=normal (普通交换机)<br>ovs-ofctl add-flow br0 input:veth0,action=output:veth1 (端口)<br></code></pre></td></tr></table></figure><h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-img create -f qcow2 imagename.qcow2 10G<br>qemu-system-x86_64 -m 2048 —enable-kvm <br>Linux 开kvm是 —enable-kvm ，mac是 accel=hvf<br></code></pre></td></tr></table></figure><h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns <span class="hljs-built_in">ls</span><br>ip netns add user1-namespace<br>ip netns <span class="hljs-built_in">exec</span> ns-name bash-command<br></code></pre></td></tr></table></figure><h1 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip <span class="hljs-built_in">link</span> <br>ip <span class="hljs-built_in">link</span> add<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev devicename master brname<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev devicename up<br>ip address add 10.0.14.3/24 dev devicename<br>ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br></code></pre></td></tr></table></figure><h1 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">brctl show<br>brctl addbr brname<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qemu frequent usings</title>
    <link href="/2022/01/22/qemu-frequent-usings/"/>
    <url>/2022/01/22/qemu-frequent-usings/</url>
    
    <content type="html"><![CDATA[<h3 id="qemu-system-x86-64"><a href="#qemu-system-x86-64" class="headerlink" title="qemu-system-x86_64"></a>qemu-system-x86_64</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qemu">qemu-system-x86_64 -m 1024 --enbale-kvm -net nic,macaddr=11:22:33:44:55;66 -hda linux.img -cdrom debian.iso<br></code></pre></td></tr></table></figure><h3 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h3><p>​创建一个虚拟磁盘，raw&#x2F;qcow2两种格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qemu">qemu-img create -f qcow2 disk.img 1G<br></code></pre></td></tr></table></figure><h3 id="libguestfs-tools"><a href="#libguestfs-tools" class="headerlink" title="libguestfs-tools"></a>libguestfs-tools</h3><p>​调整盘的大小并拷贝进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qemu">qemu-img create -f qcow2 newdisk.img 1G<br>virt-resize —expand /dev/sda1 olddisk.img newdisk.img<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker bug collect</title>
    <link href="/2022/01/22/docker-bug-collect/"/>
    <url>/2022/01/22/docker-bug-collect/</url>
    
    <content type="html"><![CDATA[<ul><li>bug-1、You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: <a href="https://www.docker.com/increase-rate-limits">https://www.docker.com/increase-rate-limits</a></li></ul><p>​检查docker的源的问题，然后尝试更换源来解决；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\\-\\-registry\\-mirror&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;&lt;https://hub-mirror.c.163.com&gt;&quot;</span>,<br>    <span class="hljs-string">&quot;&lt;https://mirror.baidubce.com&gt;&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后重启一下docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li>bug-2 Error response from daemon: could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network</li></ul><p>​手动设置好当前的docker的网络，然后重新创建该节点就ok了</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker network create --subnet <span class="hljs-number">172.18</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> -d=bridge -o com.docker.network.bridge.enable_ip_masquerade=true -o com.docker.network.driver.mtu=<span class="hljs-number">1500</span> --ipv6 --subnet fc00:f853:ccd:e793::/<span class="hljs-number">64</span> kind<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPM build</title>
    <link href="/2022/01/22/rpm-build/"/>
    <url>/2022/01/22/rpm-build/</url>
    
    <content type="html"><![CDATA[<h1 id="1、rpmbuild-安装"><a href="#1、rpmbuild-安装" class="headerlink" title="1、rpmbuild 安装"></a>1、rpmbuild 安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install make<br>yum install gcc<br>yum install rpm-build<br>yum install rpmdevtools<br>rpmdev-setuptree<br><span class="hljs-comment"># 查看安装情况</span><br>rpmbuild --showrc | grep topdir<br></code></pre></td></tr></table></figure><h1 id="2、创建用户用于打包"><a href="#2、创建用户用于打包" class="headerlink" title="2、创建用户用于打包"></a>2、创建用户用于打包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建用户</span><br>useradd rpmuser <br>su - rpmuser <br><br><span class="hljs-comment">#定义工作目录(或车间)吧</span><br>vi ~/.rpmmacros <br>%_topdir   /home/rpmuser/rpmbuild    <span class="hljs-comment">##目录可以自定义 </span><br><br><span class="hljs-built_in">mkdir</span> ~/rpmbuild  <br><br><span class="hljs-comment">#在topdir下建立需要的目录</span><br><span class="hljs-built_in">cd</span> ~/rpmbuild  <br><span class="hljs-built_in">mkdir</span> -pv &#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125; <br></code></pre></td></tr></table></figure><h1 id="3、整理源码"><a href="#3、整理源码" class="headerlink" title="3、整理源码"></a>3、整理源码</h1><p>rpmbuild安装完成以后我门就需要将我们的源码放到 SOURCE 文件夹下。我门的源码可能是一个tar.gz 的包、也可能是几个文件。tar.gz源码包的名字格式应该为 helloword-1.0.0.tar.gz (其实就是名字-版本号.tar.gz)</p><h1 id="4、编写Spec"><a href="#4、编写Spec" class="headerlink" title="4、编写Spec"></a>4、编写Spec</h1><p>在SPECS文件夹下新建 xxx.spec 打包脚本，将源码编译打包成rpm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi  xxx.spec <br><br>Name:           hellorpm           <span class="hljs-comment">#名字为源码tar.gz 包的名字 </span><br>Version:        1.0.0             <span class="hljs-comment">#版本号，一定要与tar.gz包的一致哦 </span><br>Release:        1%&#123;?dist&#125;         <span class="hljs-comment">#释出号，也就是第几次制作rpm </span><br>Summary:       helloword   <span class="hljs-comment">#软件包简介，最好不要超过50字符 </span><br><br>License:        GPL                   <span class="hljs-comment">#许可，GPL还是BSD等  </span><br>URL:            <span class="hljs-comment">#可以写一个网址 </span><br>Packager:       abel <br>Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz   <br><span class="hljs-comment">#定义用到的source，也就是你的源码</span><br><br>BuildRoot:      %_topdir/BUILDROOT         <br><span class="hljs-comment">#这个是软件make install 的测试安装目录.</span><br><br>BuildRequires:  gcc,make                           <span class="hljs-comment">#制作过程中用到的软件包 </span><br>Requires:       python-apscheduler &gt;= 2.1.2-1.el7,python-daemon &gt;= 1.6-1.el7  <span class="hljs-comment">#软件运行依赖的软件包，也可以指定最低版本如 bash &gt;= 1.1.1 </span><br>%description                <span class="hljs-comment">#描述，随便写                 </span><br>%prep                          ＃打包开始                    <br>%setup -q                      <span class="hljs-comment">#这个作用静默模式解压并cd                               </span><br><br>%build              <span class="hljs-comment">#编译制作阶段，主要目的就是编译，如果不用编译就为空 </span><br>./configure \\                                     <br> %&#123;?_smp_mflags&#125;          <span class="hljs-comment">#make后面的意思是：如果就多处理器的话make时并行编译 </span><br><br>%install                        <span class="hljs-comment">#安装阶段                        </span><br><span class="hljs-built_in">rm</span> -rf %&#123;buildroot&#125;             <span class="hljs-comment">#先删除原来的安装的，如果你不是第一次安装的话 </span><br> <span class="hljs-built_in">cp</span> -rp %_topdir/BUILD/%&#123;name&#125;-%&#123;version&#125;/*  <span class="hljs-variable">$RPM_BUILD_ROOT</span> <br><span class="hljs-comment">#将需要需要打包的文件从BUILD 文件夹中拷贝到BUILDROOT文件夹下。</span><br><br><span class="hljs-comment">#下面的几步pre、post、preun、postun 没必要可以不写 </span><br>%pre        <span class="hljs-comment">#rpm安装前制行的脚本 </span><br><br>%post       <span class="hljs-comment">#安装后执行的脚本 </span><br><br>%preun      <span class="hljs-comment">#卸载前执行的脚本 </span><br><br>%postun     <span class="hljs-comment">#卸载后执行的脚本 </span><br><br>%clean <span class="hljs-comment">#清理段,删除buildroot </span><br><span class="hljs-built_in">rm</span> -rf %&#123;buildroot&#125; <br><br>%files  <span class="hljs-comment">#rpm要包含的文件 </span><br>%defattr (-,root,root,-)   <span class="hljs-comment">#设定默认权限，如果下面没有指定权限，则继承默认 </span><br>/etc/hello/word/helloword.c           <span class="hljs-comment">#将你需要打包的文件或目录写下来</span><br><br><span class="hljs-comment">###  7.chagelog section  改变日志段 </span><br>%changelog<br></code></pre></td></tr></table></figure><h1 id="5、打包"><a href="#5、打包" class="headerlink" title="5、打包"></a>5、打包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpmbuild  <br>-ba 既生成src.rpm又生成二进制rpm <br>-bs 只生成src的rpm <br>-bb 只生二进制的rpm <br>-bp 执行到pre <br>-bc 执行到 build段 <br>-bi 执行install段 <br>-bl 检测有文件没包含<br></code></pre></td></tr></table></figure><h1 id="6、bugfix"><a href="#6、bugfix" class="headerlink" title="6、bugfix"></a>6、bugfix</h1><ul><li>rpmbuild: Empty %files file debugsourcefiles.list</li></ul><p>解决方法：在gcc的时候添加-g选项生成debuginfo信息</p><p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1583329">https://bugzilla.redhat.com/show_bug.cgi?id=1583329</a></p><h1 id="7、demo测试"><a href="#7、demo测试" class="headerlink" title="7、demo测试"></a>7、demo测试</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>main.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test Main\\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Makefile</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>OBJS = main.c<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>            gcc -g -o main $&#123;OBJS&#125;<br><span class="hljs-section">install:</span><br>            install -m 755 main <span class="hljs-variable">$(RPM_INSTALL_ROOT)</span>/usr/local/bin/main<br></code></pre></td></tr></table></figure><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mkdir ~/rpmbuild<br>cd ~/rpmbuild<br>mkdir -p BUILD SPECS RPMS SOURCES SRPMS<br></code></pre></td></tr></table></figure><h2 id="创建main-0-1-spec"><a href="#创建main-0-1-spec" class="headerlink" title="创建main-0.1.spec"></a>创建main-0.1.spec</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs perl">Summary: test rpm<br>Name: main<br>Version: <span class="hljs-number">0</span>.<span class="hljs-number">1</span><br>Release: <span class="hljs-number">1</span><br>License: GPL<br>Group: NONE<br>Source: main-<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.tar.gz<br>Url: &lt;http:<span class="hljs-regexp">//</span>www.bencorn.com&gt;<br>Packager: Lin<br>BuildRoot: %&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root<br><br>%description<br>exercise: how to <span class="hljs-keyword">use</span>  rpm <span class="hljs-keyword">and</span> rpmbuild<br><br>%prep<br>%setup -<span class="hljs-keyword">q</span><br><br>%build<br>make<br><br>%install<br>rm -rf %&#123;buildroot&#125;<br><span class="hljs-keyword">mkdir</span> -p %&#123;buildroot&#125;/usr/<span class="hljs-keyword">local</span>/bin<br>make install RPM_INSTALL_ROOT=%&#123;buildroot&#125;<br><br>%files<br>/usr/<span class="hljs-keyword">local</span>/bin/main<br><br>%changelog<br>* Sun Aug  <span class="hljs-number">1</span> <span class="hljs-number">23</span>:<span class="hljs-number">13</span>:<span class="hljs-number">44</span> EDT <span class="hljs-number">2021</span> bencorn &lt;<span class="hljs-number">1143005768</span>@qq.com&gt; <span class="hljs-number">0</span>.<span class="hljs-number">1</span><br>- build the program<br></code></pre></td></tr></table></figure><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpmbuild -ba main-0.1.spec<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://imgs.bencorn.com/imgs/2022/01/22/20220122214200.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubebuilder</title>
    <link href="/2022/01/22/Kubebuilder/"/>
    <url>/2022/01/22/Kubebuilder/</url>
    
    <content type="html"><![CDATA[<h2 id="kubebuilder-install"><a href="#kubebuilder-install" class="headerlink" title="kubebuilder install"></a>kubebuilder install</h2><h3 id="go安装"><a href="#go安装" class="headerlink" title="go安装"></a>go安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/golang.org/</span>&gt;)<br></code></pre></td></tr></table></figure><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/engine/i</span>nstall<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/docs.docker.com/</span>engine<span class="hljs-regexp">/install/</span>&gt;)<br><br>bug fix参见docker：[&lt;https:<span class="hljs-regexp">//</span>www.notion.so<span class="hljs-regexp">/docker-70e41d6ca1bd4b2b966c9d247ce628a4&gt;](&lt;https:/</span><span class="hljs-regexp">/www.notion.so/</span>docker-<span class="hljs-number">70</span>e41d6ca1bd4b2b966c9d247ce628a4&gt;)<br></code></pre></td></tr></table></figure><h3 id="SIG-CLI-安装"><a href="#SIG-CLI-安装" class="headerlink" title="SIG CLI 安装"></a>SIG CLI 安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>kubernetes.io<span class="hljs-regexp">/docs/</span>tasks<span class="hljs-regexp">/tools/i</span>nstall-kubectl-linux<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/kubectl.docs.kubernetes.io/i</span>nstallation/&gt;)<br></code></pre></td></tr></table></figure><p>​kind 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -Lo ./kind &lt;https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64&gt;<br><span class="hljs-built_in">chmod</span> +x ./kind<br><span class="hljs-built_in">mv</span> ./kind /some-dir-in-your-PATH/kind<br></code></pre></td></tr></table></figure><p>​kustome 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GOBIN=$(<span class="hljs-built_in">pwd</span>)/ GO111MODULE=on go get sigs.k8s.io/kustomize/kustomize/v3<br></code></pre></td></tr></table></figure><h3 id="kubebuilder安装"><a href="#kubebuilder安装" class="headerlink" title="kubebuilder安装"></a>kubebuilder安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">os=$(go <span class="hljs-built_in">env</span> GOOS)<br><span class="hljs-built_in">arch</span>=$(go <span class="hljs-built_in">env</span> GOARCH)<br><br><span class="hljs-comment"># 下载 kubebuilder 并解压到 tmp 目录中</span><br>curl -L &lt;https://go.kubebuilder.io/dl/2.3.1/<span class="hljs-variable">$&#123;os&#125;</span>/<span class="hljs-variable">$&#123;arch&#125;</span>&gt; | tar -xz -C /tmp/<br><br><span class="hljs-comment"># 将 kubebuilder 移动到一个长期的路径，并将其加入环境变量 path 中</span><br><span class="hljs-comment"># （如果你把 kubebuilder 放在别的地方，你需要额外设置 KUBEBUILDER_ASSETS 环境变量）</span><br><br>sudo <span class="hljs-built_in">mv</span> /tmp/kubebuilder_2.3.1_<span class="hljs-variable">$&#123;os&#125;</span>_<span class="hljs-variable">$&#123;arch&#125;</span> /usr/local/kubebuilder<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/kubebuilder/bin<br><span class="hljs-comment"># 或者添加到/etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="First-Program"><a href="#First-Program" class="headerlink" title="First Program"></a>First Program</h2><p><a href="https://cloudnative.to/kubebuilder/quick-start.html">https://cloudnative.to/kubebuilder/quick-start.html</a></p><h2 id="development-a-demo"><a href="#development-a-demo" class="headerlink" title="development a demo"></a>development a demo</h2><h3 id="go安装-1"><a href="#go安装-1" class="headerlink" title="go安装"></a>go安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/golang.org/</span>&gt;)<br></code></pre></td></tr></table></figure><h3 id="docker安装-1"><a href="#docker安装-1" class="headerlink" title="docker安装"></a>docker安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/engine/i</span>nstall<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/docs.docker.com/</span>engine<span class="hljs-regexp">/install/</span>&gt;)<br><br>bug fix参见docker：[&lt;https:<span class="hljs-regexp">//</span>www.notion.so<span class="hljs-regexp">/docker-70e41d6ca1bd4b2b966c9d247ce628a4&gt;](&lt;https:/</span><span class="hljs-regexp">/www.notion.so/</span>docker-<span class="hljs-number">70</span>e41d6ca1bd4b2b966c9d247ce628a4&gt;)<br></code></pre></td></tr></table></figure><h3 id="SIG-CLI-安装-1"><a href="#SIG-CLI-安装-1" class="headerlink" title="SIG CLI 安装"></a>SIG CLI 安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>kubernetes.io<span class="hljs-regexp">/docs/</span>tasks<span class="hljs-regexp">/tools/i</span>nstall-kubectl-linux<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/kubectl.docs.kubernetes.io/i</span>nstallation/&gt;)<br></code></pre></td></tr></table></figure><p>​kind 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -Lo ./kind &lt;https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64&gt;<br><span class="hljs-built_in">chmod</span> +x ./kind<br><span class="hljs-built_in">mv</span> ./kind /some-dir-in-your-PATH/kind<br></code></pre></td></tr></table></figure><p>​kustome 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GOBIN=$(<span class="hljs-built_in">pwd</span>)/ GO111MODULE=on go get sigs.k8s.io/kustomize/kustomize/v3<br></code></pre></td></tr></table></figure><h3 id="kubebuilder安装-1"><a href="#kubebuilder安装-1" class="headerlink" title="kubebuilder安装"></a>kubebuilder安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">os=$(go <span class="hljs-built_in">env</span> GOOS)<br><span class="hljs-built_in">arch</span>=$(go <span class="hljs-built_in">env</span> GOARCH)<br><br><span class="hljs-comment"># 下载 kubebuilder 并解压到 tmp 目录中</span><br>curl -L &lt;https://go.kubebuilder.io/dl/2.3.1/<span class="hljs-variable">$&#123;os&#125;</span>/<span class="hljs-variable">$&#123;arch&#125;</span>&gt; | tar -xz -C /tmp/<br><br><span class="hljs-comment"># 将 kubebuilder 移动到一个长期的路径，并将其加入环境变量 path 中</span><br><span class="hljs-comment"># （如果你把 kubebuilder 放在别的地方，你需要额外设置 KUBEBUILDER_ASSETS 环境变量）</span><br><br>sudo <span class="hljs-built_in">mv</span> /tmp/kubebuilder_2.3.1_<span class="hljs-variable">$&#123;os&#125;</span>_<span class="hljs-variable">$&#123;arch&#125;</span> /usr/local/kubebuilder<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/kubebuilder/bin<br><span class="hljs-comment"># 或者添加到/etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="Demo-实现"><a href="#Demo-实现" class="headerlink" title="Demo 实现"></a>Demo 实现</h2><h3 id="kind-搭建多节点集群"><a href="#kind-搭建多节点集群" class="headerlink" title="kind 搭建多节点集群"></a>kind 搭建多节点集群</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># cluster with 1 control-plane nodes and 3 workers</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-string">kind</span> <span class="hljs-string">create</span> <span class="hljs-string">cluster</span> <span class="hljs-string">--config</span> <span class="hljs-string">kind-1-3.yaml</span><br></code></pre></td></tr></table></figure><p>​创建好一个单控制节点，多计算节点集群</p><h3 id="创建kubebuilder项目"><a href="#创建kubebuilder项目" class="headerlink" title="创建kubebuilder项目"></a>创建kubebuilder项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubebuilder init --domain demo.org<br>kubebuilder create api --group system --version v1 --kind Sysctl<br></code></pre></td></tr></table></figure><p>​修改基本的逻辑，我们希望调用api的时候，检测spec数据结构的值，根据值做出相应的系统调用实现，现在做sysctl的系统调用，并且我们把它给打印到日志里边儿。</p><ul><li>数据结构</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SysctlCall 检查值进行系统调用</span><br>SysctlCall <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sysctl_call,omitempty&quot;`</span><br></code></pre></td></tr></table></figure><ul><li>Reconcile</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *SysctlReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>l := log.FromContext(ctx)<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;demo start&quot;</span>)<br><span class="hljs-keyword">var</span> sysctlCall systemv1.Sysctl<br><span class="hljs-keyword">if</span> err := r.Get(ctx, req.NamespacedName, &amp;sysctlCall); err != <span class="hljs-literal">nil</span> &#123;<br>l.Error(err, <span class="hljs-string">&quot;unable to fetch sysctlCall&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)<br>&#125;<br><br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;r.Get returns value&quot;</span>, <span class="hljs-string">&quot;sysctlCall&quot;</span>, sysctlCall)<br><span class="hljs-keyword">if</span> strings.EqualFold(sysctlCall.Spec.SysctlCall, <span class="hljs-string">&quot;Y&quot;</span>) &#123;<br><span class="hljs-keyword">var</span> whoami []<span class="hljs-type">byte</span><br><span class="hljs-keyword">var</span> cmd *exec.Cmd<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br>cmd = exec.Command(<span class="hljs-string">&quot;whoami&quot;</span>)<br><span class="hljs-keyword">if</span> whoami, err = cmd.Output(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;sysctl called&quot;</span>, <span class="hljs-string">&quot;bash/whoami&quot;</span>, <span class="hljs-type">string</span>(whoami))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;sysctl not called&quot;</span>)<br>&#125;<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;demo end&quot;</span>)<br><span class="hljs-comment">// your logic here</span><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>system_v1_sysctl.yaml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">system.demo.org/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Sysctl</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">sysctl-sample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># Add fields here</span><br>  <span class="hljs-attr">sysctl_call:</span> <span class="hljs-string">Y</span><br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><ul><li>窗口一</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make install <br>make run<br></code></pre></td></tr></table></figure><ul><li>窗口二</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f config/samples/system_v1_sysctl.yaml<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="https://imgs.bencorn.com/imgs/2022/01/22/20220122213329.png" alt="实现结果"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具记录</title>
    <link href="/2022/01/22/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/01/22/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Google学术"><a href="#Google学术" class="headerlink" title="Google学术"></a>Google学术</h1><p> 第一步、获取管理员权限，如windows：</p><ul><li>win+R，输入gpedit.msc</li><li>计算机配置</li><li>windows设置</li><li>安全设置</li><li>本地策略</li><li>安全选项设置为禁用,重启生效<br><img src="https://imgs.bencorn.com/imgs/2022/01/22/20220122132810.png" alt="安全项设置"></li></ul><p>第二步、修改host文件，如windows：</p><ul><li>获取完管理员权限过后</li><li>C:\Windows\System32\drivers\etc</li><li>修改host文件，添加以下内容：</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># google 学术<br><span class="hljs-number">172.245.241.129</span> scholar.google.com<br><span class="hljs-number">172.245.241.129</span> scholar.google.com.hk<br><span class="hljs-number">172.245.241.129</span> scholar.google.com.tw<br><span class="hljs-number">172.245.241.129</span> scholar.google.com.sg<br><span class="hljs-number">172.245.241.129</span> scholar.googleusercontent.com<br><br></code></pre></td></tr></table></figure><p>好了大功告成，这下就可以愉快看论文了。</p><h1 id="Codeforces"><a href="#Codeforces" class="headerlink" title="Codeforces"></a>Codeforces</h1><p>codeforces.com是由于google字体加载慢，然后也是修改一下host就可以很快了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">#codeforce<br>font.<span class="hljs-keyword">im</span> fonts.googleapis.<span class="hljs-keyword">com</span><br>font.<span class="hljs-keyword">im</span> fonts.gstatic.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project 0 C++ Primer</title>
    <link href="/2021/11/13/Project-0-C-Primer/"/>
    <url>/2021/11/13/Project-0-C-Primer/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab-1-Summary"><a href="#Lab-1-Summary" class="headerlink" title="Lab 1 Summary"></a>Lab 1 Summary</h2><p> cmu15445第一个项目是学习C++，包括C++的面向对象、C++11&#x2F;14&#x2F;17特性，如智能指针等。同时也是对计算机基础知识的一个基本检验。</p><p> 实验地址（以后可能用不了）：<a href="https://15445.courses.cs.cmu.edu/fall2021/project0/">https://15445.courses.cs.cmu.edu/fall2021/project0/</a></p><p> 首先说一下这个部分用到的基本原理：</p><ul><li>1、CPU cache会将一维数组进行缓存，因此对RowMatrix中二维数组内存的开辟和使用Matrix中的linear一维数组，这样可以更好的使用CPU cache这一机制，提升代码速度；</li><li>2、C++多态，以及智能指针unique_ptr独占指针实现安全；</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p> 接下来是每个部分的实现，可能会有错误的地方，C++语言特性目前还不是特别的熟悉，菜~</p><h3 id="TODO-1-Construct-a-new-Matrix-instance"><a href="#TODO-1-Construct-a-new-Matrix-instance" class="headerlink" title="TODO 1 Construct a new Matrix instance"></a>TODO 1 Construct a new Matrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols) &#123;<br>    rows_ = rows;<br>    cols_ = cols;<br>    <span class="hljs-type">int</span> len = rows * cols;<br>    linear_ = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-built_in">memset</span>(linear_, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(T) * len);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-2-Destroy-a-matrix-instance"><a href="#TODO-2-Destroy-a-matrix-instance" class="headerlink" title="TODO 2 Destroy a matrix instance"></a>TODO 2 Destroy a matrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Matrix</span>() &#123; <span class="hljs-keyword">delete</span>[] linear_; &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-3-Construct-a-new-RowMatrix-instance"><a href="#TODO-3-Construct-a-new-RowMatrix-instance" class="headerlink" title="TODO 3 Construct a new RowMatrix instance"></a>TODO 3 Construct a new RowMatrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RowMatrix</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols) : <span class="hljs-built_in">Matrix</span>&lt;T&gt;(rows, cols) &#123;<br>    data_ = <span class="hljs-keyword">new</span> T *[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>      data_[i] = <span class="hljs-keyword">this</span>-&gt;linear_ + i * cols;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-4-Implementation-getter-and-setter"><a href="#TODO-4-Implementation-getter-and-setter" class="headerlink" title="TODO 4 Implementation getter and setter"></a>TODO 4 Implementation getter and setter</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRowCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;rows_; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetColumnCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;cols_; &#125;<br><br><span class="hljs-function">T <span class="hljs-title">GetElement</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-keyword">this</span>-&gt;rows_ || j &lt; <span class="hljs-number">0</span> || j &gt;= <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;Void Get Element: index is out of range.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> data_[i][j];<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetElement</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, T val)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-keyword">this</span>-&gt;rows_ || j &lt; <span class="hljs-number">0</span> || j &gt;= <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;Void Set Element: index out of range&quot;</span>);<br>    &#125;<br>    data_[i][j] = val;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-5-Fill-from-source-container"><a href="#TODO-5-Fill-from-source-container" class="headerlink" title="TODO 5 Fill from source container"></a>TODO 5 Fill from source container</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FillFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt; &amp;source)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = source.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-keyword">this</span>-&gt;rows_ * <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;source does not contain the required number of elements&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">this</span>-&gt;linear_[i] = source[i];<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-6-Destroy-a-RowMatrix-instance"><a href="#TODO-6-Destroy-a-RowMatrix-instance" class="headerlink" title="TODO 6 Destroy a RowMatrix instance"></a>TODO 6 Destroy a RowMatrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">~<span class="hljs-built_in">RowMatrix</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">delete</span>[] data_; &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-7-RowMatrix-ADD"><a href="#TODO-7-RowMatrix-ADD" class="headerlink" title="TODO 7 RowMatrix ADD"></a>TODO 7 RowMatrix ADD</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">Add</span>(<span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;<br>    <span class="hljs-comment">// TODO(P0): Add implementation</span><br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>() || matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> rows = matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>();<br>    <span class="hljs-type">int</span> cols = matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; ret = std::make_unique&lt;RowMatrix&lt;T&gt;&gt;(rows, cols);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>        ret-&gt;<span class="hljs-built_in">SetElement</span>(i, j, matrixA-&gt;<span class="hljs-built_in">GetElement</span>(i, j) + matrixB-&gt;<span class="hljs-built_in">GetElement</span>(i, j));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-8-RowMatrix-Multiply"><a href="#TODO-8-RowMatrix-Multiply" class="headerlink" title="TODO 8 RowMatrix Multiply"></a>TODO 8 RowMatrix Multiply</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">Multiply</span>(<span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;<br>    <span class="hljs-comment">// TODO(P0): Add implementation</span><br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> rows = matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>();<br>    <span class="hljs-type">int</span> lines = matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    <span class="hljs-type">int</span> cols = matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br><br>    std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; ret = std::make_unique&lt;RowMatrix&lt;T&gt;&gt;(rows, cols);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; lines; ++k) &#123;<br>          ret-&gt;<span class="hljs-built_in">SetElement</span>(i, j, ret-&gt;<span class="hljs-built_in">GetElement</span>(i, j) + matrixA-&gt;<span class="hljs-built_in">GetElement</span>(i, k) * matrixB-&gt;<span class="hljs-built_in">GetElement</span>(k, j));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-9-RowMatrix-GEMM"><a href="#TODO-9-RowMatrix-GEMM" class="headerlink" title="TODO 9 RowMatrix GEMM"></a>TODO 9 RowMatrix GEMM</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">GEMM</span>(<span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixB,<br>                                            <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixC) &#123;<br>    <span class="hljs-comment">// TODO(P0): Add implementation</span><br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>() != matrixC-&gt;<span class="hljs-built_in">GetRowCount</span>() || matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixC-&gt;<span class="hljs-built_in">GetColumnCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">Multiply</span>(matrixA, matrixB);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(ret.<span class="hljs-built_in">get</span>(), matrixC);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd build<br>make start_test<br>./test/start_test<br><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2021/11/13/20211113143446.png" alt="测试结果1"></p><p><img src="https://imgs.bencorn.com/imgs/2021/11/13/20211113143508.png" alt="测试结果2"></p><h2 id="Gradescope"><a href="#Gradescope" class="headerlink" title="Gradescope"></a>Gradescope</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">make format<br>make check-lint<br>make check-clang-tidy<br>cd ..<br>zip -q -r project0-submission.zip src/include/primer/p0_starter.h<br><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2021/11/13/20211113174633.png" alt="grade测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>CMU15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2 Memory Management</title>
    <link href="/2021/08/13/Lab2-Memory-Management/"/>
    <url>/2021/08/13/Lab2-Memory-Management/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实验地址：<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/">https://pdos.csail.mit.edu/6.828/2018/labs/lab2/</a></p><p>lab2我们将建立操作系统对内存的管理，其中内存管理分为了两个部分：物理内存管理和虚拟内存管理</p><h1 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h1><p>JOS 通过一个链表来管理物理内存，写一个极其简易的物理页分配器，这个部分的最大的难度在于对 JOS 内存布局的理解。</p><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>在文件 <code>kern/pmap.c</code> 中，实现下面的所有函数。</p><h3 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc()"></a>boot_alloc()</h3><p>根据函数的解释说明，我们得知，boot_alloc() 是 JOS 操作系统在设置虚拟内存系统的时候使用的物理内存分配器。</p><p>从代码中我们可以看到，在设置虚拟内存系统的时候，维护了一个全局的 nextfree 指针，该指针指着下一个空闲的地址，而且这个指针只的刚好是 extend memory 里边儿的 kernel.ld 中指定的内核 bss 的结束地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span><br>   <span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><br>   <span class="hljs-comment">// to a multiple of PGSIZE.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// LAB 2: Your code here.</span><br><br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>       <span class="hljs-keyword">return</span> nextfree;<br>   &#125;<br><br>   result = nextfree;<br>   nextfree = ROUNDUP(nextfree + n, PGSIZE);<br><br>   <span class="hljs-keyword">if</span>((<span class="hljs-type">uint32_t</span>)nextfree - KERNBASE &gt; (npages * PGSIZE))&#123;<br>       panic(<span class="hljs-string">&quot;Out of memory!\n&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>因此我们参照具体的内容，当调用值 n 的时候，按照页的大小，进行分配并且返回该内存页的起始地址。</p><h3 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init()"></a>mem_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span><br><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><br><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><br><span class="hljs-comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span><br><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><br><span class="hljs-comment">// Your code goes here:</span><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*)boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages);<br><span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(pages));<br></code></pre></td></tr></table></figure><p> 创建一个数组，这个数组也就是所有的物理页了，然后初始化所有的 pages 为 0。</p><h3 id="page-init"><a href="#page-init" class="headerlink" title="page_init()"></a>page_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// The example code here marks all physical pages as free.</span><br>    <span class="hljs-comment">// However this is not truly the case.  What memory is free?</span><br>    <span class="hljs-comment">//  1) Mark physical page 0 as in use.</span><br>    <span class="hljs-comment">//     This way we preserve the real-mode IDT and BIOS structures</span><br>    <span class="hljs-comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span><br>    <span class="hljs-comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br>    <span class="hljs-comment">//     is free.</span><br>    <span class="hljs-comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br>    <span class="hljs-comment">//     never be allocated.</span><br>    <span class="hljs-comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span><br>    <span class="hljs-comment">//     Some of it is in use, some is free. Where is the kernel</span><br>    <span class="hljs-comment">//     in physical memory?  Which pages are already in use for</span><br>    <span class="hljs-comment">//     page tables and other data structures?</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Change the code to reflect this.</span><br>    <span class="hljs-comment">// NB: DO NOT actually touch the physical memory corresponding to</span><br>    <span class="hljs-comment">// free pages!</span><br>    <span class="hljs-type">size_t</span> i;<br>    page_free_list = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//page 0 in use</span><br>    pages[<span class="hljs-number">0</span>].pp_ref = <span class="hljs-number">1</span>;<br>    pages[<span class="hljs-number">0</span>].pp_link = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//[PGSIZE, npages_basemem) is free</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; npages_basemem; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">0</span>;<br>        pages[i].pp_link = page_free_list;<br>        page_free_list = &amp;pages[i];<br>    &#125;<br>    <br>    <span class="hljs-comment">//IO hole [IOPHYSMEM, EXTPYSMEM) must never be allocated</span><br>    <span class="hljs-keyword">for</span>(;i &lt; EXTPHYSMEM  / PGSIZE; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>        pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//extended memory [EXTPHYSMEM, nextfree) is in use</span><br>    <span class="hljs-comment">//tip boot_alloc algned to PGSIZE</span><br>    <span class="hljs-keyword">for</span>(; i &lt; PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>        pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//rest extended memory is free</span><br>    <span class="hljs-keyword">for</span>(; i &lt; npages; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">0</span>;<br>        pages[i].pp_link = page_free_list;<br>        page_free_list = &amp;pages[i];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc()"></a>page_alloc()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Hint: use page2kva and memset</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-keyword">if</span> (page_free_list == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span>* <span class="hljs-title">page</span> =</span> page_free_list;<br>page_free_list = page-&gt;pp_link;<br>page-&gt;pp_ref = <span class="hljs-number">0</span>;<br>page-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;<br><span class="hljs-built_in">memset</span>(page2kva(page), <span class="hljs-string">&#x27;\0&#x27;</span>, PGSIZE);<br>&#125;<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="page-free"><a href="#page-free" class="headerlink" title="page_free()"></a>page_free()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br><span class="hljs-keyword">if</span>(pp-&gt;pp_ref)&#123;<br>panic(<span class="hljs-string">&quot;page-&gt;pp_ref is nonzero!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pp-&gt;pp_link)&#123;<br>panic(<span class="hljs-string">&quot;page-&gt;pp_link is not NULL!\n&quot;</span>);<br>&#125;<br><br>pp-&gt;pp_link = page_free_list;<br>page_free_list = pp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="check-page-free-list-x2F-check-page-alloc"><a href="#check-page-free-list-x2F-check-page-alloc" class="headerlink" title="check_page_free_list()&#x2F;check_page_alloc()"></a>check_page_free_list()&#x2F;check_page_alloc()</h3><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-18-19-43-04.png" alt="Exercise 1 result"></p><h1 id="Part-2：Virtual-Memory"><a href="#Part-2：Virtual-Memory" class="headerlink" title="Part 2：Virtual Memory"></a>Part 2：Virtual Memory</h1><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><p>阅读 intel 80386 手册，对 x86 的段、页式管理有一个初步的理解。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"> Selector  +--------------+         +-----------+<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     |<span class="hljs-string"> Segmentation </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  Paging   </span>|<br>Software             |<span class="hljs-string">              </span>|<span class="hljs-string">--------&gt;</span>|<span class="hljs-string">           </span>|<span class="hljs-string">----------&gt;  RAM</span><br><span class="hljs-string">            Offset   </span>|<span class="hljs-string">  Mechanism   </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Mechanism </span>|<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     +--------------+         +-----------+<br>            Virtual                   Linear                Physical<br></code></pre></td></tr></table></figure><p>在 X86 的逻辑中，虚拟地址包含一个段选择子和偏移地址，线性地址是段地址转换过后但是没有在页地址转换之前的地址。物理地址是最后得到的地址，可以通过硬件地址总线访问 RAM。</p><h2 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual,Linear,and Physical Addresses"></a>Virtual,Linear,and Physical Addresses</h2><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-19-11-33-12.png" alt="Page Translation"></p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p>在 JOS 中，一个 C 的指针就是虚拟地址的 offset。在 <code>boot/boots.S</code> 中，GDT 将所有的段的地址都以 0 为起始地址，0xffffffff 为界限，这样就可以有效的让段地址转换变得较为简单。这样就可以让线性地址就是虚拟地址的偏移地址，JOS 的老师通过这样的方式让我们专注于页的转换。</p><p>打开 QEMU monitor 过后，Ctrl-a c 打开控制界面，我用的 WSL 还打开了一堆 QQ 之类的软件儿，可能有快捷键冲突，因此可以使用这条命令来试一试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log<br></code></pre></td></tr></table></figure><p>这个时候，在按照相应的命令来进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qemu">xp /Nx paddr 可以看到物理内存地址<br>x /Nx addr 可以看到虚拟内存地址<br>info registers可以看到寄存器内容<br>info mem可以看到已经有的页表映射的虚拟地址空间，以及访问他们的优先级<br>info pg可以看到当前页表的结构<br></code></pre></td></tr></table></figure><h2 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h2><p>在未来的实验中，通常会同时将相同的物理页面映射到多个虚拟地址（或多个环境的地址空间中）。 我们将在与物理页对应的 struct PageInfo 的 pp_ref 字段中保存对每个物理页的引用次数的计数。 当物理页的计数变为零时，该页可以被释放，因为它不再被使用。</p><p>一般来说，这个计数应该等于所有页表中物理页出现在 UTOP 下面的次数（UTOP 以上的映射大多是在引导时由内核设置的，不应该被释放，所以不需要引用计数）。我们还将使用它来跟踪我们保留的指向页目录页面的指针数量，进而跟踪页目录对页表页面的引用数量。</p><p>使用 page_alloc 时要小心。 它返回的页面的引用计数始终为 0，因此一旦您对返回的页面执行了某些操作（例如将其插入页表），pp_ref 就应该递增。 有时这是由其他函数（例如 page_insert）处理的，有时调用 page_alloc 的函数必须直接执行此操作。</p><h2 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h2><p>这个部分开始对页表进行管理，写一些例程来管理 page table，插入和删除 linear-to-physical 的映射，并且创建 page table pages 当需要的时候。</p><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>要实现的函数在 <code>kern/pmap.c</code> 文件中，在实现下列函数之前，需要弄懂页表管理以及多个宏的含义。</p><h4 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk()"></a>pgdir_walk()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pde_t</span> *pde;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span><br><br>pde = &amp;pgdir[PDX(va)];<br><br><span class="hljs-keyword">if</span>(!(*pde &amp; PTE_P))&#123;<br><span class="hljs-keyword">if</span>(create == <span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>page = page_alloc(ALLOC_ZERO);<br><span class="hljs-keyword">if</span>(page == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>page-&gt;pp_ref ++;<br>*pde = page2pa(page) | PTE_P | PTE_W | PTE_U;<br>&#125;<br>&#125;<br><br>pte = (<span class="hljs-type">pte_t</span>*)KADDR(PTE_ADDR(*pde));<br><br><span class="hljs-keyword">return</span> &amp;pte[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region()"></a>boot_map_region()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-type">size_t</span> numpage = ROUNDUP(size, PGSIZE)  / PGSIZE;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numpage; i ++)&#123;<br>pte = pgdir_walk(pgdir, (<span class="hljs-type">void</span>*) va, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(pte == <span class="hljs-literal">NULL</span>)&#123;<br>panic(<span class="hljs-string">&quot;boot_map_region: out of memory!\n&quot;</span>);<br>&#125;<br><br>*pte = (pa | perm | PTE_P);<br><br>va += PGSIZE;<br>pa += PGSIZE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a>page_lookup()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_lookup</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, <span class="hljs-type">pte_t</span> **pte_store)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pde_t</span> *pde;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span><br><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span>(pte == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(*pte_store)&#123;<br>*pte_store = pte;<br>&#125;<br><br>page = pa2page(PTE_ADDR(*pte));<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a>page_remove()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_remove</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span> <br><br>page = page_lookup(pgdir, va, &amp;pte);<br><span class="hljs-keyword">if</span>(page == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>page_decref(page);<br>tlb_invalidate(pgdir, va);<br>*pte = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert()"></a>page_insert()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span><br><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span>(!pte)&#123;<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><br><span class="hljs-keyword">if</span>(*pte &amp; PTE_P)&#123;<br><span class="hljs-keyword">if</span>(PTE_ADDR(*pte) == page2pa(pp))&#123;<br>pp-&gt;pp_ref --;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>tlb_invalidate(pgdir, va);<br>page_remove(pgdir, va);<br>&#125;<br>&#125;<br><br>pp-&gt;pp_ref ++;<br><br>*pte = page2pa(pp) | perm | PTE_P;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="check-page"><a href="#check-page" class="headerlink" title="check_page()"></a>check_page()</h4><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-19-22-00-19.png" alt="virtual memory result"></p><h1 id="Part-3：Kernel-Address-Space"><a href="#Part-3：Kernel-Address-Space" class="headerlink" title="Part 3：Kernel Address Space"></a>Part 3：Kernel Address Space</h1><p>JOS 将处理器的 32-bit 线性地址空间划分为两个部分。在 <code>inc/memlayout.h</code> 中可以看到。</p><p>我们将在实验 3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。</p><p>分割线是由 inc&#x2F;memlayout.h 中的符号 ULIM 随意定义的，为内核保留了大约 256MB 的虚拟地址空间。 这解释了为什么我们需要在实验 1 中为内核提供如此高的链接地址：否则内核的虚拟地址空间中将没有足够的空间来同时映射到其下方的用户环境。</p><h2 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h2><p>由于内核和用户内存都存在于每个环境的地址空间中，因此我们必须使用 x86 页表中的权限位来允许用户代码仅访问地址空间的用户部分。 否则，用户代码中的错误可能会覆盖内核数据，从而导致崩溃或更细微的故障； 用户代码还可能窃取其他环境的私有数据。 请注意，可写权限位（PTE_W）会影响用户和内核代码！</p><p>用户环境将没有权限访问 ULIM 以上的任何内存，而内核将能够读写该内存。 对于地址范围 [UTOP,ULIM)，内核和用户环境都具有相同的权限：可以读取但不能写入该地址范围。 该地址范围用于向用户环境公开某些只读的内核数据结构。 最后，UTOP下面的地址空间是供用户环境使用的； 用户环境将设置访问该内存的权限。</p><h2 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h2><p>现在将在 UTOP 之上设置地址空间：地址空间的内核部分。<br>inc&#x2F;memlayout.h 显示应该使用的布局。<br>使用刚刚编写的函数来设置适当的线性到物理映射。</p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>完善 mem_init()中缺失的代码，位置在 check_page()之后。</p><h4 id="mem-init-1"><a href="#mem-init-1" class="headerlink" title="mem_init()"></a>mem_init()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><br><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><br><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);<br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span><br><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><br><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><br><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><br><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><br><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><br><span class="hljs-comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><br><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><br><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><br><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><br><span class="hljs-comment">// we just set up the mapping anyway.</span><br><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KERNBASE, <span class="hljs-number">0xffffffff</span> - KERNBASE, <span class="hljs-number">0</span>, PTE_W);<br></code></pre></td></tr></table></figure><h4 id="check-kern-pgdir-x2F-check-page-installed-pgdir"><a href="#check-kern-pgdir-x2F-check-page-installed-pgdir" class="headerlink" title="check_kern_pgdir()&#x2F;check_page_installed_pgdir()"></a>check_kern_pgdir()&#x2F;check_page_installed_pgdir()</h4><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-20-07-38-24.png" alt="Exercise 5 result"></p><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-20-07-42-21.png" alt="make grade"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW2 shell</title>
    <link href="/2021/08/13/HW2-shell/"/>
    <url>/2021/08/13/HW2-shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>1、阅读 xv6 book 的第 0 章：<a href="./book-rev10.pdf">点击下载</a></p><p>2、下载 6.828 shell 文件：<a href="./sh.c">点击下载</a></p><p>3、将下列代码粘贴到 t.sh 文件内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> &gt; y<br><span class="hljs-built_in">cat</span> &lt; y | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">wc</span> &gt; y1<br><span class="hljs-built_in">cat</span> y1<br><span class="hljs-built_in">rm</span> y1<br><span class="hljs-built_in">ls</span> |  <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">wc</span><br><span class="hljs-built_in">rm</span> y<br></code></pre></td></tr></table></figure><p>4、编译并且执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o sh sh.c<br>./sh &lt; t.sh<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-24-05.png" alt="sh"></p><p>产生了错误，没有实现，接下来进行实现。</p><h1 id="Executing-simple-commands"><a href="#Executing-simple-commands" class="headerlink" title="Executing simple commands"></a>Executing simple commands</h1><h2 id="实现-ls"><a href="#实现-ls" class="headerlink" title="实现 ls"></a>实现 ls</h2><p>查看 exec manual 页，阅读 execv 并且答应错误信息当 exec 失败的时候，然后实现 ls 的 case 命令，根据 type 定义，我们只需要实现 case ‘ ‘ 的情况：</p><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-31-31.png" alt="execv 参数"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br>   ecmd = (<span class="hljs-keyword">struct</span> execcmd*)cmd;<br>   <span class="hljs-keyword">if</span>(ecmd-&gt;argv[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>     _exit(<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">// fprintf(stderr, &quot;exec not implemented\n&quot;);</span><br>   <span class="hljs-comment">// Your code here ...</span><br>   <span class="hljs-type">int</span> res = execv(ecmd-&gt;argv[<span class="hljs-number">0</span>],ecmd-&gt;argv);<br>   <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)&#123;<br>       <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;exec fails!\n&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-30-49.png" alt="/bin/ls"></p><h2 id="I-x2F-O-redirection"><a href="#I-x2F-O-redirection" class="headerlink" title="I&#x2F;O redirection"></a>I&#x2F;O redirection</h2><p>直接参照 xv6-book 实现重定向就 ok，关闭当前进程的文件描述符，而文件描述符总是从最小的开始增长，所以当我们打开一个文件时，我们将输入&#x2F;输出的标准描述符绑定到该文件上边儿，然后跑 runcmd 就可以直接使用了，完成I&#x2F;O 重定向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>  rcmd = (<span class="hljs-keyword">struct</span> redircmd*)cmd;<br>  <span class="hljs-comment">//fprintf(stderr, &quot;redir not implemented\n&quot;);</span><br>  <span class="hljs-comment">// Your code here ...</span><br>  close(rcmd-&gt;fd);<br>  <span class="hljs-type">int</span> fd = open(rcmd-&gt;file,rcmd-&gt;flags,O_CREAT|O_WRONLY|O_RDONLY);<br>  <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;could not open file %s\n&quot;</span>, rcmd-&gt;file);<br>      _exit(<span class="hljs-number">1</span>);<br>  &#125;<br>  runcmd(rcmd-&gt;cmd);<br>  <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-43-42.png" alt="/bin/cat &lt; x.txt"></p><h2 id="Implement-pipes"><a href="#Implement-pipes" class="headerlink" title="Implement pipes"></a>Implement pipes</h2><p>手动实现一个管道，参考讲义中的管道，直接写，我们将父进程的标准输出绑定到管道的一端，将子进程的标准输出绑定到管道的另一端，这样就可以实现父进程从管道的一端输出，子进程从管道的一端输入，然后我们让子进程跑在管道的左端，父进程跑在管道的右端，父进程等待子进程完成并且退出再执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;|&#x27;</span>:<br>  pcmd = (<span class="hljs-keyword">struct</span> pipecmd*)cmd;<br>  <span class="hljs-comment">//fprintf(stderr, &quot;pipe not implemented\n&quot;);</span><br>  <span class="hljs-comment">// Your code here ...</span><br>  <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>  pipe(pipefd);<br><br>  <span class="hljs-type">int</span> process = fork1();<br>  <span class="hljs-keyword">if</span>(process == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// child process</span><br>      <span class="hljs-comment">// pipe left side</span><br>      close(<span class="hljs-number">1</span>);<br>      dup(pipefd[<span class="hljs-number">1</span>]);<br>      close(pipefd[<span class="hljs-number">0</span>]);<br>      close(pipefd[<span class="hljs-number">1</span>]);<br>      runcmd(pcmd-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-comment">// parent process</span><br>      <span class="hljs-comment">// pipe right side</span><br>      close(<span class="hljs-number">0</span>);<br>      dup(pipefd[<span class="hljs-number">0</span>]);<br>      close(pipefd[<span class="hljs-number">0</span>]);<br>      close(pipefd[<span class="hljs-number">1</span>]);<br>      wait(<span class="hljs-number">0</span>);<br>      runcmd(pcmd-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">break</span>;<br><br></code></pre></td></tr></table></figure><p>手动补全 tt.sh 文件，然后尝试看能否正确运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/bin/ls &gt; y<br>/bin/cat &lt; y | /bin/sort | /bin/uniq | /bin/wc &gt; y1<br>/bin/cat y1<br>/bin/rm y1<br>/bin/ls |  /bin/sort | /bin/uniq | /bin/wc<br>/bin/rm y<br><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-51-25.png" alt="pipe test"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW1 boot xv6</title>
    <link href="/2021/08/12/HW1-boot-xv6/"/>
    <url>/2021/08/12/HW1-boot-xv6/</url>
    
    <content type="html"><![CDATA[<h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><p>1、拉取 xv6 源代码文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 6.828<br><span class="hljs-built_in">cd</span> 6.828<br>git <span class="hljs-built_in">clone</span> git://github.com/mit-pdos/xv6-public.git<br></code></pre></td></tr></table></figure><p>2、编译 xv6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> xv6-public<br>make<br></code></pre></td></tr></table></figure><h1 id="Finding-and-breaking-at-an-address"><a href="#Finding-and-breaking-at-an-address" class="headerlink" title="Finding and breaking at an address"></a>Finding and breaking at an address</h1><p>1、找到内核的入口点的地址，即 _start 的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nm kernel | grep _start<br></code></pre></td></tr></table></figure><p>在这个例子中，地址是 0x0010000c</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-20-25-30.png" alt="_start"></p><p>2、在 QEMU-GDB 内跑内核代码，并且设置刚刚找到的断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make qemu-gdb<br></code></pre></td></tr></table></figure><p>并且在另外一个 shell 中，使用 gdb，并且输入<code>target remote:26000</code>连接上qemu进行调试，通过添加断点，我们可以让 qemu 执行停在内核的入口地址处。</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-20-31-11.png" alt="breakpoint at 0x0010000c"></p><h1 id="Exercise：What-is-on-the-stack"><a href="#Exercise：What-is-on-the-stack" class="headerlink" title="Exercise：What is on the stack"></a>Exercise：What is on the stack</h1><p>当我们在断点 0x0010000c 处查看寄存器和 stack 内的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gdb"><br>info reg<br>x/24x $esp<br><br></code></pre></td></tr></table></figure><p>我们可以关注一下一些我们处理过的寄存器，一个是和堆栈相关的寄存器 <code>%esp</code> 和 <code>%eip</code>，在源代码中，从 bootasm.S 中设置堆栈为 C 语言建立堆栈开始，xv6 将堆栈的上限设置为 0x7c00，堆栈从 0x7c00 增长到了 0x7bdc 的位置，同时 <code>%ebp</code> 保存了上一次压栈的位置 0x7bf8，由于此时打了断点，可以看到 <code>%eip</code> 寄存器的值刚好指向 0x10000c 的位置。由于此时运行 boot loader 进入实模式，此时的 <code>%eflags</code> 寄存器的权限处于最高权限，代码段寄存器 <code>%cs</code> 的值，正好是 kernel.ld 中的 0x80100000 中的 0x8，此时数据段寄存器 <code>%ds</code> 正好指向对其过后的 0x10，然后是控制寄存器 <code>%cr0</code> 开起 32-bit 模式。以上寄存器的值符合运行的实际逻辑，压栈的大小，得去分析指令的条数来验证，这里没有验证，计算起来好复杂，反正是对的。</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-20-35-08.png" alt="寄存器值"></p><p>然后，我们就实际来看一看堆栈里边儿的内容吧。堆栈里的内容，我们可以通过单条指令执行来查看。</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-21-11-21.png" alt="堆栈内容"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1 Booting a PC</title>
    <link href="/2021/08/09/Lab1-Booting-a-PC/"/>
    <url>/2021/08/09/Lab1-Booting-a-PC/</url>
    
    <content type="html"><![CDATA[<p>   lab1 主要是介绍一个PC启动时如何办到的，分为了三个部分：熟悉 x86 汇编语言、熟悉 QEMU x86 模拟器、熟悉 PC 加电启动过程，然后主要的代码在 kernel 文件夹下边儿。</p><p>​实验链接：<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">https://pdos.csail.mit.edu/6.828/2018/labs/lab1/</a></p><h2 id="实验文件安装"><a href="#实验文件安装" class="headerlink" title="实验文件安装"></a>实验文件安装</h2><p>​实验环境：Ubuntu 20.04 LTS WSL</p><p>​环境配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc g++ build-essential gdb gcc-multilib qemu qemu-system<br></code></pre></td></tr></table></figure><p>​环境检测，查看是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -i<br>gcc -m32 -print-libgcc-file-name<br></code></pre></td></tr></table></figure><p>​下载 git 仓库，并尝试安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 6.828<br><span class="hljs-built_in">cd</span> 6.828<br>git <span class="hljs-built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab<br><span class="hljs-built_in">cd</span> lab<br></code></pre></td></tr></table></figure><p>​基本的一些操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make qemu<br>make grade<br></code></pre></td></tr></table></figure><h2 id="Part-1：PC-Bootstrap"><a href="#Part-1：PC-Bootstrap" class="headerlink" title="Part 1：PC Bootstrap"></a>Part 1：PC Bootstrap</h2><p>​这个部分主要是学习 X86 汇编语言，并且学习如何通过 QEMU 和 QEMU&#x2F;GDB 进行 debug。</p><h3 id="x86-assembly"><a href="#x86-assembly" class="headerlink" title="x86 assembly"></a>x86 assembly</h3><ul><li>PC Assembly Book：<a href="./pcasm-book.pdf">点击下载</a> </li><li>内联汇编：<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html</a></li><li>80368编程指导：<a href="./i386.pdf">点击下载</a>  <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm</a></li><li>IA-32 Intel Architecture 开发手册：<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></li></ul><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>​要求：熟悉 X86 汇编，并且了解 C 语言内联汇编的方式，这个之前做汇编学习过，也在 CSAPP 中学习过，可以直接过了就。</p><h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><p>​实验通过 QEMU 模拟 X86 的环境，并进行相关的系统模拟启动执行，下边儿进行具体的步骤操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> lab<br>make<br>make qemu<br>make qemu-nox<br></code></pre></td></tr></table></figure><p>make 的时候，进行编译生成 ELF 的 image 镜像，并且将它保存到了 obj&#x2F;kern&#x2F;kernel.img 这个地方，镜像里边儿保存了两个部分：obj&#x2F;boot&#x2F;boot和obj&#x2F;kernel</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-34-26.png" alt="make"></p><p>make qemu 或者 make qemu-nox 的时候从磁盘上启动该镜像，并且进入一个 Shell 的小界面如下图，该 shell 提供了两条命令：help、kerninfo</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-35-12.png" alt="make qemu"></p><p>退出 qemu 的话，只需要 ctrl+a x 按顺序按下去。然后，如果是在没有桌面环境的情况下，可以考虑使用 make qemu-nox 的命令行，这样就可以直接在 shell 上显示。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-36-45.png" alt="make qemu-nox"></p><h3 id="物理内存地址"><a href="#物理内存地址" class="headerlink" title="物理内存地址"></a>物理内存地址</h3><p>​这个部分进行了JOS物理内存地址的学习，当执行 kerninfo 的时候显示了部分信息，这个部分的信息是 JOS 内核的一些基本内存信息：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-38-22.png" alt="kernifo"></p><p>​可以看到这个部分的物理内存地址的分布情况，intel 处理器在研发过程中，从最早的 16 位到后来的 32 位、64 位，CPU 的寻址能力在提升，其物理地址空间也在变化，但总体而言 80386 的内存地址如下：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-40-54.png" alt="PC&#39;s physical address layout"></p><p>​也就是说，在 PC 启动的时候 CPU 运行在实模式，只能进行 1M 的访存，然后进入保护模式过后才拥有 4G 的内存访问能力，Intel 进行了访问的拓展，所以内存地址如上图呈现。</p><p>​其中，上述内存布局我觉得应该掌握一些基本的常识：</p><ul><li>第一代 PC 的 16-bits 的 Intel 8086 处理器，只能访问 1Mb 的内存，最早的 PC 机物理地址空间开始于 0x00000000，结束于 0x0000FFFF 而不是 0xFFFFFFFF 的 64KB</li><li>Low Memory 的 640KB 的空间只能用于随机的访问（RAM）</li><li>从 0x000A0000 开始到 0x000F0000 的 384KB 的空间被保留用于硬件的寻址，比如 VGA</li><li>1M 保留空间种最重要的部分是 BIOS ROM，占据从 0x000C0000 到 0x00100000 的 64KB 空间，BIOS 主要是进行硬件检查和初始化工作，最后从硬盘或者 CD-ROM 上装载系统，并且交接控制权给操作系统</li></ul><p>JOS 只是用前物理内存的 256M，假装机子有 32-bit 的物理地址空间。</p><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>​我们尝试进行debug的方式学习，在同一个目录下打开两个窗口，让gdb连接上QEMU进行调试，然后去学习BIOS是如何进行工作的。实验中提供了一个.gdbinit的文件，设置gdb调试的时候使用16位的模式，并且让gdb监听QEMU。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> qemu-gdb<br><span class="hljs-built_in">make</span> gdb<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-53-45.png" alt="make gdb"></p><p>​可以看到，gdb 使用了该 .gdbint 文件进行操作，并且成功监听 QEMU。当前的架构是为 i8086 也就是 16-bits 模式，这个时候会执行一条指令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[f000:fff0] <span class="hljs-number">0xffff0</span>: ljmp <span class="hljs-number">$0</span>x3630,<span class="hljs-number">$0</span>xf000e05b<br><span class="hljs-number">0x0000fff0</span> <span class="hljs-keyword">in</span> ?()<br></code></pre></td></tr></table></figure><p>​这条指令是gdb反汇编产生的代码，可以看到：</p><ul><li>IBM PC 启动执行的物理地址是再 0x000ffff0，它正是在 ROM BIOS 的高 64KB 的位置</li><li>PC 执行的时候执行：CS &#x3D; 0xf000 和 IP &#x3D; 0xfff0</li><li>执行的第一条指令是 jmp，并且跳去的地址是 0xf000e05b，也就是 CS &#x3D; 0xf000，IP &#x3D; 0xe05b</li></ul><p>​思考一个问题就是为什么 QEMU 里边儿显示的会这样执行？其实这个是 Intel 8086 处理器的设计有关，由于 BIOS 在 PC 中是 “hard-wired” 到物理地址范围0x000f0000-0x000fffff，这样设计是为了保证 PC 加电的时候能够立马执行并且控制系统，因为这个时候 RAM 内存中是没有可以执行的软件儿的（这个软件儿就是 OS）。QEMU emulator 它自带了 BIOS，当处理器重置的时候，QEMU 的虚拟处理器像正常的 CPU 那样，先是进入实模式并且设置 [CS:IP] 为 [0xf000:0xfff0]，这样可以让它根据CS:IP 进行访问；</p><p>实模式下，CPU 寻址方式是根据 CS:IP 的值来的，physical address &#x3D; 16 * segment + offset，因此：</p><p>​16 * 0xf000 + 0xfff0</p><p>​&#x3D; 0xf0000 + 0xfff0</p><p>​&#x3D; 0xffff0</p><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>​要求：使用 GDB 命令 si（step instruction）进行单步跟踪，大致了解 BIOS 干了什么，而不需要太清楚细节。</p><p>​1、学习一个链接，关于计算机IO的：<a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm</a></p><p>​2、我们进行单步的跟踪得到如下的结果：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-01-10.png" alt="gdb si"></p><p>​总而言之，当 BIOS 运行的时候，它设置好中断描述符表，初始化各种设备比如 VGA 显示器、这个时候 QEMU 中的 “Starting SeaBIOS” 就是初始化显示器过后显示的。在完成 PCI bus 和各种重要的 BIOS 知道的设备初始话过后，它开始寻找可以启动的设备比如软盘、硬盘、CD-ROM，当发现可以启动的设备过后，BIOS 读取该设备中的bootloader 并且将控制权移交给 bootloader。</p><h2 id="Part-2：The-Boot-Loader"><a href="#Part-2：The-Boot-Loader" class="headerlink" title="Part 2：The Boot Loader"></a>Part 2：The Boot Loader</h2><p>​PC 中的软盘、硬盘都可以被划分为一个个的大小为 512 字节的扇区，一个扇区是一次磁盘操作的最小粒度，每一次读取或者写入都必须是一个或者多个扇区。如果一个磁盘是可以用来启动的操作系统的，就把这个磁盘的第一个扇区叫做启动扇区，当 BIOS 找到一个可以启动的软盘或者硬盘过后，它就会将这 512 个字节加载到内存物理地址为 0x7c00 到0x7dff中，然后执行 jmp 来设置 CS:IP 为0000:7c00，转移控制给 boot loader 程序。和 BIOS 的加载地址一样，这些地址都是规定好的标准地址。</p><p>​在 6.828 中采用传统的硬盘启动机制，意识是说 boot loader 程序的大小必须小于512 字节，然后整个 boot loader 是由一个汇编文件，boot&#x2F;boot.S 以及一个 C 语言的文件，boot&#x2F;main.c 组成，其必须具备两个功能：</p><p>​1、boot loader 需要讲 CPU 从 16-bits 实模式切换到 32-bits 保护模式，只有在保护模式下边儿才可以完成超过 1M 的访存能力，并且在保护模式下，segment:offset pair 转换成物理地址的方式也不再是简单的乘以 16，而实更为复杂的段页式模式；</p><p>​2、boot loader 通过 x86 特定的 I&#x2F;O 指令访问 IDE 设备寄存器，从磁盘中将 JOS 的内核读入内存</p><p>​说明：boot loader 来说，有一个文件比较重要，obj&#x2F;boot&#x2F;boot.asm，这个文件是真实运行的 boot loader 程序的反汇编版本，可以和它的源码 boot.S 和main.c 比较。同理，obj&#x2F;kern&#x2F;kernel.asm 也是 JOS kernel 的反汇编版本，后边儿调试应该会用到。</p><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><p>​要求：在地址 0x7c00 处设置断点，这是 boot sector 被加载的位置。然后让程序继续运行直到这个断点。跟踪 &#x2F;boot&#x2F;boot.S 文件的每一条指令，同时使用 boot.S 文件和系统为你反汇编出来的文件 obj&#x2F;boot&#x2F;boot.asm。你也可以使用 GDB 的 x&#x2F;i 指令来获取去任意一个机器指令的反汇编指令，把源文件 boot.S 文件和 boot.asm 文件以及在 GDB 反汇编出来的指令进行比较。追踪到 bootmain 函数中，而且还要具体追踪到readsect() 子函数里面。找出和 readsect() C 语言程序的每一条语句所对应的汇编指令，回到 bootmain()，然后找出把内核文件从磁盘读取到内存的那个 for 循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p><p>​我们首先查看 boot.S 和 main.c 中源码文件中的内容：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">#include &lt;<span class="hljs-keyword">inc</span>/mmu<span class="hljs-number">.</span>h&gt;<br><br># Start the <span class="hljs-meta">CPU</span>: switch to <span class="hljs-number">32</span>-bit protected mode, jump <span class="hljs-keyword">into</span> C.<br># The BIOS loads this code from the first sector of the hard disk <span class="hljs-keyword">into</span><br># memory <span class="hljs-meta">at</span> physical address <span class="hljs-number">0x7c00</span> <span class="hljs-keyword">and</span> starts executing <span class="hljs-keyword">in</span> real mode<br># with %cs=<span class="hljs-number">0</span> %ip=7c00.<br><span class="hljs-meta"></span><br><span class="hljs-meta">.set</span> PROT_MODE_CSEG, <span class="hljs-number">0x8</span>         # kernel code <span class="hljs-meta">segment</span> selector<br><span class="hljs-meta">.set</span> PROT_MODE_DSEG, <span class="hljs-number">0x10</span>        # kernel data <span class="hljs-meta">segment</span> selector<br><span class="hljs-meta">.set</span> CR0_PE_ON,      <span class="hljs-number">0x1</span>         # protected mode enable flag<br><span class="hljs-meta"></span><br><span class="hljs-meta">.globl</span> start<br><span class="hljs-symbol">start:</span><br><span class="hljs-meta">  .code16</span>                     # Assemble for <span class="hljs-number">16</span>-bit mode<br>  <span class="hljs-keyword">cli</span>                         # Disable interrupts<br>  <span class="hljs-keyword">cld</span>                         # String operations increment<br><br>  # Set <span class="hljs-meta">up</span> the important data <span class="hljs-meta">segment</span> registers (<span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-built_in">SS</span>).<br>  xorw    %ax,%ax             # <span class="hljs-meta">Segment</span> number <span class="hljs-meta">zero</span><br>  movw    %ax,%ds             # -&gt; Data <span class="hljs-meta">Segment</span><br>  movw    %ax,%es             # -&gt; Extra <span class="hljs-meta">Segment</span><br>  movw    %ax,%ss             # -&gt; Stack <span class="hljs-meta">Segment</span><br><br>  # Enable A20:<br>  #   For backwards compatibility with the earliest PCs, physical<br>  #   address line <span class="hljs-number">20</span> is tied low, so that addresses higher than<br>  #   1MB wrap around to <span class="hljs-meta">zero</span> by <span class="hljs-meta">default</span>.  This code undoes this.<br><span class="hljs-symbol">seta20.1:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.1</span><br><br>  movb    <span class="hljs-number">$0</span>xd1,%al               # <span class="hljs-number">0xd1</span> -&gt; port <span class="hljs-number">0x64</span><br>  outb    %al,<span class="hljs-number">$0</span>x64<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">seta20.2:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.2</span><br><br>  movb    <span class="hljs-number">$0</span>xdf,%al               # <span class="hljs-number">0xdf</span> -&gt; port <span class="hljs-number">0x60</span><br>  outb    %al,<span class="hljs-number">$0</span>x60<br><br>  # Switch from real to protected mode, using a bootstrap GDT<br>  # <span class="hljs-keyword">and</span> <span class="hljs-meta">segment</span> translation that makes virtual addresses <br>  # identical to their physical addresses, so that the <br>  # effective memory map does <span class="hljs-keyword">not</span> change during the switch.<br>  <span class="hljs-keyword">lgdt</span>    gdtdesc<br>  movl    %cr0, %eax<br>  orl     $CR0_PE_ON, %eax<br>  movl    %eax, %cr0<br>  <br>  # Jump to next instruction, but <span class="hljs-keyword">in</span> <span class="hljs-number">32</span>-bit code <span class="hljs-meta">segment</span>.<br>  # Switches processor <span class="hljs-keyword">into</span> <span class="hljs-number">32</span>-bit mode.<br>  ljmp    $PROT_MODE_CSEG, $protcseg<br><span class="hljs-meta"></span><br><span class="hljs-meta">  .code32</span>                     # Assemble for <span class="hljs-number">32</span>-bit mode<br><span class="hljs-symbol">protcseg:</span><br>  # Set <span class="hljs-meta">up</span> the protected-mode data <span class="hljs-meta">segment</span> registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="hljs-meta">segment</span> selector<br>  movw    %ax, %ds                # -&gt; <span class="hljs-built_in">DS</span>: Data <span class="hljs-meta">Segment</span><br>  movw    %ax, %es                # -&gt; <span class="hljs-built_in">ES</span>: Extra <span class="hljs-meta">Segment</span><br>  movw    %ax, %fs                # -&gt; <span class="hljs-built_in">FS</span><br>  movw    %ax, %gs                # -&gt; <span class="hljs-built_in">GS</span><br>  movw    %ax, %ss                # -&gt; <span class="hljs-built_in">SS</span>: Stack <span class="hljs-meta">Segment</span><br>  <br>  # Set <span class="hljs-meta">up</span> the stack pointer <span class="hljs-keyword">and</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">into</span> C.<br>  movl    $start, %esp<br>  <span class="hljs-keyword">call</span> bootmain<br><br>  # If bootmain returns (it shouldn<span class="hljs-string">&#x27;t), loop.</span><br><span class="hljs-string">spin:</span><br><span class="hljs-string">  jmp spin</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Bootstrap GDT</span><br><span class="hljs-string">.p2align 2                                # force 4 byte alignment</span><br><span class="hljs-string">gdt:</span><br><span class="hljs-string">  SEG_NULL# null seg</span><br><span class="hljs-string">  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span><br><span class="hljs-string">  SEG(STA_W, 0x0, 0xffffffff)        # data seg</span><br><span class="hljs-string"></span><br><span class="hljs-string">gdtdesc:</span><br><span class="hljs-string">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="hljs-string">  .long   gdt                             # address gdt</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>​然后是 main.c 中几个函数的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/x86.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/elf.h&gt;</span></span><br><br><span class="hljs-comment">/**********************************************************************</span><br><span class="hljs-comment"> * This a dirt simple boot loader, whose sole job is to boot</span><br><span class="hljs-comment"> * an ELF kernel image from the first IDE hard disk.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * DISK LAYOUT</span><br><span class="hljs-comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span><br><span class="hljs-comment"> *    be stored in the first sector of the disk.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * The 2nd sector onward holds the kernel image.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * The kernel image must be in ELF format.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * BOOT UP STEPS</span><br><span class="hljs-comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span><br><span class="hljs-comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span><br><span class="hljs-comment"> *    into memory and jumps to it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * Assuming this boot loader is stored in the first sector of the</span><br><span class="hljs-comment"> *    hard-drive, this code takes over...</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * control starts in boot.S -- which sets up protected mode,</span><br><span class="hljs-comment"> *    and a stack so C code then run, then calls bootmain()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span><br><span class="hljs-comment"> **********************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTSIZE512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELFHDR((struct Elf *) 0x10000) <span class="hljs-comment">// scratch space</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">uint32_t</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">readseg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint32_t</span>)</span>;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bootmain</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br><span class="hljs-comment">// read 1st page off disk</span><br>readseg((<span class="hljs-type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// is this a valid ELF?</span><br><span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)<br><span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">// load each program segment (ignores ph flags)</span><br>ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);<br>eph = ph + ELFHDR-&gt;e_phnum;<br><span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)<br><span class="hljs-comment">// p_pa is the load address of this segment (as well</span><br><span class="hljs-comment">// as the physical address)</span><br>readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);<br><br><span class="hljs-comment">// call the entry point from the ELF header</span><br><span class="hljs-comment">// note: does not return!</span><br>((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) (ELFHDR-&gt;e_entry))();<br><br>bad:<br>outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br><span class="hljs-comment">/* do nothing */</span>;<br>&#125;<br><br><span class="hljs-comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span><br><span class="hljs-comment">// Might copy more than asked</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readseg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> pa, <span class="hljs-type">uint32_t</span> count, <span class="hljs-type">uint32_t</span> offset)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> end_pa;<br><br>end_pa = pa + count;<br><br><span class="hljs-comment">// round down to sector boundary</span><br>pa &amp;= ~(SECTSIZE - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// translate from bytes to sectors, and kernel starts at sector 1</span><br>offset = (offset / SECTSIZE) + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span><br><span class="hljs-comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span><br><span class="hljs-comment">// we load in increasing order.</span><br><span class="hljs-keyword">while</span> (pa &lt; end_pa) &#123;<br><span class="hljs-comment">// Since we haven&#x27;t enabled paging yet and we&#x27;re using</span><br><span class="hljs-comment">// an identity segment mapping (see boot.S), we can</span><br><span class="hljs-comment">// use physical addresses directly.  This won&#x27;t be the</span><br><span class="hljs-comment">// case once JOS enables the MMU.</span><br>readsect((<span class="hljs-type">uint8_t</span>*) pa, offset);<br>pa += SECTSIZE;<br>offset++;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">waitdisk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// wait for disk reaady</span><br><span class="hljs-keyword">while</span> ((inb(<span class="hljs-number">0x1F7</span>) &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x40</span>)<br><span class="hljs-comment">/* do nothing */</span>;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">uint32_t</span> offset)</span><br>&#123;<br><span class="hljs-comment">// wait for disk to be ready</span><br>waitdisk();<br><br>outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// count = 1</span><br>outb(<span class="hljs-number">0x1F3</span>, offset);<br>outb(<span class="hljs-number">0x1F4</span>, offset &gt;&gt; <span class="hljs-number">8</span>);<br>outb(<span class="hljs-number">0x1F5</span>, offset &gt;&gt; <span class="hljs-number">16</span>);<br>outb(<span class="hljs-number">0x1F6</span>, (offset &gt;&gt; <span class="hljs-number">24</span>) | <span class="hljs-number">0xE0</span>);<br>outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);<span class="hljs-comment">// cmd 0x20 - read sectors</span><br><br><span class="hljs-comment">// wait for disk to be ready</span><br>waitdisk();<br><br><span class="hljs-comment">// read a sector</span><br>insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE/<span class="hljs-number">4</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​研究上述的两段儿代码，我们可以知道基本的过程，首先这两段儿程序共同构成了 boot loader 程序，并且这两段儿程序放到磁盘的第一个扇区作为启动扇区。BIOS 加载该扇区，同时这两段代码先执行的是 boot.S，在 boot.S 中从实模式切换到保护模式，并且建立好堆栈，在堆栈建立好过后才能够开始运行 C 代码，这个时候执行 main.c 中的函数bootmain()，然后 bootmain() 将内核加载进来过后，开始将控制权交给 JOS Kernel，这样就完成了启动工作。</p><p>​能够回答以下问题：</p><ul><li><p>处理器从什么时候开始执行 32 位代码？究竟是什么导致从 16 位模式切换到 32 位模式？</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">  .code32</span>                     # Assemble for <span class="hljs-number">32</span>-bit mode<br><span class="hljs-symbol">protcseg:</span><br>  # Set <span class="hljs-meta">up</span> the protected-mode data <span class="hljs-meta">segment</span> registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="hljs-meta">segment</span> selector<br>  movw    %ax, %ds                # -&gt; <span class="hljs-built_in">DS</span>: Data <span class="hljs-meta">Segment</span><br>  movw    %ax, %es                # -&gt; <span class="hljs-built_in">ES</span>: Extra <span class="hljs-meta">Segment</span><br>  movw    %ax, %fs                # -&gt; <span class="hljs-built_in">FS</span><br>  movw    %ax, %gs                # -&gt; <span class="hljs-built_in">GS</span><br>  movw    %ax, %ss                # -&gt; <span class="hljs-built_in">SS</span>: Stack <span class="hljs-meta">Segment</span><br>  <br>  # Set <span class="hljs-meta">up</span> the stack pointer <span class="hljs-keyword">and</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">into</span> C.<br>  movl    $start, %esp<br>  <span class="hljs-keyword">call</span> bootmain<br><br></code></pre></td></tr></table></figure><p>系统从.code32部分开始执行32位代码如上所示；</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.globl</span> start<br><span class="hljs-symbol">start:</span><br><span class="hljs-meta">  .code16</span>                     # Assemble for <span class="hljs-number">16</span>-bit mode<br>  <span class="hljs-keyword">cli</span>                         # Disable interrupts<br>  <span class="hljs-keyword">cld</span>                         # String operations increment<br><br>  # Set <span class="hljs-meta">up</span> the important data <span class="hljs-meta">segment</span> registers (<span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-built_in">SS</span>).<br>  xorw    %ax,%ax             # <span class="hljs-meta">Segment</span> number <span class="hljs-meta">zero</span><br>  movw    %ax,%ds             # -&gt; Data <span class="hljs-meta">Segment</span><br>  movw    %ax,%es             # -&gt; Extra <span class="hljs-meta">Segment</span><br>  movw    %ax,%ss             # -&gt; Stack <span class="hljs-meta">Segment</span><br></code></pre></td></tr></table></figure><p>CPU首先是运行在实模式，这个时候的 boot loader 运行在 16-bits 模式下边儿，这个时候中断屏蔽；由于之前 BIOS 执行的时候我们不清楚会不会寄存器内的内容是否会变我们无法保证，因此将 <code>%ax</code> 内的内容设置为0过后赋值给 <code>%ds、%es、%ss</code> 三个寄存器来清零；</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">  # Enable A20:<br>  #   For backwards compatibility with the earliest PCs, physical<br>  #   address line <span class="hljs-number">20</span> is tied low, so that addresses higher than<br>  #   1MB wrap around to <span class="hljs-meta">zero</span> by <span class="hljs-meta">default</span>.  This code undoes this.<br><span class="hljs-symbol">seta20.1:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.1</span><br><br>  movb    <span class="hljs-number">$0</span>xd1,%al               # <span class="hljs-number">0xd1</span> -&gt; port <span class="hljs-number">0x64</span><br>  outb    %al,<span class="hljs-number">$0</span>x64<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">seta20.2:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.2</span><br><br>  movb    <span class="hljs-number">$0</span>xdf,%al               # <span class="hljs-number">0xdf</span> -&gt; port <span class="hljs-number">0x60</span><br>  outb    %al,<span class="hljs-number">$0</span>x60<br></code></pre></td></tr></table></figure><p>由于运行在实模式下，物理主线的低 20 位是没有用到的，以至于总是使用高地址的 1 M 内存，因此需要开启 A20 模式，来让这些位可以使用。为什么这样可以让 A20 开启呢？在 Intel 设计中，通过键盘控制器寄存器来实现 A20 开启，如主线 port 描述中所述：<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p><img src="https://imgs.bencorn.com/imgs/2021/08/11/+08000811143425.png" alt="port"></p><p><img src="https://imgs.bencorn.com/imgs/2021/08/11/+08000811143314.png" alt="port value"></p><p><img src="https://imgs.bencorn.com/imgs/2021/08/11/+08000811143708.png" alt="A20"></p><p>可以看到，其中 0x64 端口是键盘控制器，当 0xd1 值输出到 0x64 port 里边儿，这个时候使 A20 gate 受到控制，然后再向 0x0060 port 写入 0xdf，这个时候根据port 描述可知，直接 enable address A20，至此 CPU 可以达到寻址范围增加，开启A20 成功。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># Switch from real to protected mode, using a bootstrap GDT<br># <span class="hljs-keyword">and</span> <span class="hljs-meta">segment</span> translation that makes virtual addresses <br># identical to their physical addresses, so that the <br># effective memory map does <span class="hljs-keyword">not</span> change during the switch.<br><span class="hljs-keyword">lgdt</span>    gdtdesc<br>movl    %cr0, %eax<br>orl     $CR0_PE_ON, %eax<br>movl    %eax, %cr0<br><br># Jump to next instruction, but <span class="hljs-keyword">in</span> <span class="hljs-number">32</span>-bit code <span class="hljs-meta">segment</span>.<br># Switches processor <span class="hljs-keyword">into</span> <span class="hljs-number">32</span>-bit mode.<br>ljmp    $PROT_MODE_CSEG, $protcseg<br></code></pre></td></tr></table></figure><p>由上述知道，CR0_PE_ON 里边儿的值是 0x1，这个是保护模式 enable 的标志，加载好全局描述符表过后，cr0 控制器要通过异或将标志位打开，同时最后执行一个 jmp 指令，其中 $PROT_MODE_CSEG，这个是 JOS kernel 的代码段地址，在保护模式下运行该代码段，这样就顺利切换到了 Kernel。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># Bootstrap GDT<br><span class="hljs-meta">.p2align</span> <span class="hljs-number">2</span>                                # force <span class="hljs-number">4</span> <span class="hljs-built_in">byte</span> alignment<br><span class="hljs-symbol">gdt:</span><br>  SEG_NULL# null <span class="hljs-built_in">seg</span><br>  <span class="hljs-built_in">SEG</span>(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)# code <span class="hljs-built_in">seg</span><br>  <span class="hljs-built_in">SEG</span>(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)        # data <span class="hljs-built_in">seg</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gdtdesc:</span><br><span class="hljs-meta">  .word</span>   <span class="hljs-number">0x17</span>                            # sizeof(gdt) - <span class="hljs-number">1</span><br><span class="hljs-meta">  .long</span>   gdt                             # address gdt<br></code></pre></td></tr></table></figure><p>其中 lgdt gdtdesc，把 gdtdesc 标识符的值送入全局映射描述符表 GDTR 中，CPU 的 GDTR中 保存了 gdt 的起始地址和 gdt 表的长，其中 GDTR 是一个位宽位 48 的寄存器，低 16 位表示该表的长度，高 32 表示该表在内存中的起始位置。gdtdesc 是一个标识符，其中前 2 个字节表示 gdt 表大小，后 4 个字节表示 gdt 表的内存中地址起始位置。</p><p>而 gdt 描述符分为了三个段，分别是 null seg、code seg、data seg，而 JOS 中是没有分段机制的，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是 0x0，大小都是 0xfffffffff &#x3D; 4GB。</p><p>其中 SEG() 函数我们可以在 mmu.h 中找到，它是一个宏函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Macros to build GDT entries in assembly.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEG_NULL\</span><br><span class="hljs-meta">.word 0, 0;\</span><br><span class="hljs-meta">.byte 0, 0, 0, 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEG(type,base,lim)\</span><br><span class="hljs-meta">.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);\</span><br><span class="hljs-meta">.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),\</span><br><span class="hljs-meta">(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span><span class="hljs-comment">// not __ASSEMBLER__</span></span><br><br></code></pre></td></tr></table></figure></li></ul><p>其中函数参数优势按个，分别是 type 表示了访问权限，base 表示这个段的起始地址，lim 表示这个段的大小界限。</p><p> 完成上述步骤过后，就可以 call bootmain，这个时候将 kernel.img 从磁盘中读进来，然后就可以开始执行啦。</p><ul><li>引导加载程序执行 的最后一条指令是什么，它刚刚加载的内核的第一条指令是什么？</li></ul><p>最后一条指令是bootmain程序中的((void (*)(void)) (ELFHDR-&gt;e_entry))(); 即跳转到操作系统内核程序的起始指令处。</p><p>它刚刚加载的第一条指令是位于 kern&#x2F;entry.S 文件中的第一句，movw $0x1234,0x472</p><ul><li>内核的第一条指令在哪里？</li></ul><p>kern&#x2F;entry.S</p><ul><li>引导加载程序如何决定它必须读取多少个扇区才能从磁盘获取整个内核？它在哪里找到这些信息？</li></ul><p>引导加载程序读取操作系统文件 Program Header Table 中，这个表会描述整个内核占了几个扇区，需要读取多少个段才可以将内核加载进来；这些信息保存在 kernel.img 的ELF 头部信息当中</p><h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>​学习 boot&#x2F;main.c，在此之前需要学习 C 语言的指针，这个也是一个难点，同时需要学习 ELF 文件的格式，这样才能够继续阅读代码。</p><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>​要求：阅读 K&amp;R 中 5.1-5.5，学习 C 语言中指针和地址，然后下载 pointers.c 文件，运行它，并且搞懂那些值为什么会这样出现。其中该程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-type">int</span> *c;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);<br><br>    c = a;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>a[i] = <span class="hljs-number">100</span> + i;<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c[<span class="hljs-number">1</span>] = <span class="hljs-number">300</span>;<br>    *(c + <span class="hljs-number">2</span>) = <span class="hljs-number">301</span>;<br>    <span class="hljs-number">3</span>[c] = <span class="hljs-number">302</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c = c + <span class="hljs-number">1</span>;<br>    *c = <span class="hljs-number">400</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c = (<span class="hljs-type">int</span> *) ((<span class="hljs-type">char</span> *) c + <span class="hljs-number">1</span>);<br>    *c = <span class="hljs-number">500</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    b = (<span class="hljs-type">int</span> *) a + <span class="hljs-number">1</span>;<br>    c = (<span class="hljs-type">int</span> *) ((<span class="hljs-type">char</span> *) a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> ac, <span class="hljs-type">char</span> **av)</span><br>&#123;<br>    f();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​编译并执行所得结果如下所示，结果分析：</p><p>​学习完 CSAPP 咱们都应该知道，指针是指向某个内存地址的一个标识，而且指针也是具有不同的类型的，C 语言提供了访问指针地址的操作，同样提供了访问该地址位置的值的操作，指针操作是会改变该内存地址的值的，因此，不论多少指针或者说指针张啥样，只要修改其中任何一个指针的值，则其他指向该地址的指针的值都会改变，因此我们可以知道：</p><p>​a、b、c均是指向int类型的指针，不同点是 a 是采用数组的方式直接静态分配了内存，其大小为 4*4 字节，并且 a 执行数组的起始地址即 a[0]；b 采用动态 malloc 的方式分配了 16 个字节的 void 类型地址，并且 b 指向这块内存的起始地址；c 只是命名了一个空指针，其单纯指向一个地址，没有大小或者说指针自身大小即根据多少位机子判断，其指向内存中的某个 int 的地址；我们也应该知道 int 是 4 个字节，指针大小和计算机位数有关，如 64-bits 的是 8 字节，32-bits 是 4 字节；</p><p>​c &#x3D; a 让 c 和 a 同时指向了一块儿数组内存地址的起始地址，所以 c 和 a 就没有任何区别了就；</p><p>​第二行结果中，先循环修改了 a 的内容，然后修改 c[0] 中的值，由于 c 和 a 指向同一内存地址，因此 a[0] 的值改变；</p><p>第三行结果中，由于c进行了修改，c和a相同，那么a的值也进行了改变，只是说访问内存的方式不同罢了，其中几种访问都是一次内存增加int个字节大小；</p><p>第四次结果中，只改变了 c[1] 的值，因此和第三次比较只进行了 c[1] 的改变；</p><p>​第五次结果中，先是将 c[1] 通过 char 指针增长 1 个字节，访问 c[2] 的前 1 个字节，再将其转换成了 int 类型，因此目前 c 指向 int* a[1] 的后 3 个字节，同时起内存长度是 4 个字节，因此当前 c 指向的内存的末尾是 a[2] 的前 1 个字节的尾巴，再让 *c &#x3D; 500 的时候，a[1]、a[2] 的值都进行了改变；</p><p>​第六次结果中，我们可以通过地址的大小发现，刚好验证了第五次中结果为啥是这样。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-20-59.png" alt="pointer.c results"></p><h4 id="ELF-kernel-img"><a href="#ELF-kernel-img" class="headerlink" title="ELF kernel.img"></a>ELF kernel.img</h4><p>​单独列了一个标题为 ELF 的文件，主要是为了好好学习 ELF，这个部分有一些复杂的信息，需要进行记录和积累。<a href="./elf.pdf">点击可下载elf.pdf</a></p><p>​在 6.828 中，可以将 ELF 文件看作是一个带有固定的 header 的可执行代码文件，其中代码被分成了不同的段包含了 code、data 等等，这些地址是在文件中定义好了的而boot loader 不会定义这些地址，这些东西可以根据描述的地址加载进内存直接进行执行。</p><p>​一个 ELF 二进制文件中，包含一个指定长度的头部，候面跟了几个代码块，这些个代码块可以分为程序和数据，可以在 inc&#x2F;elf.h 中看到如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> JOS_INC_ELF_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JOS_INC_ELF_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU<span class="hljs-comment">/* &quot;\x7FELF&quot; in little endian */</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> &#123;</span><br><span class="hljs-type">uint32_t</span> e_magic;<span class="hljs-comment">// must equal ELF_MAGIC</span><br><span class="hljs-type">uint8_t</span> e_elf[<span class="hljs-number">12</span>];<br><span class="hljs-type">uint16_t</span> e_type;<br><span class="hljs-type">uint16_t</span> e_machine;<br><span class="hljs-type">uint32_t</span> e_version;<br><span class="hljs-type">uint32_t</span> e_entry;<br><span class="hljs-type">uint32_t</span> e_phoff;<br><span class="hljs-type">uint32_t</span> e_shoff;<br><span class="hljs-type">uint32_t</span> e_flags;<br><span class="hljs-type">uint16_t</span> e_ehsize;<br><span class="hljs-type">uint16_t</span> e_phentsize;<br><span class="hljs-type">uint16_t</span> e_phnum;<br><span class="hljs-type">uint16_t</span> e_shentsize;<br><span class="hljs-type">uint16_t</span> e_shnum;<br><span class="hljs-type">uint16_t</span> e_shstrndx;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> &#123;</span><br><span class="hljs-type">uint32_t</span> p_type;<br><span class="hljs-type">uint32_t</span> p_offset;<br><span class="hljs-type">uint32_t</span> p_va;<br><span class="hljs-type">uint32_t</span> p_pa;<br><span class="hljs-type">uint32_t</span> p_filesz;<br><span class="hljs-type">uint32_t</span> p_memsz;<br><span class="hljs-type">uint32_t</span> p_flags;<br><span class="hljs-type">uint32_t</span> p_align;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Secthdr</span> &#123;</span><br><span class="hljs-type">uint32_t</span> sh_name;<br><span class="hljs-type">uint32_t</span> sh_type;<br><span class="hljs-type">uint32_t</span> sh_flags;<br><span class="hljs-type">uint32_t</span> sh_addr;<br><span class="hljs-type">uint32_t</span> sh_offset;<br><span class="hljs-type">uint32_t</span> sh_size;<br><span class="hljs-type">uint32_t</span> sh_link;<br><span class="hljs-type">uint32_t</span> sh_info;<br><span class="hljs-type">uint32_t</span> sh_addralign;<br><span class="hljs-type">uint32_t</span> sh_entsize;<br>&#125;;<br><br><span class="hljs-comment">// Values for Proghdr::p_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr::p_flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ4</span><br><br><span class="hljs-comment">// Values for Secthdr::sh_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_NULL0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_PROGBITS1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_SYMTAB2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_STRTAB3</span><br><br><span class="hljs-comment">// Values for Secthdr::sh_name</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHN_UNDEF0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* !JOS_INC_ELF_H */</span></span><br></code></pre></td></tr></table></figure><p>​program section中我们关注以下几个部分：</p><ul><li><p>.text：程序可执行指令；</p></li><li><p>.rodata：只读数据；</p></li><li><p>.data：data section 包含了已经初始话的数据，比如全局变量 int x  &#x3D; 5；</p></li><li><p>.bss ： 存放未初始化的变量， 但是在ELF中只需要记录 .bss 的起始地址和长度。Loader and  program 必须自己将 .bss 段清零</p></li></ul><p>我们可以通过<code>objdump -h obj/kern/kernel</code>来查看所有的名字和地址范围：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-26-57.png" alt="kernel headers"></p><p>​在 JOS 中我们只关注上述的几个段，有一些我们需要特别关注的，比如 VMA（link address）、LMA（load addres），其中 LMA 就是程序运行的时候加载到内存中的位置，VMA 的话比较复杂，主要是用来添加或者执行一些共享的库之类的，在 JOS 中没有使用该段。</p><p>​我们同样可以通过<code>objdump -h obj/boot/boot.out</code>来查看 boot loader .text区域：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-25-21.png" alt="boot.out header"></p><p>​我们可以看到其 LMA 的地址和 VMA 的地址都是 0x7c00，这个和我们之前看到的 BIOS 启动跳转的地址相同。</p><p>​同理，我们可以通过 <code>objdump -x obj/kern/kernel</code> 来查看整个kernel的header信息等。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-28-30.png" alt="kernel header all"></p><p>​我们可以看到 LOAD 中的需要加载到内存中的区域，vaddr 是虚拟地址、paddr 是物理地址、加载区域大小 filesz&#x2F;memsz，在 boot&#x2F;main.c 中，ph-&gt;p_pa 每个程序头的字段都包含段的目标物理地址。BIOS 将引导扇区加载到内存中，从 0x7c00 开始，因此这是引导扇区的起始地址，由于这个地址也是引导扇区执行的地方，所以它也是链接地址，我们设置连接地址 <code>-Ttext 0x7c00</code> 到链接器 boot&#x2F;Makefrag，链接器将产生正确的代码地址。</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>​要求：先跟踪部分 boot loader 中的一小部分步骤，然后修改 boot&#x2F;Makefrag 中的链接地址，查看其行为。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#</span><br><span class="hljs-comment"># Makefile fragment for the JOS kernel.</span><br><span class="hljs-comment"># This is NOT a complete makefile;</span><br><span class="hljs-comment"># you must run GNU make in the top-level directory</span><br><span class="hljs-comment"># where the GNUmakefile is located.</span><br><span class="hljs-comment">#</span><br><br>OBJDIRS += boot<br><br>BOOT_OBJS := <span class="hljs-variable">$(OBJDIR)</span>/boot/boot.o <span class="hljs-variable">$(OBJDIR)</span>/boot/main.o<br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/%.o: boot/%.c<br>@echo + cc -Os <span class="hljs-variable">$&lt;</span><br>@mkdir -p $(@D)<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(CC)</span> -nostdinc <span class="hljs-variable">$(KERN_CFLAGS)</span> -Os -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/%.o: boot/%.S<br>@echo + as <span class="hljs-variable">$&lt;</span><br>@mkdir -p $(@D)<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(CC)</span> -nostdinc <span class="hljs-variable">$(KERN_CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/main.o: boot/main.c<br>@echo + cc -Os <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(CC)</span> -nostdinc <span class="hljs-variable">$(KERN_CFLAGS)</span> -Os -c -o <span class="hljs-variable">$(OBJDIR)</span>/boot/main.o boot/main.c<br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/boot: <span class="hljs-variable">$(BOOT_OBJS)</span><br>@echo + ld boot/boot<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o <span class="hljs-variable">$@</span>.out <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(OBJDUMP)</span> -S <span class="hljs-variable">$@</span>.out &gt;<span class="hljs-variable">$@</span>.asm<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(OBJCOPY)</span> -S -O binary -j .text <span class="hljs-variable">$@</span>.out <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(V)</span>perl boot/sign.pl <span class="hljs-variable">$(OBJDIR)</span>/boot/boot<br></code></pre></td></tr></table></figure><p>​我们可以看到，通过编译生成了 boot&#x2F; 文件夹下的内容，并且在最后根据地址进行链接，我们尝试修改 0x7c00 为错误的地址 0x7000，看会如何执行；</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-32-41.png" alt="0x7000 error"></p><p>​我们可以看到在这个情况下边儿，由于 boot loader 加载地址，无法正常启动，导致 BIOS 不断重启去寻找可以启动的盘，此时的 qemu 就陷入了死循环，当我们把地址改为正确的时候，则可以正常启动，不过得执行命令 make clean 再重新编译。</p><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>​要求：使用 GDB 中 x 命令来检测地址，其中 x&#x2F;Nx ADDR 命令打印从 ADDR 开始的 N 个字的地址。测试 0x00100000 地址开始的 8 个字的内存，然后再引导程序进入内核时再次检查，他们为什么不同？第二个断点有什么？</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-37-22.png" alt="x/Nx ADDR"></p><p>​我们知道在 ELF 头中保存了一个叫做 e_entry 的字段，该字段中保存了程序中入口点的地址，也就是 kernel 的入口地址，我们根据要求查看进入内核前后的该处地址情况，发现在运行内核过后，内存 0x0010000 中加载了内核的代码地址。</p><h2 id="Part-3：The-Kernel"><a href="#Part-3：The-Kernel" class="headerlink" title="Part 3：The Kernel"></a>Part 3：The Kernel</h2><p>​第三个部分我们开始研究内核，在将内核加载到内存中，并且根据 e_entry 字段进入内核代码过后，CPU 流水开始执行 kernel，JOS 运行了起来。</p><h3 id="虚拟内存解决位置依赖"><a href="#虚拟内存解决位置依赖" class="headerlink" title="虚拟内存解决位置依赖"></a>虚拟内存解决位置依赖</h3><p>​操作系统的内核通常被链接到非常高的虚拟地址如（0x00100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。</p><p>​许多机子在地址范围无法到达 0xf0100000，因此我们不能在该处存储内核，我们可以使用处理器提供的内存管理硬件将虚拟地址 0xf0100000（内核代码期望云运行的链接地址）映射到物理地址 0x00100000（引导加载程序将内核加载到物理内存中）。</p><p>​我们目前不需要掌握细节，我们只需要知道可以通过 kern&#x2F;entrypgdir.c 中静态初始化的页面目录和页表来完成此操作，映射前 4M 的物理内存就可以启动并运行起来。在内存映射的过程中有一个非常重要的寄存器，cr0 控制寄存器，当我们在 kern&#x2F;entry.S 中设置 CR0_PG 标志位过后，内存映射打开，这个时候的虚拟地址被映射成了物理地址。此处我们开启了页机制，我们将虚拟地址 0xf0000000 到 0xffffffff 映射到 0x000000000到 0x0ffffffff。</p><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>​要求：使用GDB调试跟踪内核并且停止在 <code>movl %eax, %cr0</code> 部分，并且检测内存0x00100000 和 0xf0100000，并且单步跟踪 GDB，查看内存前后内容的差别。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-41-51.png" alt="kernel.asm 指令地址"></p><p>​我们可以在 <code>obj/kern/kernel.asm</code> 反汇编得到的代码中看到，<code>movl %eax, %cr0</code> 的代码地址为 0xf0100020，因此我们在此处设置断点，并且观察前后cr0寄存器的行为和内容；出现一个小错误就是，这里的 0xf0100020 是虚拟地址，我们需要跟踪映射过后的实际的地址，而实际的映射规则正如前边儿提到的，因此我们设置的断点应该为 0x00100020；</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-45-13.png" alt="breakpoint"></p><p>​我们可以看到，在该命令执行之后，原本放在 0xf0100000 处的内容映射到了0x00100000 处，因为这两个地方的值完全一样。</p><p>​接下来我们将 <code>movl %eax, %cr0</code> 注释掉，查看会发生什么：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-46-49.png" alt="make qemu no %cr0"></p><p>​会发现，操作系统无法启动，这个时候由于没有开启页机制，kernel 的地址映射没有成功，从而超出了寻址范围，导致操作系统内核无法启动，修改回去可以成功启动。</p><h3 id="格式化输出到控制台"><a href="#格式化输出到控制台" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h3><p>​这个小节主要是为了说明，操作系统中是没有 printf() 这种函数的，我们需要去写一个可以输出到界面的比如 vga 的输出，并且封装来供使用，比如当前的 kernel 中就提供了三个和输出相关的文件 kern&#x2F;printf.c，lib&#x2F;printfmt.c 和 kern&#x2F;console.c，我们需要学习这三个咋搞起来的还有他们之间的关系。</p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>​要求：在printfmt.c中省略了打印八进制数的格式，%o的格式选项，需要我们进行补充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// (unsigned) octal</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br><span class="hljs-comment">// Replace this with your code.</span><br><span class="hljs-comment">//putch(&#x27;X&#x27;, putdat);</span><br><span class="hljs-comment">//putch(&#x27;X&#x27;, putdat);</span><br><span class="hljs-comment">//putch(&#x27;X&#x27;, putdat);</span><br><span class="hljs-comment">//</span><br>num = getint(&amp;ap,lflag);<br><span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)num &lt;<span class="hljs-number">0</span>)&#123;<br>putch(<span class="hljs-string">&#x27;-&#x27;</span>,putdat);<br>num = -(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) num;<br>&#125;<br><br>base = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">goto</span> number;<br><br></code></pre></td></tr></table></figure><p>​这个还行，只需要照着前边儿的 10 进制进行复制就好了，基本没有难度，补充完毕就ok，接下来是回答一堆问题：</p><ul><li>1、解释 printf.c 和 console.c 之间的接口，尤其是 console.c 导出了什么函数，printf.c 如何使用这些函数？</li></ul><p>printf.c 使用了 console.c 的 cputchar() 函数，通过直接调用该函数完成输出到vga 上；同时 printf.c 也使用 printfmt.c 中包装过的 console.c 中的函数，这样便于格式化的输出到屏幕上。</p><ul><li>2、解释console.c中的一段儿程序：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// What is the purpose of this?</span><br><span class="hljs-keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;<br><span class="hljs-type">int</span> i;<br><br>memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>));<br><span class="hljs-keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>crt_buf[i] = <span class="hljs-number">0x0700</span> | <span class="hljs-string">&#x27; &#x27;</span>;<br>crt_pos -= CRT_COLS;<br>&#125;<br></code></pre></td></tr></table></figure><p>​由于当前的输出是到 VGA 显示，这个地方是检测 ctr_pos 指针施否超出了 CTR 的范围，如果超出了，则需要对超出部分的显示缓存内容清零，并且对 ctr_pos 进行重新设置回到该位置。</p><ul><li>3、跟踪下边儿的一段儿代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span>, z = <span class="hljs-number">4</span>;<br>cprintf(<span class="hljs-string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);<br></code></pre></td></tr></table></figure><p>​cprintf()，fmt指向什么？ap又指向什么？</p><p>​这一段儿代码我们可以考虑插入到内核的任何位置，为了便于跟踪，我们可以考虑到加入的内核的初始化的地方 <code>kern/init.c</code>，因此我们加入过后进行跟踪：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">i386_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> edata[], end[];<br><br><span class="hljs-comment">// Before doing anything else, complete the ELF loading process.</span><br><span class="hljs-comment">// Clear the uninitialized global data (BSS) section of our program.</span><br><span class="hljs-comment">// This ensures that all static/global variables start out zero.</span><br><span class="hljs-built_in">memset</span>(edata, <span class="hljs-number">0</span>, end - edata);<br><br><span class="hljs-comment">// Initialize the console.</span><br><span class="hljs-comment">// Can&#x27;t call cprintf until after we do this!</span><br>cons_init();<br><br>cprintf(<span class="hljs-string">&quot;6828 decimal is %o octal!\n&quot;</span>, <span class="hljs-number">6828</span>);<br><br><span class="hljs-comment">// Lab 1 exercise 8</span><br>&#123;<br><span class="hljs-comment">// Trace the execution of the following code step-by-step</span><br><br>Lab1_exercise8_3:<br>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span>, z = <span class="hljs-number">4</span>;<br>cprintf(<span class="hljs-string">&quot;x %d, y %d, z %d\n&quot;</span>,x, y, z);<br>&#125;<br><br>Lab1_exercise8_4:<br>&#123;<br><span class="hljs-comment">// Run the following code</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br>cprintf(<span class="hljs-string">&quot;H%x Wo%s\n&quot;</span>,<span class="hljs-number">57616</span>, &amp;i);<br>&#125;<br>Lab1_exercise8_5:<br>&#123;<br><span class="hljs-comment">// y = ?</span><br>cprintf(<span class="hljs-string">&quot;x=%d y=%d\n&quot;</span>,<span class="hljs-number">3</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Test the stack backtrace function (lab 1 only)</span><br>test_backtrace(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// Drop into the kernel monitor.</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>monitor(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​我们在<code>obj/kern.kernel.asm</code> 中找到添加的代码的位置，打上断点进行跟踪，具体方法和前边儿的调试方法相同，于是得到以下结果：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-59-53.png" alt="init"></p><p>​单步运行，跟踪每个 call 中 cons_putc,va_arg 和 vcprintf，对于 cons_putc 列出参数，对于 va_arg，列出 ap 在调用前后分别指向什么，对于 vcprintf 列出参数和值</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-00-29.png" alt="printfmt.c"></p><p>​其他的也类似挨着跟踪一下就好了，可以看到调用链和每次传入的值。对于其中的可变参数的实现，我们可以在 inc&#x2F;stdarg.h 中找到，为什么可以实现可变参数主要原因是因为函数的参数压栈是从左到右依次进栈的，然后根据这个规则进行取就好了。</p><ul><li>4、运行下边儿的代码，查看结果是什么：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br>   cprintf(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br></code></pre></td></tr></table></figure><p>​结果是：hell0，World，这个地方的输出跟ASCII码有关，凑成了 hell0 world</p><ul><li>5、下边儿的代码，y后边儿会输出什么？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>​y 后边儿跟了一个未知的数</p><ul><li>6、GCC改变调用的时候参数压栈顺序，如何修改 cprintf() 函数可以让他输出可变个数的参数？</li></ul><p>如果是从右往左进行压栈，我们可以考虑传进去一个参数个数的值，然后我们获取参数的从末尾开始拿就好了</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>​我们最后来研究一下 X86 上的 C 语言栈，我们会实现一个 backtrace 的函数，来对栈内的参数和 IP 信息等进行打印出来。</p><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><p>​要求：判断内核在哪个地方初始化的栈，并且判断栈在内存中的位置，内核是如何为栈保存空间的？并且在这个保留区域的 “end” 是堆栈指针最初指向的位置嘛？</p><p>栈的初始化，最先是在 boot loader 中，然后在进入内核过后，内核也对栈进行了重新初始化。​entry.S 中初始化的，然后初始化的时候我去调用 kernel.asm 文件，然后观察栈的大小啥的：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-05-44.png" alt="entry.S"></p><p>在 memlayout.h 和 mmu.h 中可以找到内核栈的相关情况，理论上只要是空闲的物理地址都可以作为栈，JOS 对栈的定义在 memlayout.h 中：</p><ul><li>内核在 entry.S 中进行栈的重新初始化</li><li>栈在内存中的位置，KSTACKTOP：KERNBASE（0xF0000000）</li><li>内核为栈预留 KSTKIZE（8*PGSIZE，PGSIZE&#x3D;4096） 的空间</li></ul><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><p>​要求：为了熟悉 X86 中 C 调用约定，test_backtrace 在 obj&#x2F;kern&#x2F;kernel.asm 中找到函数地址，在那里设置一个断点，然后检查内核启动后每次调用它会发生什么。每个递归嵌套级别的 test_backtrace 推入堆栈的32位字是多少，这些字是什么？</p><p>首先，我们再次熟悉x86栈的约定是长什么样：</p><p><img src="https://imgs.bencorn.com/imgs/2021/08/12/+08000812150935.png" alt="x86 堆栈结构"></p><p>​每个栈帧中保存了上述的信息，其中，<code>%esp</code> 寄存器始终指向栈顶，并且每一次入栈的时候，<code>%esp</code> 的减少，在 32-bit 模式下，堆栈只能保存 32-bit 的值，并且 <code>%esp</code> 总是可以被 4 整除。</p><p>​<code>%ebp</code> 寄存器，基址寄存器，每一次函数调用压栈的时候，将 <code>%esp</code> 的值保存到 <code>%ebp</code>中，每一次都这样按照这个约定，这样的话每次取 <code>%ebp</code> 的上一次的值就可以拿到栈的调用链。</p><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><p>​于是基于上述 exercise 10 中堆栈的描述约定的方式，我们可以进行栈的跟踪打印，实现方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Your code here.</span><br><span class="hljs-comment">// Lab 1 exercise 9</span><br><br><span class="hljs-type">uint32_t</span> ebp,*p,eip; <br>ebp = read_ebp();<br><br>cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br><span class="hljs-keyword">while</span>(ebp != <span class="hljs-number">0</span>)&#123;<br>p = (<span class="hljs-type">uint32_t</span>*) ebp;<br>eip = p[<span class="hljs-number">1</span>];<br>cprintf(<span class="hljs-string">&quot;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, ebp, eip, p[<span class="hljs-number">2</span>], p[<span class="hljs-number">3</span>], p[<span class="hljs-number">4</span>], p[<span class="hljs-number">5</span>], p[<span class="hljs-number">6</span>]);<br>ebp = p[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​然后将其添加到内核的 cmd 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Command</span> <span class="hljs-title">commands</span>[] =</span> &#123;<br>&#123; <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,<br>&#123; <span class="hljs-string">&quot;kerninfo&quot;</span>, <span class="hljs-string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,<br>&#123; <span class="hljs-string">&quot;backtrace&quot;</span>,<span class="hljs-string">&quot;Display the stack backtrace info&quot;</span>,mon_backtrace&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>​此时，我们就可以在内核启动的时候，调用 <code>backtrace</code> 完成堆栈跟踪展示信息了就。</p><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><p>​要求：打印 debug info 出来，利用 eip，在 kern&#x2F;kdebug.c 中完成检测；并且完成 stab_binsearch 取寻找一个地址的行号编号，然后添加 debuginfo_eip 到mon_backtrace 中，然后查看施否能够打印出来；</p><p>​先手动完成命令行的查看，然后编写二分搜索，阅读给出的 stab_binsearch 函数，按照二分的模板写吧和算法相同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Search within [lline, rline] for the line number stab.</span><br>      <span class="hljs-comment">// If found, set info-&gt;eip_line to the right line number.</span><br>      <span class="hljs-comment">// If not found, return -1.</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// Hint:</span><br>      <span class="hljs-comment">//      There&#x27;s a particular stabs type used for line numbers.</span><br>      <span class="hljs-comment">//      Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span><br>      <span class="hljs-comment">//      which one.</span><br>      <span class="hljs-comment">// Your code here.</span><br><br>      stab_binsearch(stabs,&amp;lline,&amp;rline,N_SLINE,addr);<br>      <span class="hljs-keyword">if</span>(lline &lt;= rline)&#123;<br>              info-&gt;eip_line = stabs[lline].n_desc;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>              cprintf(<span class="hljs-string">&quot;line not find\n&quot;</span>);<br>              <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>​然后就是在 mon_backtrace 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Your code here.</span><br><span class="hljs-comment">// Lab 1 exercise 9</span><br><br><span class="hljs-type">uint32_t</span> ebp,*p,eip; <br>ebp = read_ebp();<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Eipdebuginfo</span> <span class="hljs-title">info</span>;</span><br><br>cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br><span class="hljs-keyword">while</span>(ebp != <span class="hljs-number">0</span>)&#123;<br><br>p = (<span class="hljs-type">uint32_t</span>*) ebp;<br>eip = p[<span class="hljs-number">1</span>];<br>cprintf(<span class="hljs-string">&quot;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, ebp, eip, p[<span class="hljs-number">2</span>], p[<span class="hljs-number">3</span>], p[<span class="hljs-number">4</span>], p[<span class="hljs-number">5</span>], p[<span class="hljs-number">6</span>]);<br><br><span class="hljs-type">int</span> c = debuginfo_eip(eip,&amp;info);<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> fn_offset = eip - info.eip_fn_addr;<br>cprintf(<span class="hljs-string">&quot;%s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, fn_offset);<br>&#125;<br><br>ebp = p[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​然后尝试 make grade 一下，完结撒花完成整个实验：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-34-46.png" alt="tests OK"></p><p>​至此 Lab1 完结撒花。</p><p>补充一个点儿，有可能在 grade 的时候会失败，具体原因是由于 qemu 的执行结果重定向到 jos.out 文件过后，可能会有换行问题，导致 Python 的grade 脚本匹配失败，如：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-32-35.png" alt="grade fail"></p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-34-24.png" alt="缺少回车"></p><p>解决方法就是在 6828 前边儿加个回车符号，满足脚本儿要求。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab syscall System calls</title>
    <link href="/2021/03/30/Lab-syscall-System-calls/"/>
    <url>/2021/03/30/Lab-syscall-System-calls/</url>
    
    <content type="html"><![CDATA[<h3 id="Lab-2-System-Call"><a href="#Lab-2-System-Call" class="headerlink" title="Lab 2 System Call"></a>Lab 2 System Call</h3><p>​lab2 总算是跌跌撞撞做完了，其实思路不难，但就是会发生一些意想不到的错误，就包括了 PPT 中提到的指针问题，把我卡了一天f**k；然后内存那个地方误打误撞还做出来了，思路找wyy提示了一下，总而言之还是对页表部分理解不够深刻吧可能</p><p>​学习网站：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a></p><h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>​要求实现一个调用跟踪的 trace，其中有一个地方我一开始没理解到 mask 是干嘛的（原文： You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. ），卡了2天（英语不够，google来凑）；</p><h5 id="1、修改-Makefile"><a href="#1、修改-Makefile" class="headerlink" title="1、修改 Makefile"></a>1、修改 Makefile</h5><p>​add $U&#x2F;_trace\</p><h5 id="2、添加-syscall"><a href="#2、添加-syscall" class="headerlink" title="2、添加 syscall"></a>2、添加 syscall</h5><p>​add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. </p><h5 id="3、添加-sys-trace-函数-kernel-x2F-sysproc-c"><a href="#3、添加-sys-trace-函数-kernel-x2F-sysproc-c" class="headerlink" title="3、添加 sys_trace()函数 kernel&#x2F;sysproc.c"></a>3、添加 sys_trace()函数 kernel&#x2F;sysproc.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab2 trace</span><br>uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>,&amp;n)&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    p-&gt;mask = n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、修改-fork-函数-kernel-x2F-proc-c"><a href="#4、修改-fork-函数-kernel-x2F-proc-c" class="headerlink" title="4、修改 fork 函数 kernel&#x2F;proc.c"></a>4、修改 fork 函数 kernel&#x2F;proc.c</h5><p>​以防万一，修改的时候mask还是上锁了，mask 其实是每个 process 的 private 信息应该，但是上锁无伤大雅感觉，就放到了release前边儿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  <span class="hljs-comment">// lab2 get the trace mask from parent</span><br>  np-&gt;mask = p-&gt;mask;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、添加trace输出"><a href="#5、添加trace输出" class="headerlink" title="5、添加trace输出"></a>5、添加trace输出</h5><p>​提前准备好映射的名字，因为输出的时候需要（You will need to add an array of syscall names to index into.），然后积极犯错，忘记如何定义二维数组的信息了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *syscall_names[] = &#123;<br>        [SYS_fork]    <span class="hljs-string">&quot;fork&quot;</span>,<br>        [SYS_exit]    <span class="hljs-string">&quot;exit&quot;</span>,<br>        [SYS_wait]    <span class="hljs-string">&quot;wait&quot;</span>,<br>        [SYS_pipe]    <span class="hljs-string">&quot;pipe&quot;</span>,<br>        [SYS_read]    <span class="hljs-string">&quot;read&quot;</span>,<br>        [SYS_kill]    <span class="hljs-string">&quot;kill&quot;</span>,<br>        [SYS_exec]    <span class="hljs-string">&quot;exec&quot;</span>,<br>        [SYS_fstat]   <span class="hljs-string">&quot;fstat&quot;</span>,<br>        [SYS_chdir]   <span class="hljs-string">&quot;chdir&quot;</span>,<br>        [SYS_dup]     <span class="hljs-string">&quot;dup&quot;</span>,<br>        [SYS_getpid]  <span class="hljs-string">&quot;getpid&quot;</span>,<br>        [SYS_sbrk]    <span class="hljs-string">&quot;sbrk&quot;</span>,<br>        [SYS_sleep]   <span class="hljs-string">&quot;sleep&quot;</span>,<br>        [SYS_uptime]  <span class="hljs-string">&quot;uptime&quot;</span>,<br>        [SYS_open]    <span class="hljs-string">&quot;open&quot;</span>,<br>        [SYS_write]   <span class="hljs-string">&quot;write&quot;</span>,<br>        [SYS_mknod]   <span class="hljs-string">&quot;mknod&quot;</span>,<br>        [SYS_unlink]  <span class="hljs-string">&quot;unlink&quot;</span>,<br>        [SYS_link]    <span class="hljs-string">&quot;link&quot;</span>,<br>        [SYS_mkdir]   <span class="hljs-string">&quot;mkdir&quot;</span>,<br>        [SYS_close]   <span class="hljs-string">&quot;close&quot;</span>,<br>        [SYS_trace]   <span class="hljs-string">&quot;trace&quot;</span>,<br>        [SYS_sysinfo] <span class="hljs-string">&quot;sysinfo&quot;</span>,<br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>    <span class="hljs-comment">// num syscall numbers store in the register a7</span><br>    num = p-&gt;trapframe-&gt;a7;<br>    <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>        p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>               p-&gt;pid, p-&gt;name, num);<br>        p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// trace the syscall</span><br>    <span class="hljs-keyword">if</span> (((<span class="hljs-number">1</span> &lt;&lt; num) &amp; p-&gt;mask) &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);<br>&#125;<br></code></pre></td></tr></table></figure><p>​到这里 trace 就完成了，解决之前的疑惑，mask 和 num 两个的关系，在开头的英语中说的是，如果返回的 mask 和调用 num 在mask 中，也就是那个mask &#x3D; 1 &lt;&lt; num ，ok搞定</p><h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>​这个实验着实让人伤脑筋一开始，主要是没认真 xv6 这书，书上说了 defs.h 中定义了各个模块的接口，然而一开始没看见，所以老是不知道怎么把要加的两个函数加入到新函数中，老是出现未定义的错误提示</p><h5 id="1、添加基本的调用信息"><a href="#1、添加基本的调用信息" class="headerlink" title="1、添加基本的调用信息"></a>1、添加基本的调用信息</h5><p>​和 trace 中的步骤一样，每个地方都要填</p><h5 id="2、kernel-x2F-kalloc-c"><a href="#2、kernel-x2F-kalloc-c" class="headerlink" title="2、kernel&#x2F;kalloc.c"></a>2、kernel&#x2F;kalloc.c</h5><p>​遍历 freelist ，把所有的 page 求和就好了，这里我一开始很meng不知道怎么办，后来问了问wyy逻辑关系，一下子就明朗了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab2</span><br>uint64<br><span class="hljs-title function_">collect_free_memory</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">r</span>;</span><br>    acquire(&amp;kmem.lock);<br>    r = kmem.freelist;<br>    <span class="hljs-keyword">while</span> (r) &#123;<br>        res += PGSIZE;<br>        r = r-&gt;next;<br>    &#125;<br>    release(&amp;kmem.lock);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、kernel-x2F-proc-c"><a href="#3、kernel-x2F-proc-c" class="headerlink" title="3、kernel&#x2F;proc.c"></a>3、kernel&#x2F;proc.c</h5><p>​这里的 p-&gt;state 在 proc.h 中有要求上锁，所以要小心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lab2</span><br>uint64<br><span class="hljs-title function_">collect_process_number</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    uint64 n = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span> (p = proc;p  &lt; &amp;proc[NPROC];p++) &#123;<br>        acquire(&amp;p-&gt;lock);<br>        <span class="hljs-keyword">if</span> (p-&gt;state != UNUSED)&#123;<br>            n += <span class="hljs-number">1</span>;<br>        &#125;<br>        release(&amp;p-&gt;lock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、kernel-x2F-sysproc-c"><a href="#4、kernel-x2F-sysproc-c" class="headerlink" title="4、kernel&#x2F;sysproc.c"></a>4、kernel&#x2F;sysproc.c</h5><p>​这里一开始我犯的错误，是开了一个 sysinfo 的指针，然后将 info-&gt;freemem &#x3D; collect_free_memory()，然后返回的地址是一个未知的地址，指针指向的是一个 uint64 的地址，根本不是值，f**k一天过去了原来如此，太菜了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab2 sys_info</span><br>uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><br>    uint64 addr;<br><span class="hljs-comment">//   wrong answer</span><br><span class="hljs-comment">//   struct sysinfo* info;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>,&amp;addr)&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>    info.freemem= collect_free_memory();<br>    info.nproc = collect_process_number();<br><br>    <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable,addr,(<span class="hljs-type">char</span>*)&amp;info,<span class="hljs-keyword">sizeof</span>(info))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​到此就两个实验结束了，赶紧学习下一个鸭得，不然得失业了要，下一个实验很有意思，是关于页表的。</p>]]></content>
    
    
    <categories>
      
      <category>6.s081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab util Unix utilities</title>
    <link href="/2021/03/21/Lab-util-Unix-utilities/"/>
    <url>/2021/03/21/Lab-util-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p>​ucore写了以后算是对操作系统有一个初步的认识，ucore 既然也是参照 xv6 来的，那何尝不尝试一下这个呢，而且这个课程可以对标更多的其他课程，坑也会少很多的样子，抓紧时间学习吧；</p><p>​先说一下整体的步骤：</p><p><code>因为有了 OS 基础、而不是第一次学习 OS，所以就比较快了可能，但是会发现让自己去独立的写一个.c文件而不是像ucore那样去填空还是有点儿吃力的</code></p><p>​1、看xv6电子书要求章节，看PPT，看说明</p><p>​2、看每个实验要求要看的源码</p><p>​3、写lab、debug</p><p>​4、不会的地方先查资料，再不会看学长代码提供的思路，最终独立敲一遍</p><p>​课程网页：<a href="https://pdos.csail.mit.edu/6.828/2020/index.html">https://pdos.csail.mit.edu/6.828/2020/index.html</a></p><h3 id="Lab-Util"><a href="#Lab-Util" class="headerlink" title="Lab Util"></a>Lab Util</h3><p>​正式开始之前，得搭建好实验环境，选择国内镜像站最好选择 ustc 的，貌似其他的几个镜像站 Ubuntu 20.04 有的安装包没进行缓存或者丢弃了（eg. qemu的部分组建）</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>​这个部分要求写一个用户态程序，然后理解用户态是如何通过 system call 调用内核代码的；记录踩坑经历，include 部分的每个顺序是有要求的，去查看三个头文件会发现会有依赖关系，如果顺序错了会造成编译失败，至于为啥请查询 C 语法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// order is important</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span><br>&#123;<br><span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Sleep Error: Argument is Needed...\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> n = atoi(argv[<span class="hljs-number">1</span>]);<br>sleep(n);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>​通过管道实现两个进程之间的通讯，子进程向父进程写一个字节，父进程也向子进程写一个字节，分别起两个管道就好了；我是直接输出字符串，没进行检测，想的是如果出错的化 read 会阻塞啥的，逻辑正确就没管了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// order is important</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>pipe(p1);<br>pipe(p2);<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// fd[0] read end,fd[1] write end</span><br><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>write(p2[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">1</span>);<br>close(p2[<span class="hljs-number">0</span>]);<br><br>read(p1[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br>close(p1[<span class="hljs-number">1</span>]);<br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>write(p1[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-number">1</span>);<br>close(p1[<span class="hljs-number">0</span>]);<br>wait(<span class="hljs-number">0</span>);<br><br>read(p2[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br>close(p2[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h4><p>​通过管道，实现一个流水线，也就是CSP模型的管道解（<a href="http://swtch.com/~rsc/thread/%EF%BC%89%EF%BC%8C%E5%8D%A1%E4%BA%86%E5%BE%88%E4%B9%85%E5%BE%88%E4%B9%85%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E4%BC%9A%E5%86%99%E2%80%9C%E5%85%B1%E4%BA%AB%E2%80%9D%EF%BC%88%E8%BF%99%E9%87%8C%E7%9A%84%E5%85%B1%E4%BA%AB%E6%84%8F%E6%80%9D%E6%98%AF%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%E7%9B%B8%E5%90%8C%E4%BB%A3%E7%A0%81%EF%BC%89%E9%83%A8%E5%88%86%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AA%E4%BC%9A%E5%86%99%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%95%BF%E5%BA%A6%E4%B8%BA">http://swtch.com/~rsc/thread/），卡了很久很久，因为不会写“共享”（这里的共享意思是每个进程都会执行的相同代码）部分的代码，只会写流水线长度为</a> 2 的情况，想了很久想到用 goto 可以，而且书上给了一个 dup 的例子来进行文件描述符的控制，这样就避免了题干中提到的坑了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// order is important</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">redict</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[])</span> &#123;<br>    close(<span class="hljs-number">0</span>);<br>    close(fd[<span class="hljs-number">1</span>]);<br>    dup(fd[<span class="hljs-number">0</span>]);<br>    close(fd[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    pipe(fd);<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>        redict(fd);<br><br>        <span class="hljs-type">int</span> buf, n, x, fd1[<span class="hljs-number">2</span>];<br>        lable:<br>        <span class="hljs-keyword">if</span> ((n = read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &lt;= <span class="hljs-number">0</span> || buf &lt;= <span class="hljs-number">0</span>)) &#123;<br>            close(<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, buf);<br>        x = buf;<br><br>        pipe(fd1);<br><br>        <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>            redict(fd1);<br>            <span class="hljs-keyword">goto</span> lable;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (buf % x != <span class="hljs-number">0</span>) &#123;<br>                write(fd1[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125;<br>        close(<span class="hljs-number">0</span>);<br>        close(fd1[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>            write(fd[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;<br>        close(fd[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>​find这个主要是引入了几个结构体和函数，需要仔细的阅读 ls.c 文件来弄懂每个函数是干什么的，然后才可以进行代码否则的话就会一直卡着；其实递归还好拉，就检测当前文件夹下边儿读到的一个stat结构体类型，如果是文件就判断名字是否相同，如果是文件夹就递归下去就好了（.和..的情况不进行递归），微光招新题也有一道类似的，实现copy函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *filepath, <span class="hljs-type">char</span> *filename)</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(filepath, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, filepath);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, filepath);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.type != T_DIR) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot find file %s in filepath %s\n&quot;</span>, filename, filepath);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(filepath) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(buf, filepath);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;<br>        <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (st.type) &#123;<br>            <span class="hljs-keyword">case</span> T_FILE:<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(p, filename) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> T_DIR:<br>                find(buf, filename);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><span class="hljs-comment">//        close(fd);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find error: need at least two arguments &#x27;filepath&#x27; and &#x27;filename&#x27;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>​这道题我一开始没理解到题目意思，我以为要写一个和 unix 一模一样的出来，一下子给我整懵了，当时也不是不可以写，但是仔细读题干发现要求完全不同好吧，xargs  后边儿执行的内容除了 exe_args  的以外，其他的是从标准输入进行输入的，那这样就好写很多阿，保存好 xargs 后边儿执行的命令，默认每次执行一次，只需要吧前边儿的内容嵌近来就 ok</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs error: need at least 2 arguments\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/// To get the xargs command args</span><br>    <span class="hljs-comment">/// We need not to make the optimizations for xargs -n 1 echo line the fot the choice -n 1</span><br>    <span class="hljs-comment">/// its always -n 1 for this lab</span><br>    <span class="hljs-type">char</span> *exec_args[MAXARG];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) &#123;<br>        exec_args[cnt] = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br>        memmove(exec_args[cnt], argv[i], <span class="hljs-built_in">strlen</span>(argv[i]));<br>        cnt++;<br>    &#125;<br><br>    exec_args[cnt] = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> len = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-built_in">memset</span>(exec_args[cnt], <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>            memmove(exec_args[cnt], buf + start, i - start);<br>            exec_args[cnt + <span class="hljs-number">1</span>] = (<span class="hljs-type">char</span> *) <span class="hljs-number">0</span>;<br>            start = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>                exec(*exec_args, exec_args);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><p>​写一个time.txt的文件，里边儿写好完成实验花的时间，那每天2小时，一周完成14h吧差不多，太菜了我还是，呜呜呜～～</p><p>​make grade 总算完成了，还是最简单的实验了应该是，下周lab1哇</p>]]></content>
    
    
    <categories>
      
      <category>6.s081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BlogByHexo</title>
    <link href="/2020/11/09/BlogByHexo/"/>
    <url>/2020/11/09/BlogByHexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-折腾日记"><a href="#Hexo-折腾日记" class="headerlink" title="Hexo  折腾日记"></a>Hexo  折腾日记</h1><p>​网上有很多的教程，这里记录一下我的折腾，然后达到自己想要的效果都做了什么</p><ul><li>环境 Ubuntu 20.04，Git</li><li>参考链接：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li></ul><h1 id="安装-nodejs、npm、git"><a href="#安装-nodejs、npm、git" class="headerlink" title="安装 nodejs、npm、git"></a>安装 nodejs、npm、git</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nodejs<br>sudo apt install npm<br>sudo apt install git<br></code></pre></td></tr></table></figure><h1 id="起一个名为-blog-的文件夹，在该文件夹里边儿起-Hexo"><a href="#起一个名为-blog-的文件夹，在该文件夹里边儿起-Hexo" class="headerlink" title="起一个名为 blog 的文件夹，在该文件夹里边儿起 Hexo"></a>起一个名为 blog 的文件夹，在该文件夹里边儿起 Hexo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<br><span class="hljs-built_in">cd</span> blog<br>sudo npm install -g hexo-cli<br>hexo init<br>npm install <span class="hljs-comment"># 安装必要的plugin</span><br></code></pre></td></tr></table></figure><h1 id="config-yml-配置，下面是我修改了的部分"><a href="#config-yml-配置，下面是我修改了的部分" class="headerlink" title="_config.yml 配置，下面是我修改了的部分"></a>_config.yml 配置，下面是我修改了的部分</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Bencorn</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">shuisong</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://blog.bencorn.com</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br>  <br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">12</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">Chic</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">https://github.com/shatanyumi/shatanyumi.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h1 id="安装-Hexo-git-插件，添加远程-github-仓库"><a href="#安装-Hexo-git-插件，添加远程-github-仓库" class="headerlink" title="安装 Hexo git 插件，添加远程 github 仓库"></a>安装 Hexo git 插件，添加远程 github 仓库</h1><ul><li>参考：<a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></li><li>仓库命名：‘你的github名’ .github.io</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br>git config --global user.name shatanyumi<br>git config --global user.email 1143005768@qq.com<br>ssh-keygen -t rsa -C 1143005768@qq.com<br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br><span class="hljs-comment"># 复制该内容到github的persoal access token</span><br>ssh git@github.com<br><span class="hljs-comment"># 出现下图表示配置好了</span><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2021/08/03/+08000803191648.png" alt="git 图片"></p><h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1><p>​在不修改任何 _config.yml 的情况下，执行目录为 blog&#x2F;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo s<br><span class="hljs-comment"># ctrl + 鼠标点击 （或者输入localhost:4000）</span><br></code></pre></td></tr></table></figure><p>​在不修改 theme 的情况下，其他的如上修改 github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">heoxo c<br>hexo g<br>hexo d<br><span class="hljs-comment"># 访问 shatanyumi.github.io(自己的修改一下即可)</span><br></code></pre></td></tr></table></figure><h1 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h1><ul><li><p>如果有计网知识的，请参考：<a href="https://juejin.im/post/6844903634161909767#heading-33">https://juejin.im/post/6844903634161909767#heading-33</a></p></li><li><p>注意必须在 source 下，添加 CNAME 文件，里边儿放网站的域名</p></li><li><p>然后，在 github 的该仓库下 domina 添加域名</p></li></ul><h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><ul><li><p>操作位置：blog&#x2F;themes&#x2F;</p></li><li><p>个人使用的是 Chic 主题：<a href="https://github.com/Siricee/hexo-theme-Chic">https://github.com/Siricee/hexo-theme-Chic</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> themes<br>git <span class="hljs-built_in">clone</span> https://github.com/Siricee/hexo-theme-Chic.git Chic<br><span class="hljs-comment"># 修改如前边儿说的.yml文件 theme: Chic</span><br></code></pre></td></tr></table></figure><ul><li>然后照着人家给出来的 DIY 文档，修改自己喜欢的就好了</li></ul><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><ul><li>因为hexo是靠yml来组织的，使用之前得好好看一下官方文档，然后在写</li><li>注意：操作目录 blog&#x2F;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page tag<br>hexo new page about<br>hexo new page categories<br></code></pre></td></tr></table></figure><ul><li>编辑 tag、categories、about，下边儿给出 tag 的 front-matter ，添加 layout：tag，about不用添加</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">title:</span> <span class="hljs-string">tag</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">tag</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-11-09 00:09:51</span><br><span class="hljs-string">______________________________________________________________________________________________________________________________</span><br></code></pre></td></tr></table></figure><p>然后写文章的时候，front-matter注意添加就好了</p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
