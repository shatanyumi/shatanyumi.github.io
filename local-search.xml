<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HW4-lazy-page-allocation</title>
    <link href="/2023/07/22/HW4-lazy-page-allocation/"/>
    <url>/2023/07/22/HW4-lazy-page-allocation/</url>
    
    <content type="html"><![CDATA[<p>操作系统可以使用页表硬件的许多巧妙技巧之一是堆内存的延迟分配。xv6 应用程序使用 sbrk() 系统调用向内核请求堆内存。在我们提供给的内核中，sbrk() 分配物理内存并将其映射到进程的虚拟地址空间。有些程序分配内存但从不使用它，例如实现大型稀疏数组。复杂的内核会延迟每个内存页面的分配，直到应用程序尝试使用该页面（如缺页错误）。在本练习中，将此延迟分配功能添加到 xv6。</p><p>作业链接：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html</a></p><h1 id="Part-One-Eliminate-allocation-from-sbrk"><a href="#Part-One-Eliminate-allocation-from-sbrk" class="headerlink" title="Part One: Eliminate allocation from sbrk()"></a>Part One: Eliminate allocation from sbrk()</h1><p>从 sbrk(n) 系统调用中，删除页分配。系统调用 sbrk(n) 增加进程空间 n bytes，然后返回新分配的区域的起始地址。</p><p>修改代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  myproc()-&gt;sz += n;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW4-lazy-page-allocation-2023-07-22-21-42-15.png" alt="结果"></p><h1 id="Part-Two-Lazy-allocation"><a href="#Part-Two-Lazy-allocation" class="headerlink" title="Part Two: Lazy allocation"></a>Part Two: Lazy allocation</h1><p>在 trap.c 中，添加对页错误的处理。</p><p>在 trap() 函数中，命名 char *mem，然后映射分配的物理页；如果映射之后还出现缺页错误，则会反复触发 T_PGFLT，然后反复分配一个页面来映射。</p><p>同时，将 mappages 的 static 删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> T_PGFLT:<br>   mem = kalloc();<br>   <span class="hljs-keyword">if</span>(mem != <span class="hljs-number">0</span>)&#123;<br>       uint va = PGROUNDDOWN(rcr2());<br>       <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span> ,PGSIZE);<br>       <span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, uint size, uint pa, <span class="hljs-type">int</span> perm)</span>;<br>       <span class="hljs-keyword">if</span>(mappages(myproc()-&gt;pgdir, (<span class="hljs-type">void</span>*)va, PGSIZE, V2P(mem),  PTE_W|PTE_U)&gt;=<span class="hljs-number">0</span>)&#123;<br>         <span class="hljs-keyword">break</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW4-lazy-page-allocation-2023-07-22-22-16-11.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW3-system-calls</title>
    <link href="/2023/07/20/HW3-system-calls/"/>
    <url>/2023/07/20/HW3-system-calls/</url>
    
    <content type="html"><![CDATA[<p>为 xv6 添加一个系统调用。</p><h1 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h1><p>第一个任务是修改 xv6 内核，为每个系统调用打印出一行。打印系统调用的名称和返回值就足够，不需要打印系统调用参数。</p><p>完成过后，会看到类似于以下的输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">fork -&gt; 2<br>exec -&gt; 0<br>open -&gt; 3<br>close -&gt; 0<br>$write -&gt; 1<br> write -&gt; 1<br></code></pre></td></tr></table></figure><p>提示：修改 syscall.c 文件中的 syscall() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">char</span> *syscalls_name[] = &#123;<br>[SYS_fork]    <span class="hljs-string">&quot;fork&quot;</span>,<br>[SYS_exit]    <span class="hljs-string">&quot;exit&quot;</span>,<br>[SYS_wait]    <span class="hljs-string">&quot;wait&quot;</span>,<br>[SYS_pipe]    <span class="hljs-string">&quot;pipe&quot;</span>,<br>[SYS_read]    <span class="hljs-string">&quot;read&quot;</span>,<br>[SYS_kill]    <span class="hljs-string">&quot;kill&quot;</span>,<br>[SYS_exec]    <span class="hljs-string">&quot;exec&quot;</span>,<br>[SYS_fstat]   <span class="hljs-string">&quot;fstat&quot;</span>,<br>[SYS_chdir]   <span class="hljs-string">&quot;chdir&quot;</span>,<br>[SYS_dup]     <span class="hljs-string">&quot;dup&quot;</span>,<br>[SYS_getpid]  <span class="hljs-string">&quot;getpid&quot;</span>,<br>[SYS_sbrk]    <span class="hljs-string">&quot;sbrk&quot;</span>,<br>[SYS_sleep]   <span class="hljs-string">&quot;sleep&quot;</span>,<br>[SYS_uptime]  <span class="hljs-string">&quot;uptime&quot;</span>,<br>[SYS_open]    <span class="hljs-string">&quot;open&quot;</span>,<br>[SYS_write]   <span class="hljs-string">&quot;write&quot;</span>,<br>[SYS_mknod]   <span class="hljs-string">&quot;mknod&quot;</span>,<br>[SYS_unlink]  <span class="hljs-string">&quot;unlink&quot;</span>,<br>[SYS_link]    <span class="hljs-string">&quot;link&quot;</span>,<br>[SYS_mkdir]   <span class="hljs-string">&quot;mkdir&quot;</span>,<br>[SYS_close]   <span class="hljs-string">&quot;close&quot;</span>,<br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  num = curproc-&gt;tf-&gt;eax;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    curproc-&gt;tf-&gt;eax = syscalls[num]();<br>    <span class="hljs-comment">// solution</span><br>    cprintf(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, syscalls_name[num], curproc-&gt;tf-&gt;eax);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            curproc-&gt;pid, curproc-&gt;name, num);<br>    curproc-&gt;tf-&gt;eax = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW3-system-calls-2023-07-20-08-09-16.png" alt="result"></p><h1 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h1><p>添加一个系统调用，这个系统调用可以获取当前的 UTC 时间，并且返回给用户程序。cmostime() 等接口 在 lapic.c 文件中定义好了。</p><p><img src="https://imgs.bencorn.com/imgs/HW3-system-calls-2023-07-20-09-06-13.png" alt="查看 uptime 系统调用"></p><p>参照 uptime 系统调用，然后挨着在每个地方添加相应的内容。</p><ul><li>syscall.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br>...<br>[SYS_date]    sys_date,<br>...<br>[SYS_date]    <span class="hljs-string">&quot;date&quot;</span>,<br></code></pre></td></tr></table></figure><ul><li>syscall.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_date   22</span><br></code></pre></td></tr></table></figure><ul><li>sysproc.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <br><span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(argptr(<span class="hljs-number">0</span>,r,<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> rtcdate)) &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  cmostime(r);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>user.h</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">date</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rtcdate *r)</span>;<br></code></pre></td></tr></table></figure><ul><li>usys.S</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asm">SYSCALL(date)<br></code></pre></td></tr></table></figure><p>然后再添加一个用户程序 date.c，来调用该系统调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span> <span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (date(&amp;r)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;date failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// your code to print the time in any format you like...</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d-%d-%d %d:%d:%d UTC\n&quot;</span>, r.year, r.month, r.day, r.hour, r.minute, r.second);<br>  <span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile 里添加具体的应用程序。</p><p><img src="https://imgs.bencorn.com/imgs/HW3-system-calls-2023-07-20-09-52-16.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-Memory</title>
    <link href="/2023/07/05/xv6-Memory/"/>
    <url>/2023/07/05/xv6-Memory/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>这个部分，我们来学习一下 xv6 是如何进行内存的管理的，了解最简单的管理方式，为后续学习 Linux 内存管理哪些打个小基础。</p><p>xv6 <a href="./book-rev11.pdf">这儿有源文件</a> 是一个 UNIX 风格的操作系统。后续的代码，我会按照顺序，对其进行拆分，和一些自己理解的说明，其实基本上内容都是在 xv6 的这本书里。</p><h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><p>x86 的指令操纵的都是虚拟地址（virtual address），而硬件 RAM 物理内存（physical address），则是每个存储空间有一个物理地址。x86 页表硬件将虚拟地址和物理地址进行一一映射。</p><p>x86 页表逻辑上是一个大小为 2^20 的数组，每个数组想被称为一个页表条目(page table entry, PTEs)。每个 PTE 包含 20-bit 物理页号（physical page number, PPN）和一些标志 flag。页表硬件将虚拟地址的高 20-bit 作为索引在页表中寻找一个 PTE，然后将高 20-bit 的地址替换为 PTE 中对应内存单元中保存的 PPN；同时，页表硬件将虚拟地址中的低 12-bit 直接复制到物理内存中的低 12-bit 的位置，然后和前边儿的 20-bit 组合起来形成一个地址，这个地址就是虚拟地址对应的实际的物理地址，然后硬件系统就可以通过该物理地址进行内存数据的访问。通过这样的步骤，就可以得到一个页大小 2^12（4096）bytes。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Memory-2023-07-09-21-30-21.png" alt="x86 page table hardware"></p><p>如图所示，虚拟地址到物理地址的转换实际分为了两个步骤。页表在物理内存中保存为两级树的形式，树的根部是一个 4096 字节的页目录（page directory），包含 1024 个页表页（page table pages）。这些页表页都包含一个 1024 大小的 32-bit 的页表条目（PTEs）。</p><p>页表硬件会使用虚拟地址的高地址的 10-bits 在页目录表中选择条目，然后使用接下来的 10-bits 在二级页表中选择页表条目。如果页目录表（page directory entry）和页表条目（PTE）都没有的话，页表硬件会报错。</p><p>每个 PTE 会包含标志位，页表硬件通过这些标志位来知晓如何使用虚拟地址。</p><ul><li>PTE_P：表明PTE是否存在，如果否会报错；</li><li>PTE_W：表明指令是否可以对页进行写操作，如果否，那么只允许读和取指令；</li><li>PTE_U：表明用户程序允许使用该页；</li></ul><p>这些标志位的具体信息，可以在 <code>mmu.h</code> 中看到，这些 16 进制的数，转化为二进制过后就可以得到相应的标志位为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Page table/directory entry flags.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_P           0x001   <span class="hljs-comment">// Present</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_W           0x002   <span class="hljs-comment">// Writeable</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_U           0x004   <span class="hljs-comment">// User</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_PS          0x080   <span class="hljs-comment">// Page Size</span></span><br></code></pre></td></tr></table></figure><p>关于术语的一些注释。 物理内存是指DRAM中的存储单元。 物理内存的一个字节有一个地址，称为物理地址。 指令仅使用虚拟地址，分页硬件将其转换为物理地址，然后发送到 DRAM 硬件以读取或写入存储。 在这个级别的讨论中，没有虚拟内存之类的东西，只有虚拟地址。</p><h1 id="Process-address-space"><a href="#Process-address-space" class="headerlink" title="Process address space"></a>Process address space</h1><p>这个部分我们讨论 xv6 的进程地址空间。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># By convention, the _start symbol specifies the ELF entry point.<br># Since we haven<span class="hljs-string">&#x27;t set up virtual memory yet, our entry point is</span><br><span class="hljs-string"># the physical address of &#x27;</span>entry<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">.globl _start</span><br><span class="hljs-string">_start = V2P_WO(entry)</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Entering xv6 on boot processor, with paging off.</span><br><span class="hljs-string">.globl entry</span><br><span class="hljs-string">entry:</span><br><span class="hljs-string">  # Turn on page size extension for 4Mbyte pages</span><br><span class="hljs-string">  movl    %cr4, %eax</span><br><span class="hljs-string">  orl     $(CR4_PSE), %eax</span><br><span class="hljs-string">  movl    %eax, %cr4</span><br><span class="hljs-string">  # Set page directory</span><br><span class="hljs-string">  movl    $(V2P_WO(entrypgdir)), %eax</span><br><span class="hljs-string">  movl    %eax, %cr3</span><br><span class="hljs-string">  # Turn on paging.</span><br><span class="hljs-string">  movl    %cr0, %eax</span><br><span class="hljs-string">  orl     $(CR0_PG|CR0_WP), %eax</span><br><span class="hljs-string">  movl    %eax, %cr0</span><br><span class="hljs-string"></span><br><span class="hljs-string">  # Set up the stack pointer.</span><br><span class="hljs-string">  movl $(stack + KSTACKSIZE), %esp</span><br><span class="hljs-string"></span><br><span class="hljs-string">  # Jump to main(), and switch to executing at</span><br><span class="hljs-string">  # high addresses. The indirect call is needed because</span><br><span class="hljs-string">  # the assembler produces a PC-relative instruction</span><br><span class="hljs-string">  # for a direct jump.</span><br><span class="hljs-string">  mov $main, %eax</span><br><span class="hljs-string">  jmp *%eax</span><br><span class="hljs-string"></span><br><span class="hljs-string">.comm stack, KSTACKSIZE</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>由entry创建的页表有足够的映射来允许内核的C代码开始运行。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// Allocate one page table for the machine for the kernel address</span><br><span class="hljs-comment">// space for scheduler processes.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kvmalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  kpgdir = setupkvm();<br>  switchkvm();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然而，main 立即通过调用 kvmalloc 更改为新的页表，因为内核有一个更详细的计划来描述进程地址空间。</p><p>每个进程有一个单独的页表，并且 xv6 告知页表硬件，当 xv6 切换进程的时候切换页表。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Memory-2023-07-10-20-44-02.png" alt="Layout of the virtual address space of a process and the layout of the physical address space. Note that if a machine has more than 2 Gbyte of physical memory, xv6 can use only the memory that fits between KERNBASE and 0xFE00000"></p><p>如图所示，一个进程的用户内存从虚拟地址 0 开始，一直增长到 <code>KERNBASE </code> 的位置，允许一个进程寻址最多 2G。</p><p>在 <code>memlayout.h</code> 中，有描述 xv6 的内存布局，和一些将虚拟地址转化到虚拟地址的宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Memory layout</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXTMEM  0x100000            <span class="hljs-comment">// Start of extended memory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHYSTOP 0xE000000           <span class="hljs-comment">// Top physical memory</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEVSPACE 0xFE000000         <span class="hljs-comment">// Other devices are at high addresses</span></span><br><br><span class="hljs-comment">// Key addresses for address space layout (see kmap in vm.c for layout)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80000000         <span class="hljs-comment">// First kernel virtual address</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNLINK (KERNBASE+EXTMEM)  <span class="hljs-comment">// Address where kernel is linked</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2P(a) (((uint) (a)) - KERNBASE)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> P2V(a) ((void *)(((char *) (a)) + KERNBASE))</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> V2P_WO(x) ((x) - KERNBASE)    <span class="hljs-comment">// same as V2P, but without casts</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> P2V_WO(x) ((x) + KERNBASE)    <span class="hljs-comment">// same as P2V, but without casts</span></span><br><br></code></pre></td></tr></table></figure><p>当一个进程向 xv6 申请内存的时候，xv6 首先寻找空闲的物理页（physical page），然后添加 PTEs 到进程的页表，该 PTEs 指向新的物理页。xv6 设置 <code>PTE_U PTE_W PTE_P</code> 标志位在这些 PTEs中。绝大部分进程不会使用完所有的用户进程空间，xv6 让 未使用的PTEs的 <code>PTE_P</code> 清零。不同的进程页表将用户地址转换为不同的物理内存，所以每个进程都有私有的用户内存。</p><p>xv6 包含了内核在每个进程的页表中运行所需的所有映射； 这些映射都出现在 KERNBASE 之上。它将虚拟地址 KERNBASE:KERNBASE+PHYSTOP 映射到 0:PHYSTOP。 这种映射的原因之一是内核可以使用自己的指令和数据。 另一个原因是内核有时需要能够写入物理内存的给定页面，例如在创建页表页面时； 让每个物理页都出现在可预测的虚拟地址处使这变得很方便。 这种安排的一个缺陷是 xv6 无法使用超过 2 GB 的物理内存，因为地址空间的内核部分是 2 GB。 因此，xv6 要求 PHYSTOP 小于 2 GB，即使计算机具有超过 2 GB 的物理内存。</p><p>一些使用内存映射 I&#x2F;O 的设备出现在从 0xFE000000 开始的物理地址处，因此 xv6 页表包括它们的直接映射。 因此，PHYSTOP 必须小于 2 GB - 16 MB（对于设备内存）。</p><p>xv6 不会将高于 KERNBASE 的 PTEs 中设置 PTE_U 标志，所以只有内核可以使用他们。</p><p>让每个进程的页表都包含用户内存和整个内核的映射，在系统调用和中断期间从用户代码切换到内核代码时很方便：这种切换不需要页表切换。 大多数情况下，内核没有自己的页表； 它几乎总是借用某个进程的页表。（其实这种管理方式是不安全的，Linux 现在都会维护内核页表，用户态切换带内核态的时候，也会从用户页表切换到内核页表）</p><p>回顾一下，xv6 确保每个进程只能使用自己的内存。 而且，每个进程都将其内存视为具有从零开始的连续虚拟地址，而进程的物理内存可以是不连续的。 xv6 通过仅在引用进程自己的内存的虚拟地址的 PTE 上设置 PTE_U 位来实现第一个。 它使用页表的能力来实现第二个，将连续的虚拟地址转换为恰好分配给进程的任何物理页。</p><h2 id="Code：createing-an-address-space"><a href="#Code：createing-an-address-space" class="headerlink" title="Code：createing an address space"></a>Code：createing an address space</h2><p>main 调用 kvmalloc 创建并切换到具有内核运行所需的 KERNBASE 以上映射的页表。 大部分工作发生在 setupkvm 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Set up kernel part of a page table.</span><br><span class="hljs-type">pde_t</span>*<br><span class="hljs-title function_">setupkvm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">pde_t</span> *pgdir;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kmap</span> *<span class="hljs-title">k</span>;</span><br><br>  <span class="hljs-keyword">if</span>((pgdir = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">memset</span>(pgdir, <span class="hljs-number">0</span>, PGSIZE);<br>  <span class="hljs-keyword">if</span> (P2V(PHYSTOP) &gt; (<span class="hljs-type">void</span>*)DEVSPACE)<br>    panic(<span class="hljs-string">&quot;PHYSTOP too high&quot;</span>);<br>  <span class="hljs-keyword">for</span>(k = kmap; k &lt; &amp;kmap[NELEM(kmap)]; k++)<br>    <span class="hljs-keyword">if</span>(mappages(pgdir, k-&gt;virt, k-&gt;phys_end - k-&gt;phys_start,<br>                (uint)k-&gt;phys_start, k-&gt;perm) &lt; <span class="hljs-number">0</span>) &#123;<br>      freevm(pgdir);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  <span class="hljs-keyword">return</span> pgdir;<br>&#125;<br></code></pre></td></tr></table></figure><p>它首先分配一个内存页来保存页目录。 然后它调用mappages 来安装内核所需的翻译，这些映射在 kmap 数组中进行了描述。 这些翻译包括内核的指令和数据、直至 PHYSTOP 的物理内存以及实际上是 I&#x2F;O 设备的内存范围。 setupkvm 不会为用户内存安装任何映射； 这将在稍后发生。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to</span><br><span class="hljs-comment">// physical addresses starting at pa. va and size might not</span><br><span class="hljs-comment">// be page-aligned.</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, uint size, uint pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  <span class="hljs-type">char</span> *a, *last;<br>  <span class="hljs-type">pte_t</span> *pte;<br><br>  a = (<span class="hljs-type">char</span>*)PGROUNDDOWN((uint)va);<br>  last = (<span class="hljs-type">char</span>*)PGROUNDDOWN(((uint)va) + size - <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">if</span>((pte = walkpgdir(pgdir, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_P)<br>      panic(<span class="hljs-string">&quot;remap&quot;</span>);<br>    *pte = pa | perm | PTE_P;<br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += PGSIZE;<br>    pa += PGSIZE;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mappages 将一系列虚拟地址到对应的物理地址范围的映射安装到页表中。 它以页面大小间隔为范围内的每个虚拟地址单独执行此操作。 对于每个要映射的虚拟地址，mappages 调用 walkpgdir 来查找该地址的 PTE 地址。 然后它初始化 PTE 以保存相关的物理页号、期望的权限 (PTE_W 和&#x2F;或 PTE_U) 以及 PTE_P 以将 PTE 标记为有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Return the address of the PTE in page table pgdir</span><br><span class="hljs-comment">// that corresponds to virtual address va.  If alloc!=0,</span><br><span class="hljs-comment">// create any required page table pages.</span><br><span class="hljs-type">static</span> <span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">walkpgdir</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>  <span class="hljs-type">pde_t</span> *pde;<br>  <span class="hljs-type">pte_t</span> *pgtab;<br><br>  pde = &amp;pgdir[PDX(va)];<br>  <span class="hljs-keyword">if</span>(*pde &amp; PTE_P)&#123;<br>    pgtab = (<span class="hljs-type">pte_t</span>*)P2V(PTE_ADDR(*pde));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>(!alloc || (pgtab = (<span class="hljs-type">pte_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// Make sure all those PTE_P bits are zero.</span><br>    <span class="hljs-built_in">memset</span>(pgtab, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-comment">// The permissions here are overly generous, but they can</span><br>    <span class="hljs-comment">// be further restricted by the permissions in the page table</span><br>    <span class="hljs-comment">// entries, if necessary.</span><br>    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;<br>  &#125;<br>  <span class="hljs-keyword">return</span> &amp;pgtab[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure><p>walkpgdir  模仿 x86 分页硬件在 PTE 中查找虚拟地址的操作。 walkpgdir 使用虚拟地址的高 10 位来查找页目录条目。 如果页目录项不存在，则所需的页表页尚未分配； 如果设置了 alloc 参数，walkpgdir 会分配它并将其物理地址放入页目录中。 最后，它使用虚拟地址的接下来的 10 位来查找页表页中 PTE 的地址。</p><h1 id="Physical-memory-allocation"><a href="#Physical-memory-allocation" class="headerlink" title="Physical memory allocation"></a>Physical memory allocation</h1><p>这个部分看一看物理内存的分配。</p><p>内核必须在运行时为页表、进程用户内存、内核堆栈和管道缓冲区分配和释放物理内存。</p><p>xv6 使用 kernel 结尾到 PHYSTOP 之间的物理内存，来为运行过程中进行内存分配。每一次分配，都是按照 4096-byte 大小的页进行。并且通过链表来跟踪每个页的使用情况。</p><p>物理内存分配包括从链表中删除一个页，释放物理内存则是添加空闲页到链表。</p><p>存在一个引导问题：必须映射所有物理内存以便分配器初始化空闲列表，但是使用这些映射创建页表涉及分配页表页面。 xv6 通过在进入期间使用单独的页面分配器来解决这个问题，该分配器在内核数据段末尾之后分配内存。 该分配器不支持释放，并且受到 entrypgdir 中 4 MB 映射的限制，但这足以分配第一个内核页表。</p><h2 id="Code：Physical-memory-allocator"><a href="#Code：Physical-memory-allocator" class="headerlink" title="Code：Physical memory allocator"></a>Code：Physical memory allocator</h2><p>分配器的数据结构是可用于分配的物理内存页的空闲列表。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-type">int</span> use_lock;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem;<br><br></code></pre></td></tr></table></figure><p>每个空闲页面的列表元素都是一个struct run。分配器从哪里获取内存来保存该数据结构？ 它将每个空闲页面的运行结构存储在空闲页面本身中，因为那里没有存储任何其他内容。 空闲列表受自旋锁保护。 链表和锁包装在一个结构中，以明确锁保护结构中的字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Bootstrap processor starts running C code here.</span><br><span class="hljs-comment">// Allocate a real stack and switch to it, first</span><br><span class="hljs-comment">// doing some setup required for memory allocator to work.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  kinit1(end, P2V(<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>)); <span class="hljs-comment">// phys page allocator</span><br>  kvmalloc();      <span class="hljs-comment">// kernel page table</span><br>  mpinit();        <span class="hljs-comment">// detect other processors</span><br>  lapicinit();     <span class="hljs-comment">// interrupt controller</span><br>  seginit();       <span class="hljs-comment">// segment descriptors</span><br>  picinit();       <span class="hljs-comment">// disable pic</span><br>  ioapicinit();    <span class="hljs-comment">// another interrupt controller</span><br>  consoleinit();   <span class="hljs-comment">// console hardware</span><br>  uartinit();      <span class="hljs-comment">// serial port</span><br>  pinit();         <span class="hljs-comment">// process table</span><br>  tvinit();        <span class="hljs-comment">// trap vectors</span><br>  binit();         <span class="hljs-comment">// buffer cache</span><br>  fileinit();      <span class="hljs-comment">// file table</span><br>  ideinit();       <span class="hljs-comment">// disk </span><br>  startothers();   <span class="hljs-comment">// start other processors</span><br>  kinit2(P2V(<span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>), P2V(PHYSTOP)); <span class="hljs-comment">// must come after startothers()</span><br>  userinit();      <span class="hljs-comment">// first user process</span><br>  mpmain();        <span class="hljs-comment">// finish this processor&#x27;s setup</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数 main 调用 kinit1 和 kinit2 来初始化分配器。 进行两次调用的原因是，对于 main 的大部分调用来说，不能使用锁或超过 4 MB 的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Initialization happens in two phases.</span><br><span class="hljs-comment">// 1. main() calls kinit1() while still using entrypgdir to place just</span><br><span class="hljs-comment">// the pages mapped by entrypgdir on free list.</span><br><span class="hljs-comment">// 2. main() calls kinit2() with the rest of the physical pages</span><br><span class="hljs-comment">// after installing a full page table that maps them on all cores.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kinit1</span><span class="hljs-params">(<span class="hljs-type">void</span> *vstart, <span class="hljs-type">void</span> *vend)</span><br>&#123;<br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  kmem.use_lock = <span class="hljs-number">0</span>;<br>  freerange(vstart, vend);<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kinit2</span><span class="hljs-params">(<span class="hljs-type">void</span> *vstart, <span class="hljs-type">void</span> *vend)</span><br>&#123;<br>  freerange(vstart, vend);<br>  kmem.use_lock = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>kinit1 为前 4 MB 建立无锁的分配，kinit2 则是对剩下的更多的内存添加锁服务。</p><p>main 函数应该决定多少物理内存是可用的，但是在 x86 上比较困难。取而代之的，它假设一台电脑拥有 224 MB（PHYSTOP）的物理内存，并且使用所有的 kernel 结束位置到 PHYSTOP 的物理内存作为初始空闲内存池。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">freerange</span><span class="hljs-params">(<span class="hljs-type">void</span> *vstart, <span class="hljs-type">void</span> *vend)</span><br>&#123;<br>  <span class="hljs-type">char</span> *p;<br>  p = (<span class="hljs-type">char</span>*)PGROUNDUP((uint)vstart);<br>  <span class="hljs-keyword">for</span>(; p + PGSIZE &lt;= (<span class="hljs-type">char</span>*)vend; p += PGSIZE)<br>    kfree(p);<br>&#125;<br></code></pre></td></tr></table></figure><p>kinit1 和 kinit2 调用 <code>freerange</code> 接口添加内存到空闲链表，这个步骤是通过对每一个物理页调用 <code>kfree</code> 来实现。一个 PTE 只能指向一个对齐 4096-byte 的物理地址，所以会使用 <code>PGROUNDUP</code> 来保证对齐。分配器 allocator 初始是没有内存的，这些调用通过 <code>kfree</code> 准备好一些内存来给分配器使用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//PAGEBREAK: 21</span><br><span class="hljs-comment">// Free the page of physical memory pointed at by v,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">char</span> *v)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>((uint)v % PGSIZE || v &lt; end || V2P(v) &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">1</span>, PGSIZE);<br><br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    acquire(&amp;kmem.lock);<br>  r = (<span class="hljs-keyword">struct</span> run*)v;<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    release(&amp;kmem.lock);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>kfree</code> 功能将一个物理内存页进行释放，并且将其添加到空闲内存链表内。这个步骤是需要进行原子操作的，因此会使用原子锁进行控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">char</span>*<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r)<br>    kmem.freelist = r-&gt;next;<br>  <span class="hljs-keyword">if</span>(kmem.use_lock)<br>    release(&amp;kmem.lock);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">char</span>*)r;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>kalloc</code> 则是分配一个 4096-byte 大小的物理内存，并且返回一个指向该内存页初始地址的指针。如果返回 0 的话，则是没有内存可以分配了。</p><p>值得注意的是，分配器 allocator 通过虚拟地址映射来指向一个物理页，所以 <code>kinit </code> 使用 <code>P2V(PHYSTOP)</code> 来将物理地址 PHYSTOP 翻译成一个虚拟地址。分配器有时将地址视为整数以便对其进行算术（例如，遍历 kinit 中的所有页面），有时将地址用作读写内存的指针（例如，操作存储在每个页面中的运行结构）； 地址的双重使用是分配器代码充满 C 类型转换的主要原因。 另一个原因是释放和分配本质上改变了内存的类型。</p><h1 id="User-part-of-an-address-space"><a href="#User-part-of-an-address-space" class="headerlink" title="User part of an address space"></a>User part of an address space</h1><p><img src="https://imgs.bencorn.com/imgs/xv6-Memory-2023-07-15-09-18-00.png" alt="Memory layout of a user process with its initial stack"></p><p>如图所示，xv6 进程的用户内存空间分布。每一个用户进程都从地址 0 开始。地址空间的地步是用户程序的具体内容 text，data，stack。堆 heap 在栈 stack 的上方，进程可以通过 <code>sbrk</code> 来扩展堆的大小。值得注意的是，text，data，stack 在进程地址空间内是连续的，但是 xv6 可以自由的为这些部分使用非连续的物理页。例如，当 xv6 扩展进程的 heap 时，可以使用任何空闲的物理页来构建新的虚拟页，然后使用页表硬件，通过编程将虚拟页映射到物理页。这种灵活性是使用分页硬件的主要优点。</p><p>堆栈是一个页，并显示由 <code>exec</code> 创建的初始内容。 包含命令行参数的字符串以及指向它们的指针数组位于堆栈的最顶部。 就在其下方是允许程序在 <code>main</code> 处启动的值，就像函数调用 <code>main(argc, argv)</code> 刚刚启动一样。 为了保护堆栈从堆栈页增长，xv6 在堆栈的正下方放置了一个保护页。 保护页未映射，因此如果堆栈超出堆栈页，硬件将生成异常，因为它无法转换错误地址。 Linux等操作系统可能会为堆栈分配更多空间，以便它可以增长到超过一页。</p><h2 id="Code：sbrk"><a href="#Code：sbrk" class="headerlink" title="Code：sbrk"></a>Code：sbrk</h2><p>sbrk 是一个系统调用，它可以为一个进程收缩或者增加内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  <span class="hljs-keyword">if</span>(growproc(n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>该系统调用通过函数 <code>growproc</code> 来实现。如果 n 是正数，<code>growproc</code> 会分配一个或更多的物理页，并且映射他们到进程地址空间的顶部。如果 n 是负数，则会从进程地址空间的顶部取消一个或更多的页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Grow current process&#x27;s memory by n bytes.</span><br><span class="hljs-comment">// Return 0 on success, -1 on failure.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">growproc</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint sz;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  sz = curproc-&gt;sz;<br>  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = allocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">if</span>((sz = deallocuvm(curproc-&gt;pgdir, sz, sz + n)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  curproc-&gt;sz = sz;<br>  switchuvm(curproc);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了进行这些更改，xv6 修改了进程的页表。 进程的页表存储在内存中，因此内核可以使用普通的赋值语句更新页表，这就是 allocuvm 和 deallocuvm 所做的事情。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate page tables and physical memory to grow process from oldsz to</span><br><span class="hljs-comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">allocuvm</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span><br>&#123;<br>  <span class="hljs-type">char</span> *mem;<br>  uint a;<br><br>  <span class="hljs-keyword">if</span>(newsz &gt;= KERNBASE)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(newsz &lt; oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  a = PGROUNDUP(oldsz);<br>  <span class="hljs-keyword">for</span>(; a &lt; newsz; a += PGSIZE)&#123;<br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      cprintf(<span class="hljs-string">&quot;allocuvm out of memory\n&quot;</span>);<br>      deallocuvm(pgdir, newsz, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    <span class="hljs-keyword">if</span>(mappages(pgdir, (<span class="hljs-type">char</span>*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) &lt; <span class="hljs-number">0</span>)&#123;<br>      cprintf(<span class="hljs-string">&quot;allocuvm out of memory (2)\n&quot;</span>);<br>      deallocuvm(pgdir, newsz, oldsz);<br>      kfree(mem);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>allocuvm</code> 分配一个物理页，并且添加一个映射到页表内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Deallocate user pages to bring the process size from oldsz to</span><br><span class="hljs-comment">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span><br><span class="hljs-comment">// need to be less than oldsz.  oldsz can be larger than the actual</span><br><span class="hljs-comment">// process size.  Returns the new process size.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">deallocuvm</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, uint oldsz, uint newsz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint a, pa;<br><br>  <span class="hljs-keyword">if</span>(newsz &gt;= oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br><br>  a = PGROUNDUP(newsz);<br>  <span class="hljs-keyword">for</span>(; a  &lt; oldsz; a += PGSIZE)&#123;<br>    pte = walkpgdir(pgdir, (<span class="hljs-type">char</span>*)a, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(!pte)<br>      a = PGADDR(PDX(a) + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) - PGSIZE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((*pte &amp; PTE_P) != <span class="hljs-number">0</span>)&#123;<br>      pa = PTE_ADDR(*pte);<br>      <span class="hljs-keyword">if</span>(pa == <span class="hljs-number">0</span>)<br>        panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br>      <span class="hljs-type">char</span> *v = P2V(pa);<br>      kfree(v);<br>      *pte = <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>deallocuvm</code> 删除页表中的映射关系。并且调整具体的内存大小的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Switch TSS and h/w page table to correspond to process p.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">switchuvm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(p == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;switchuvm: no process&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;kstack == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;switchuvm: no kstack&quot;</span>);<br>  <span class="hljs-keyword">if</span>(p-&gt;pgdir == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;switchuvm: no pgdir&quot;</span>);<br><br>  pushcli();<br>  mycpu()-&gt;gdt[SEG_TSS] = SEG16(STS_T32A, &amp;mycpu()-&gt;ts,<br>                                <span class="hljs-keyword">sizeof</span>(mycpu()-&gt;ts)<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>  mycpu()-&gt;gdt[SEG_TSS].s = <span class="hljs-number">0</span>;<br>  mycpu()-&gt;ts.ss0 = SEG_KDATA &lt;&lt; <span class="hljs-number">3</span>;<br>  mycpu()-&gt;ts.esp0 = (uint)p-&gt;kstack + KSTACKSIZE;<br>  <span class="hljs-comment">// setting IOPL=0 in eflags *and* iomb beyond the tss segment limit</span><br>  <span class="hljs-comment">// forbids I/O instructions (e.g., inb and outb) from user space</span><br>  mycpu()-&gt;ts.iomb = (ushort) <span class="hljs-number">0xFFFF</span>;<br>  ltr(SEG_TSS &lt;&lt; <span class="hljs-number">3</span>);<br>  lcr3(V2P(p-&gt;pgdir));  <span class="hljs-comment">// switch to process&#x27;s address space</span><br>  popcli();<br>&#125;<br></code></pre></td></tr></table></figure><p>x86 硬件将页表条目缓存在 Translation Look-aside Buffer(TLB) 中，当 xv6 更改页表时，它必须使缓存的条目无效。如果它没有使缓存的条目无效，那么在稍后的某个时刻，TLB 可能会使用旧的映射，指向同时已分配给另一个进程的物理页，因此，进程可能能在其他进程的内存上修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">lcr3</span><span class="hljs-params">(uint val)</span><br>&#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;movl %0,%%cr3&quot;</span> : : <span class="hljs-string">&quot;r&quot;</span> (val))</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>xv6 通过重新加载 cr3（保存当前页表地址的寄存器）来使过时的缓存条目无效。</p><h2 id="Code：exec"><a href="#Code：exec" class="headerlink" title="Code：exec"></a>Code：exec</h2><p><code>exec</code> 是创建地址空间的用户部分的系统调用。它从文件系统中存储的文件初始化地址空间的用户部分。</p><p><code>exec</code> 使用 <code>namei</code> 打开命名二进制路径。然后，它读取 ELF 标头。 xv6 应用程序使用 elf 格式，在 elf.h 中定义。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Format of an ELF executable file</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU  <span class="hljs-comment">// &quot;\x7FELF&quot; in little endian</span></span><br><br><span class="hljs-comment">// File header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> &#123;</span><br>  uint magic;  <span class="hljs-comment">// must equal ELF_MAGIC</span><br>  uchar elf[<span class="hljs-number">12</span>];<br>  ushort type;<br>  ushort machine;<br>  uint version;<br>  uint entry;<br>  uint phoff;<br>  uint shoff;<br>  uint flags;<br>  ushort ehsize;<br>  ushort phentsize;<br>  ushort phnum;<br>  ushort shentsize;<br>  ushort shnum;<br>  ushort shstrndx;<br>&#125;;<br><br><span class="hljs-comment">// Program section header</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> &#123;</span><br>  uint type;<br>  uint off;<br>  uint vaddr;<br>  uint paddr;<br>  uint filesz;<br>  uint memsz;<br>  uint flags;<br>  uint align;<br>&#125;;<br><br><span class="hljs-comment">// Values for Proghdr type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD           1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC      1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE     2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ      4</span><br><br></code></pre></td></tr></table></figure><p>ELF 二进制文件由 ELF 头 struct elfhdr 组成，后面跟着一系列程序段头 struct proghdr。 每个 proghdr 描述了必须加载到内存中的应用程序的一部分； xv6 程序只有一个程序节标头，但其他系统可能有单独的指令和数据节。</p><p>第一步是快速检查该文件是否可能包含 ELF 二进制文件。 ELF 二进制文件以四字节“幻数 ”0x7F、“E”、“L”、“F” 或 ELF_MAGIC 开头。 如果 ELF 标头具有正确的幻数，则 exec 会假定二进制文件格式良好。</p><p><code>exec</code> 使用 setupkvm 分配一个没有用户映射的新页表，使用 allocuvm 为每个 ELF 段分配内存，并使用 loaduvm 将每个段加载到内存中。 allocuvm 检查请求的虚拟地址是否低于 KERNBASE。 loaduvm 使用 walkpgdir 查找已定位内存的物理地址，在该地址写入 ELF 段的每个页面，并使用 readi 从文件中读取。</p><p>&#x2F;init（使用 exec 创建的第一个用户程序）的程序节标头如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># objdump -p _init</span><br>_init:  file format elf32-i386<br>Program Header:<br>  LOAD off 0x00000054 vaddr 0x00000000 paddr 0x00000000 align 2**2<br>    filesz 0x000008c0 memsz 0x000008cc flags rwx<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>xv6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Minikube-创建集群</title>
    <link href="/2023/06/06/Minikube-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/06/06/Minikube-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>学习和复现一些小练习，从最基础的开始捏。从最基本的使用 K8S 开始，通过使用 Minikube 创建集群。<br>学习地址链接：<a href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/</a></p><h1 id="Kubernetes-集群"><a href="#Kubernetes-集群" class="headerlink" title="Kubernetes 集群"></a>Kubernetes 集群</h1><p>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。 Kubernetes 中的抽象允许你将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。 Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源:</p><ul><li>Control Plane 调度整个集群</li><li>Nodes 负责运行应用</li></ul><p><img src="https://imgs.bencorn.com/imgs/Minikube-%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4-2023-06-06-22-39-38.png" alt="集群图"></p><p>Control Plane 负责管理整个集群。 Control Plane 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色。每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Control Plane 通信的代理。 Node 还应该具有用于​​处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node，因为如果一个 Node 出现故障其对应的 etcd 成员和控制平面实例都会丢失，并且冗余会受到影响。 你可以通过添加更多控制平面节点来降低这种风险 。</p><p>Control Plane 管理集群，Node 用于托管正在运行的应用。</p><p>在 Kubernetes 上部署应用时，你告诉 Control Plane 启动应用容器。 Control Plane 就编排容器在集群的 Node 上运行。 Node 使用 Control Plane 暴露的 Kubernetes API 与 Control Plane 通信。终端用户也可以使用 Kubernetes API 与集群交互。</p><p>Kubernetes 既可以部署在物理机上也可以部署在虚拟机上。你可以使用 Minikube 开始部署 Kubernetes 集群。 Minikube 是一种轻量级的 Kubernetes 实现，可在本地计算机上创建 VM 并部署仅包含一个节点的简单集群。 Minikube 可用于 Linux ， macOS 和 Windows 系统。Minikube CLI 提供了用于引导集群工作的多种操作，包括启动、停止、查看状态和删除。</p><h1 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h1><ul><li>目标：将一个示例应用部署到 Minikube。运行应用程序。查看应用日志。</li><li>环境：Ubuntu 20.04，自用笔记本</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下载安装 minikube，链接：<a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube_latest_amd64.deb<br>sudo dpkg -i minikube_latest_amd64.deb<br></code></pre></td></tr></table></figure><p>安装完成过后，尝试启动一个集群。在 root 权限下执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start<br></code></pre></td></tr></table></figure><p>如果不出意外的话，这个时候会出现没有 driver 的报错，这个时候可以按照链接里边儿的说明进行修复。这个地方，我准备采用 docker 来作为底层的 driver。链接：<a href="https://minikube.sigs.k8s.io/docs/drivers/docker/">https://minikube.sigs.k8s.io/docs/drivers/docker/</a></p><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><p>链接：<a href="https://docs.docker.com/engine/install/ubuntu/">https://docs.docker.com/engine/install/ubuntu/</a></p><p>删除之前存在的一些依赖，包括 containerd、runc 等，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">for</span> pkg <span class="hljs-keyword">in</span> docker.io docker-doc docker-compose podman-docker containerd runc; <span class="hljs-keyword">do</span> sudo apt-get remove <span class="hljs-variable">$pkg</span>; <span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>然后我们使用 apt repo 来进行安装，便于后续的更新。首先安装一些辅助的工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install ca-certificates curl gnupg<br></code></pre></td></tr></table></figure><p>添加 docker official GPG key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo install -m 0755 -d /etc/apt/keyrings<br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg<br>sudo <span class="hljs-built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg<br></code></pre></td></tr></table></figure><p>添加 docker 仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="hljs-string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-string">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$VERSION_CODENAME</span>&quot;</span>)<span class="hljs-string">&quot; stable&quot;</span> | \<br>  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br></code></pre></td></tr></table></figure><p>安装 docker engine，并且运行验证，更新 docker 的时候也使用这些命令。可能会出现下载比较缓慢的情况，最好是有 ipv6，兴许会下载较快。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin<br>sudo docker run hello-world<br></code></pre></td></tr></table></figure><h3 id="继续"><a href="#继续" class="headerlink" title="继续"></a>继续</h3><p>使用 docker 作为 driver 启动，或者可以设置 docker 作为默认 driver。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start --driver=docker  <br>minikube config <span class="hljs-built_in">set</span> driver docker<br></code></pre></td></tr></table></figure><p>然后这个时候，如果在 sudo su 模式下当做 minikube 的 driver，会提示报错；但是如果直接运行，又会使用 unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock 的权限不够，因此需要将本机的用户添加到 docker 组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span> &amp;&amp; newgrp docker<br></code></pre></td></tr></table></figure><p>如果不出意外的话，应该是可以运行起来了，而且会下载一些个相关的镜像,我只能说网速是真的慢。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>链接：<a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><ul><li>启动集群：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube start --driver=docker<br></code></pre></td></tr></table></figure><ul><li>集群交互，通过 kubectl 与集群进行交互。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- get po -A<br>minikube kubectl -- get pods -A<br>minikube dashboard<br></code></pre></td></tr></table></figure><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><p>通过三种不同的方式来创建和部署应用。</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>创建一个简单的服务，并进行部署，将端口暴露到8080：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- create deployment hello-minikube --image=kicbase/echo-server:1.0<br>minikube kubectl -- expose deployment hello-minikube --<span class="hljs-built_in">type</span>=NodePort --port=8080<br></code></pre></td></tr></table></figure><p>稍等一会儿，然后观察部署情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- get services hello-minikube<br></code></pre></td></tr></table></figure><p>可以让 minikube 启动一个浏览器来观察：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube service hello-minikube<br></code></pre></td></tr></table></figure><p>可以使用 kubectl 来转发端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- port-forward service/hello-minikube 7080:8080<br></code></pre></td></tr></table></figure><p>这个时候，刚刚部署的这个服务，可以在 <a href="http://localhost:7080/">http://localhost:7080/</a> 上访问到了。</p><h3 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h3><p>创建一个 LoadBalancer 负载均衡器，并且将其路由到集群外部可访问。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl -- create deployment balanced --image=kicbase/echo-server:1.0<br>minikube kubectl -- expose deployment balanced --<span class="hljs-built_in">type</span>=LoadBalancer --port=8080<br></code></pre></td></tr></table></figure><p>在另外一个 shell 窗口中，开起 tunnel 来为已部署的实例进行负载 IP 的路由。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube tunnel<br></code></pre></td></tr></table></figure><p>可以通过下列命令找到，已经可以路由访问的外部 IP 地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube kubectl get services balanced<br></code></pre></td></tr></table></figure><p>现在该服务可以在 &lt;external&#x3D;ip&gt;:8080 中访问到。</p><h3 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h3><p>开起 ingress addon 机制测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">minikube addons <span class="hljs-built_in">enable</span> ingress<br></code></pre></td></tr></table></figure><p>下边给出一个例子，创建一个 echo-server 服务并且一个 ingress 路由到这个服务。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">foo</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">foo-app</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;kicbase/echo-server:1.0&#x27;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">foo-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">foo</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bar-app</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">bar</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">bar-app</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">&#x27;kicbase/echo-server:1.0&#x27;</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">bar-service</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">bar</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">example-ingress</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">rules:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">http:</span><br>        <span class="hljs-attr">paths:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/foo</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">service:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">foo-service</span><br>                <span class="hljs-attr">port:</span><br>                  <span class="hljs-attr">number:</span> <span class="hljs-number">8080</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>            <span class="hljs-attr">path:</span> <span class="hljs-string">/bar</span><br>            <span class="hljs-attr">backend:</span><br>              <span class="hljs-attr">service:</span><br>                <span class="hljs-attr">name:</span> <span class="hljs-string">bar-service</span><br>                <span class="hljs-attr">port:</span><br>                  <span class="hljs-attr">number:</span> <span class="hljs-number">8080</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>K8s</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xv6-Boot</title>
    <link href="/2023/04/25/xv6-Boot/"/>
    <url>/2023/04/25/xv6-Boot/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>学习 xv6 的同时，对照 Linux 0.11 源代码进行理解，希望自己能够有所提升吧。顺便给自己立一个 flag，看能不能花两个月的时间啃完。</p><p>xv6 <a href="./book-rev11.pdf">这儿有源文件</a> 是一个 UNIX 风格的操作系统。后续的代码，我会按照顺序，对其进行拆分，和一些自己理解的说明，其实基本上内容都是在 xv6 的这本书里。</p><h1 id="The-boot-loader"><a href="#The-boot-loader" class="headerlink" title="The boot loader"></a>The boot loader</h1><p>xv6 是基于 X86 的，可以参考的芯片手册是 i386。在实验部分有细讲。当 X86 的机子开机的时候，PC 会首先执行 BIOS（Basic Input&#x2F;Output System）程序，BIOS 是保存在主板上的非易失性存储器上。</p><p>BIOS 的任务是准备好 PC 的硬件，然后将控制权转移给操作系统。BIOS 首先会把控制权转移给保存在启动盘的第一个 512 字节的扇区内的代码，也就是 boot loader：一些汇编代码组成的指令，它主要把内核加载到内存。BIOS 把启动扇区内的 boot loader 加载到内存地址为 0x7c00 的地方，然后将处理器的 pc（%ip） 设置为该地址。</p><p>当 boot loader 开始执行，处理器模拟 Intel 8088 模式（16-bit 实模式）运行，并且 boot loader 的任务就是处理器设置成为现代处理器模式（32-bit 保护模式）。然后 boot loader 从磁盘把 xv6 的内核加载到内存，把控制权转交给内核。xv6 的 boot loader 分为两个文件，分别是 bootasm.S 和 bootmain.c</p><h2 id="Code-Assembly-bootstrap"><a href="#Code-Assembly-bootstrap" class="headerlink" title="Code: Assembly bootstrap"></a>Code: Assembly bootstrap</h2><p>boot loader 的第一条指令是 cli，它的作用是关中断（中断：硬件提供的调用操作系统的中断处理函数的机制）。为啥要关中断呢？现代处理器的 BIOS 实际上是一个小型的操作系统，BIOS 在运行的时候，可能也会使用一些中断处理函数来初始化硬件。但是，在运行 boot loader 的时候，BIOS 已经没有运行了，原来定义的中断处理函数例程不应该再被使用，所以就要先关中断。所以，也会猜到，当 xv6 操作系统就绪的时候，中断应该会再次被打开，而此时的中断服务例程是由 xv6 提供。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">#include <span class="hljs-string">&quot;asm.h&quot;</span><br>#include <span class="hljs-string">&quot;memlayout.h&quot;</span><br>#include <span class="hljs-string">&quot;mmu.h&quot;</span><br><br># Start the first <span class="hljs-meta">CPU</span>: switch to <span class="hljs-number">32</span>-bit protected mode, jump <span class="hljs-keyword">into</span> C.<br># The BIOS loads this code from the first sector of the hard disk <span class="hljs-keyword">into</span><br># memory <span class="hljs-meta">at</span> physical address <span class="hljs-number">0x7c00</span> <span class="hljs-keyword">and</span> starts executing <span class="hljs-keyword">in</span> real mode<br># with %cs=<span class="hljs-number">0</span> %ip=7c00.<br><span class="hljs-meta"></span><br><span class="hljs-meta">.code16</span>                       # Assemble for <span class="hljs-number">16</span>-bit mode<br><span class="hljs-meta">.globl</span> start<br><span class="hljs-symbol">start:</span><br>  <span class="hljs-keyword">cli</span>                         # BIOS enabled interrupts<span class="hljs-comment">; disable</span><br></code></pre></td></tr></table></figure><p>接下来就是老生常谈了，X86 的特点了，兼容性带来的一系列的特殊东西。<br>具体的细节可以查询这个手册：<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a></p><p>现在，X86 处理器是运行在实模式的，它实际上是模拟 Intel 8088 运行机制。实模式下有以下特征，总共有 8 个 16-bit 的通用寄存器，但是 CPU 进行内存访问使用的是 20-bit 的地址。所以段寄存器 <code>%cs，%ds，%es，%ss</code>为 16-bit 的寄存器们提供额外的 4-bit 的寻址，来凑齐 20-bit，这样的机制是处理器本身的硬件结构设计导致的，至于为什么，估计是为了兼容性导致的了。当程序在访问内存的时候，处理器会自动将段寄存器的值乘以 16，然后加上这些寄存器里的内存地址。内存使用的种类通常会指明使用哪个寄存器：指令的获取使用代码段寄存器<code>%cs</code>，数据的读写使用数据段寄存器<code>%ds</code>。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Boot-2023-04-26-11-08-04.png" alt="relationship between logical，linear，physical address"></p><p>xv6 是假设 X86 的指令，对其内存操作数是使用的虚拟地址（virtual address），但是一条 X86 指令实际上使用的是逻辑地址（logical address）。一条逻辑地址包含段选择子（segment selector）和偏移（offset），可以写作<code>segment:offset</code>。常见的情况是，段是隐式的，程序实际上只操作偏移量。段处理相关的硬件，将逻辑地址转换为线性地址（linear address）。如果页相关的硬件支持打开的话，那么页处理相关的硬件将会把线性地址转换为物理地址（physical address）；如果页没有启用，那么处理器会将线性地址，直接当做物理地址来使用。</p><p>说明：虚拟地址就是程序操纵的地址，出于历史原因被这样叫做。其他三个地址概念是 Intel 处理器出现的硬件上的概念。</p><p>boot loader 是没有使用页机制的，逻辑地址被直接转换为线性地址，线性地址直接当做物理地址使用。xv6 配置硬件将逻辑地址翻译为线性地址，并且不做任何改变，所以此时的逻辑地址和线性地址是相等的。xv6 的虚拟地址是和 X86 的逻辑地址是相同的，并且和线性地址相同。（虽然很奇怪，段机制没有使用上的感觉，xv6 的逻辑是这样的）当页机制开起的时候，线性地址转换为物理地址就成了我们后续唯一需要重点关注的。</p><p>BIOS 并没有保证<code>%ds，%es，%ss</code>的值为某个特定的值，因此第一件事情就是对每个段寄存器清零。那为什么要用<code>xorw %ax,%ax</code>，而不是<code>movw $0,%ax</code>呢，在逻辑电路上边儿表示的话，应该是会更快一点。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># <span class="hljs-meta">Zero</span> data <span class="hljs-meta">segment</span> registers <span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-keyword">and</span> <span class="hljs-built_in">SS</span>.<br>xorw    %ax,%ax             # Set %ax to <span class="hljs-meta">zero</span><br>movw    %ax,%ds             # -&gt; Data <span class="hljs-meta">Segment</span><br>movw    %ax,%es             # -&gt; Extra <span class="hljs-meta">Segment</span><br>movw    %ax,%ss             # -&gt; Stack <span class="hljs-meta">Segment</span><br></code></pre></td></tr></table></figure><p>地址<code>segment:offset</code>可以达到 21-bit 的物理地址，但是 Intel 8088 只能使用 20-bit 的内存地址，所以丢弃掉了高地址<code>0xffff0 + 0xffff = 0x10ffef</code>,但是虚拟地址<code>0xffff:0xffff</code>指向物理地址的<code>0x0ffef</code>。早期的依赖硬件的一些软件会选择忽略到第 21 位地址，IBM 提供了一种方式让硬件更加的灵活。它是这样操作的，如果键盘控制器的输出端口的第 2 个bit位是关着的，那么第 21 位物理地址总是清零；如果是开着的，那么第 21 位地址是正常的。boot loader 必须将第 21 位地址位变为可用，把键盘控制器端口<code>0x64</code>和<code>0x60</code>设置为开起，即可达到该效果。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"> # Physical address line A20 is tied to <span class="hljs-meta">zero</span> so that the first PCs <br>  # with <span class="hljs-number">2</span> MB would run software that assumed <span class="hljs-number">1</span> MB.  Undo that.<br><span class="hljs-symbol">seta20.1:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.1</span><br><br>  movb    <span class="hljs-number">$0</span>xd1,%al               # <span class="hljs-number">0xd1</span> -&gt; port <span class="hljs-number">0x64</span><br>  outb    %al,<span class="hljs-number">$0</span>x64<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">seta20.2:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.2</span><br><br>  movb    <span class="hljs-number">$0</span>xdf,%al               # <span class="hljs-number">0xdf</span> -&gt; port <span class="hljs-number">0x60</span><br>  outb    %al,<span class="hljs-number">$0</span>x60<br></code></pre></td></tr></table></figure><p>实模式 16-bit 的通用寄存器和段寄存器，最多只能访问 1M 的内存，X86 处理器从 80286 开始支持保护模式，增加了寻址能力，然后 80386 支持 32-bit 模式， 让寻址、寄存器等支持 32 位。</p><p>保护模式下，段寄存器是一个到段描述符表（segment descriptor table）的索引。每个表条目都指定一个物理地址基址（base），一个最大虚拟地址的限制（limit），一个权限控制 bit （permission bits）等组成。权限控制位在保护模式下，让操作系统内核保证代码只能使用自己的内存，这样就可以起到保护作用。</p><p><img src="https://imgs.bencorn.com/imgs/xv6-Boot-2023-04-27-09-37-32.png" alt="Segment in protected mode"></p><p>xv6 基本上没使用段，它主要使用的是页机制。xv6 的 boot loader 设置好短描述符表 gdt，让每个表项的基地址都为 0，同时每个表项的最大可能的限制都设置为 4G。段描述符表有一个空的表项，一个执行代码段表项，一个数据段表项。代码段描述符有一个标志（flag）位设置，它可以表示代码是运行在 32-bit 模式的，当这个开起的时候，boot loader 进入保护模式，逻辑地址就一条一条的被映射成为物理地址（注意这个时候还没有开起页机制，线性地址就是当做物理地址用）。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># Bootstrap GDT<br><span class="hljs-meta">.p2align</span> <span class="hljs-number">2</span>                                # force <span class="hljs-number">4</span> <span class="hljs-built_in">byte</span> alignment<br><span class="hljs-symbol">gdt:</span><br>  SEG_NULLASM                             # null <span class="hljs-built_in">seg</span><br>  SEG_ASM(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)   # code <span class="hljs-built_in">seg</span><br>  SEG_ASM(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)         # data <span class="hljs-built_in">seg</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gdtdesc:</span><br><span class="hljs-meta">  .word</span>   (gdtdesc - gdt - <span class="hljs-number">1</span>)             # sizeof(gdt) - <span class="hljs-number">1</span><br><span class="hljs-meta">  .long</span>   gdt                             # address gdt<br><br></code></pre></td></tr></table></figure><p>boot loader 执行 <code>lgdt</code> 指令，将段描述符表的信息 <code>gdtdesc</code> 加载到全局描述符表寄存器（GDT register，简称 gdtr），寄存器的值指向全局描述符表 <code>gdt</code>。当 boot loader 加载了全局描述符表寄存器，boot loader 通过将寄存器 <code>%cr0</code> 的 1 bit（CR0_PE） 位设置开起保护模式。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># Switch from real to protected mode.  Use a bootstrap GDT that makes<br># virtual addresses map directly to physical addresses so that the<br># effective memory map doesn<span class="hljs-string">&#x27;t change during the transition.</span><br><span class="hljs-string">lgdt    gdtdesc</span><br><span class="hljs-string">movl    %cr0, %eax</span><br><span class="hljs-string">orl     $CR0_PE, %eax</span><br><span class="hljs-string">movl    %eax, %cr0</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>开起保护模式过后，处理器不是立马就是在保护模式了，也并不是立刻就改变处理器是如何将逻辑地址转换成物理地址的。这个时候，只有当处理器从GDT读取并加载一个新的值到段寄存器，然后它才会改变内部的段机制相关的设置。由于我们不可以直接手动设置 <code>%cs</code>段寄存器，因此只有执行代码 <code>ljmp</code> 长跳转指令，才能保证段选择子被定义。长跳转所跳转的指令继续执行，由于此时 <code>%cs</code> 指向的代码段是 32-bit 的，所以处理器切换到 32-bit 模式。</p><p>此时，boot loader将处理器的运行模式，从 8088 模式，切换到 80286 模式，最后切换到了 80386 模式。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># PAGEBREAK!<br># Complete the transition to <span class="hljs-number">32</span>-bit protected mode by using a long <span class="hljs-keyword">jmp</span><br># to reload %cs <span class="hljs-keyword">and</span> %eip.  The <span class="hljs-meta">segment</span> descriptors are set <span class="hljs-meta">up</span> with no<br># translation, so that the mapping is still the identity mapping.<br>ljmp    $(SEG_KCODE&lt;&lt;<span class="hljs-number">3</span>), $start32<br><br></code></pre></td></tr></table></figure><p>进入 32-bit 模式过后，boot loader 第一件事情，是设置代码段寄存器的值为 <code>SEG_KDATA</code>。现在逻辑地址仍然是直接映射到物理地址的，这个时候为了支持C代码的运行，需要在未使用的内存区域，建立好堆栈。目前，内存中从 0xa0000 到 0x100000 是设备内存区，然后 xv6 的内核将放置在 0x100000。boot loader 则是放置在 0x7c00 到 0x7e00（512 bytes）的区域。其他的任何空闲的区域都可以作为堆栈来使用，boot loader 选择 0x7c00 作为堆栈的栈顶，堆栈将从该地址开始往下压栈，一直直到 0x0000，这样可以很好的远离 boot loader。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta"></span><br><span class="hljs-meta">.code32</span>  # Tell assembler to generate <span class="hljs-number">32</span>-bit code now.<br><span class="hljs-symbol">start32:</span><br>  # Set <span class="hljs-meta">up</span> the protected-mode data <span class="hljs-meta">segment</span> registers<br>  movw    $(SEG_KDATA&lt;&lt;<span class="hljs-number">3</span>), %ax    # Our data <span class="hljs-meta">segment</span> selector<br>  movw    %ax, %ds                # -&gt; <span class="hljs-built_in">DS</span>: Data <span class="hljs-meta">Segment</span><br>  movw    %ax, %es                # -&gt; <span class="hljs-built_in">ES</span>: Extra <span class="hljs-meta">Segment</span><br>  movw    %ax, %ss                # -&gt; <span class="hljs-built_in">SS</span>: Stack <span class="hljs-meta">Segment</span><br>  movw    <span class="hljs-number">$0</span>, %ax                 # <span class="hljs-meta">Zero</span> segments <span class="hljs-keyword">not</span> ready for use<br>  movw    %ax, %fs                # -&gt; <span class="hljs-built_in">FS</span><br>  movw    %ax, %gs                # -&gt; <span class="hljs-built_in">GS</span><br><br></code></pre></td></tr></table></figure><p>最后，boot loader 调用 C 函数 bootmain。bootmain 的主要任务是，加载并且运行操作系统的内核。后续的代码主要是为了与模拟器做准备，call bootmain 它仅在出现问题时返回。在这种情况下，代码会在端口 0x8a00 上发送一些输出字。在真正的硬件上，没有设备连接到那个端口，所以这段代码什么都不做。如果引导加载程序在 PC 模拟器中运行，端口 0x8a00 连接到模拟器本身，并且可以将控制权传回模拟器。不管是否是模拟器，代码都会执行一个无限循环。真正的引导加载程序可能会首先尝试打印错误消息。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br>  # Set <span class="hljs-meta">up</span> the stack pointer <span class="hljs-keyword">and</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">into</span> C.<br>  movl    $start, %esp<br>  <span class="hljs-keyword">call</span>    bootmain<br><br>  # If bootmain returns (it shouldn<span class="hljs-string">&#x27;t), trigger a Bochs</span><br><span class="hljs-string">  # breakpoint if running under Bochs, then loop.</span><br><span class="hljs-string">  movw    $0x8a00, %ax            # 0x8a00 -&gt; port 0x8a00</span><br><span class="hljs-string">  movw    %ax, %dx</span><br><span class="hljs-string">  outw    %ax, %dx</span><br><span class="hljs-string">  movw    $0x8ae0, %ax            # 0x8ae0 -&gt; port 0x8a00</span><br><span class="hljs-string">  outw    %ax, %dx</span><br><span class="hljs-string">spin:</span><br><span class="hljs-string">  jmp     spin</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h2 id="Code-C-bootstrap"><a href="#Code-C-bootstrap" class="headerlink" title="Code: C bootstrap"></a>Code: C bootstrap</h2><p>boot loader 的 C 语言部分，bootmain.c 主要是在磁盘的第二个扇区寻找可执行的内核，内核文件以 ELF 二进制文件的格式保存。读取内核二进制文件的时候，首先读取 ELF 的 header，bootmain 首先读取 ELF 文件的前 4096 bytes，将其拷贝到内存地址为 0x10000的位置。然后就是检测，将要读取的是否是 ELF 文件，如果不是，那么直接返回，bootasm.S定义好的错误处理进行处理；如果是的话，接着 header 后边的内容，从 phoff 字节开始写入到内存地址为 paddr 的位置。Bootmain 调用 readseg 从磁盘加载数据并调用 stosb 将段的剩余部分归零。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Boot loader.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Part of the boot block, along with bootasm.S, which calls bootmain().</span><br><span class="hljs-comment">// bootasm.S has put the processor into protected 32-bit mode.</span><br><span class="hljs-comment">// bootmain() loads an ELF kernel image from the disk starting at</span><br><span class="hljs-comment">// sector 1 and then jumps to the kernel entry routine.</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;elf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;x86.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTSIZE  512</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">readseg</span><span class="hljs-params">(uchar*, uint, uint)</span>;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bootmain</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">elfhdr</span> *<span class="hljs-title">elf</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br>  <span class="hljs-type">void</span> (*entry)(<span class="hljs-type">void</span>);<br>  uchar* pa;<br><br>  elf = (<span class="hljs-keyword">struct</span> elfhdr*)<span class="hljs-number">0x10000</span>;  <span class="hljs-comment">// scratch space</span><br><br>  <span class="hljs-comment">// Read 1st page off disk</span><br>  readseg((uchar*)elf, <span class="hljs-number">4096</span>, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// Is this an ELF executable?</span><br>  <span class="hljs-keyword">if</span>(elf-&gt;magic != ELF_MAGIC)<br>    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// let bootasm.S handle error</span><br><br>  <span class="hljs-comment">// Load each program segment (ignores ph flags).</span><br>  ph = (<span class="hljs-keyword">struct</span> proghdr*)((uchar*)elf + elf-&gt;phoff);<br>  eph = ph + elf-&gt;phnum;<br>  <span class="hljs-keyword">for</span>(; ph &lt; eph; ph++)&#123;<br>    pa = (uchar*)ph-&gt;paddr;<br>    readseg(pa, ph-&gt;filesz, ph-&gt;off);<br>    <span class="hljs-keyword">if</span>(ph-&gt;memsz &gt; ph-&gt;filesz)<br>      stosb(pa + ph-&gt;filesz, <span class="hljs-number">0</span>, ph-&gt;memsz - ph-&gt;filesz);<br>  &#125;<br><br>  <span class="hljs-comment">// Call the entry point from the ELF header.</span><br>  <span class="hljs-comment">// Does not return!</span><br>  entry = (<span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span>))(elf-&gt;entry);<br>  entry();<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">waitdisk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// Wait for disk ready.</span><br>  <span class="hljs-keyword">while</span>((inb(<span class="hljs-number">0x1F7</span>) &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x40</span>)<br>    ;<br>&#125;<br><br><span class="hljs-comment">// Read a single sector at offset into dst.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, uint offset)</span><br>&#123;<br>  <span class="hljs-comment">// Issue command.</span><br>  waitdisk();<br>  outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// count = 1</span><br>  outb(<span class="hljs-number">0x1F3</span>, offset);<br>  outb(<span class="hljs-number">0x1F4</span>, offset &gt;&gt; <span class="hljs-number">8</span>);<br>  outb(<span class="hljs-number">0x1F5</span>, offset &gt;&gt; <span class="hljs-number">16</span>);<br>  outb(<span class="hljs-number">0x1F6</span>, (offset &gt;&gt; <span class="hljs-number">24</span>) | <span class="hljs-number">0xE0</span>);<br>  outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);  <span class="hljs-comment">// cmd 0x20 - read sectors</span><br><br>  <span class="hljs-comment">// Read data.</span><br>  waitdisk();<br>  insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE/<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span><br><span class="hljs-comment">// Might copy more than asked.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readseg</span><span class="hljs-params">(uchar* pa, uint count, uint offset)</span><br>&#123;<br>  uchar* epa;<br><br>  epa = pa + count;<br><br>  <span class="hljs-comment">// Round down to sector boundary.</span><br>  pa -= offset % SECTSIZE;<br><br>  <span class="hljs-comment">// Translate from bytes to sectors; kernel starts at sector 1.</span><br>  offset = (offset / SECTSIZE) + <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span><br>  <span class="hljs-comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span><br>  <span class="hljs-comment">// we load in increasing order.</span><br>  <span class="hljs-keyword">for</span>(; pa &lt; epa; pa += SECTSIZE, offset++)<br>    readsect(pa, offset);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Bootmain 调用 readseg 从磁盘加载数据并调用 stosb 将段的剩余部分归零。Stosb 使用 x86 指令 rep stosb 来初始化内存块的每个字节。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">stosb</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">int</span> data, <span class="hljs-type">int</span> cnt)</span><br>&#123;<br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;cld; rep stosb&quot;</span> :</span><br><span class="hljs-params">               <span class="hljs-string">&quot;=D&quot;</span> (addr), <span class="hljs-string">&quot;=c&quot;</span> (cnt) :</span><br><span class="hljs-params">               <span class="hljs-string">&quot;0&quot;</span> (addr), <span class="hljs-string">&quot;1&quot;</span> (cnt), <span class="hljs-string">&quot;a&quot;</span> (data) :</span><br><span class="hljs-params">               <span class="hljs-string">&quot;memory&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>内核经过编译和链接，在虚拟地址为 0x80100000 中找到内核。因此，函数调用指令必须类似于 call 0x801xxxxx 的目标地址。这个地址在kernel.ld中配置0x80100000是一个比较高的地址，朝向32位地址空间的末尾； 第 2 章解释了做出这种选择的原因。 在这么高的地址可能没有任何物理内存。 一旦内核开始执行，它将设置分页硬件来映射虚拟地址 0x80100000 到 0x00100000 开始的物理地址；内核假定在这个低地址有物理内存。但是，这个时候 boot loader 未启用分页机制。于是，编写链接文件的时候，kernel.ld 指定 ELF paddr 从 0x00100000 开始，这会导致 boot loader 将内核复制到 0x00100000 低物理地址，当开起分页机制过后，分页硬件将会将 0x80100000 最终指向该地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">/* Simple linker script for the JOS kernel.<br>   See the GNU ld <span class="hljs-string">&#x27;info&#x27;</span> manual (<span class="hljs-string">&quot;info ld&quot;</span>) to learn the syntax. */<br><br>OUTPUT_FORMAT(<span class="hljs-string">&quot;elf32-i386&quot;</span>, <span class="hljs-string">&quot;elf32-i386&quot;</span>, <span class="hljs-string">&quot;elf32-i386&quot;</span>)<br>OUTPUT_ARCH(i386)<br>ENTRY(_start)<br><br>SECTIONS<br>&#123;<br>/* Link the kernel <span class="hljs-meta">at</span> this address: <span class="hljs-string">&quot;.&quot;</span> means the current address */<br>        /* Must be equal to KERNLINK */<br>. = <span class="hljs-number">0x80100000</span><span class="hljs-comment">;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.text</span> : <span class="hljs-meta">AT</span>(<span class="hljs-number">0x100000</span>) &#123;<br>*(.text .stub .text.* .gnu<span class="hljs-number">.</span>linkonce<span class="hljs-number">.</span>t.*)<br>&#125;<br><br>PROVIDE(etext = .)<span class="hljs-comment">;/* Define the &#x27;etext&#x27; symbol to this value */</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.rodata</span> : &#123;<br>*(.rodata .rodata.* .gnu<span class="hljs-number">.</span>linkonce<span class="hljs-number">.</span>r.*)<br>&#125;<br><br>/* Include debugging information <span class="hljs-keyword">in</span> kernel memory */<br><span class="hljs-meta">.stab</span> : &#123;<br>PROVIDE(__STAB_BEGIN__ = .)<span class="hljs-comment">;</span><br>*(.stab)<span class="hljs-comment">;</span><br>PROVIDE(__STAB_END__ = .)<span class="hljs-comment">;</span><br>&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">.stabstr</span> : &#123;<br>PROVIDE(__STABSTR_BEGIN__ = .)<span class="hljs-comment">;</span><br>*(.stabstr)<span class="hljs-comment">;</span><br>PROVIDE(__STABSTR_END__ = .)<span class="hljs-comment">;</span><br>&#125;<br><br>/* Adjust the address for the data <span class="hljs-meta">segment</span> to the next page */<br>. = <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">0x1000</span>)<span class="hljs-comment">;</span><br><br>/* Conventionally, Unix linkers provide pseudo-symbols<br> * etext, edata, <span class="hljs-keyword">and</span> end, <span class="hljs-meta">at</span> the end of the text, data, <span class="hljs-keyword">and</span> bss.<br> * For the kernel mapping, we need the address <span class="hljs-meta">at</span> the beginning<br> * of the data <span class="hljs-meta">section</span>, but that<span class="hljs-string">&#x27;s not one of the conventional</span><br><span class="hljs-string"> * symbols, because the convention started before there was a</span><br><span class="hljs-string"> * read-only rodata section between text and data. */</span><br><span class="hljs-string">PROVIDE(data = .);</span><br><span class="hljs-string"></span><br><span class="hljs-string">/* The data segment */</span><br><span class="hljs-string">.data : &#123;</span><br><span class="hljs-string">*(.data)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">PROVIDE(edata = .);</span><br><span class="hljs-string"></span><br><span class="hljs-string">.bss : &#123;</span><br><span class="hljs-string">*(.bss)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">PROVIDE(end = .);</span><br><span class="hljs-string"></span><br><span class="hljs-string">/DISCARD/ : &#123;</span><br><span class="hljs-string">*(.eh_frame .note.GNU-stack)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>boot loader 的最后一步是调用内核的入口，也就是调用内核开始执行的地方。xv6 的入口地址是 0x10000c。<br><img src="https://imgs.bencorn.com/imgs/xv6-Boot-2023-04-27-19-55-32.png" alt="xv6 kernel entry point"></p><p>按照惯例，_start 符号指定 ELF 入口点，它在文件 entry.S 中定义。 由于xv6还没有设置虚拟内存，所以xv6的entry point就是entry的物理地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br># By convention, the _start symbol specifies the ELF entry point.<br># Since we haven<span class="hljs-string">&#x27;t set up virtual memory yet, our entry point is</span><br><span class="hljs-string"># the physical address of &#x27;</span>entry<span class="hljs-string">&#x27;.</span><br><span class="hljs-string">.globl _start</span><br><span class="hljs-string">_start = V2P_WO(entry)</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>到这个地方 xv6 的 boot loader 就基本上结束了，嗯，xv6 的设计的话，还是进行了简化，但是确实是可行的，其中段机制的使用很少，然后就是由于页机制迟迟没有打开，先是在物理内存上，把整个操作系统安排好了，再做页机制的映射，后续对照一下 linux 看一下是怎么做到的。</p>]]></content>
    
    
    <categories>
      
      <category>xv6</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chronos和simplescalar安装</title>
    <link href="/2022/09/20/chronos%E5%92%8Csimplescalar%E5%AE%89%E8%A3%85/"/>
    <url>/2022/09/20/chronos%E5%92%8Csimplescalar%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="安装预先准备"><a href="#安装预先准备" class="headerlink" title="安装预先准备"></a>安装预先准备</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>ubuntu 9.04（32-bit）   Virtualbox</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p> <a href="https://uestc.feishu.cn/file/boxcnoDny8joPj3GnKWb2l6vtRe">ubuntu-9.04-desktop-i386.iso</a>        </p><h2 id="chronos安装包"><a href="#chronos安装包" class="headerlink" title="chronos安装包"></a>chronos安装包</h2><p><a href="https://uestc.feishu.cn/file/boxcnLYNkH68ZIZbNGTtE1uOBCg">chronos2.0版本安装包.zip</a> </p><h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225317.png" alt="虚拟机"></p><p>正常按照步骤安装系统</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225327.png" alt="安装系统"></p><p>安装好系统之后，切换源，教程如下，笔者使用的中科大源：</p><p><a href="https://mirrors.ustc.edu.cn/help/ubuntu-old-releases.html">https://mirrors.ustc.edu.cn/help/ubuntu-old-releases.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225345.png" alt="更换APT源"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Plain">sudo sed -i &#x27;s/cn.archive.ubuntu.com/mirrors.ustc.edu.cn/ubuntu-old-releases/g&#x27; /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>更换完源后，安装桌面工具,点击虚拟机客户端，生成插件到桌面并执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo sh VBoxLinuxAdditions.run<br></code></pre></td></tr></table></figure><p>安装相关工具包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">sudo apt-get install vim<br>sudo apt upgrade<br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><h2 id="Chronos安装"><a href="#Chronos安装" class="headerlink" title="Chronos安装"></a>Chronos安装</h2><p>将chronos传入虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">scp ./chronos2.0.zip chronos@192.168.2.108<br></code></pre></td></tr></table></figure><p>创建chronos文件夹，simplescalar将安装包内容解压到此</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">mkdir</span> simplescalar<br>unzip chronos2.0.zip<br><span class="hljs-built_in">mkdir</span> simplescalar<br><span class="hljs-built_in">mv</span> simplesim-3.0.tgz simplescalar/<br></code></pre></td></tr></table></figure><h3 id="安装Chronos2-0分析器"><a href="#安装Chronos2-0分析器" class="headerlink" title="安装Chronos2.0分析器"></a><strong>安装Chronos2.0分析器</strong></h3><p>添加全局路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">export</span> IDIR=<span class="hljs-variable">$HOME</span>/chronos<br></code></pre></td></tr></table></figure><p>安装相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo apt-get install flex-old<br>sudo apt-get install bison<br>sudo apt-get install openjdk-6-* -y<br></code></pre></td></tr></table></figure><p>编译est 分析器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> est &amp;&amp; make<br><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">cd</span> gui &amp;&amp; make<br></code></pre></td></tr></table></figure><h3 id="安装lp-solve"><a href="#安装lp-solve" class="headerlink" title="安装lp_solve"></a><strong>安装lp_solve</strong></h3><p><strong>将其含有文件全部解压</strong></p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225400.png" alt="解压文件"></p><h3 id="安装simplescalar"><a href="#安装simplescalar" class="headerlink" title="安装simplescalar"></a><strong>安装simplescalar</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">cd</span> simplescalar <br>sudo apt-get install gcc-3.4<br></code></pre></td></tr></table></figure><p>添加simplescalar环境变量</p><p>先查看平台,看是i686或是i386</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">uname</span> -m<br><span class="hljs-built_in">export</span> CC=<span class="hljs-string">&quot;gcc-3.4&quot;</span><br><span class="hljs-built_in">export</span> HOST=i686-unknown-linux <br><span class="hljs-built_in">export</span> TARGET=sslittle-na-sstrix <br><span class="hljs-built_in">export</span> IDIR=<span class="hljs-variable">$HOME</span>/chronos/simplescalar<br></code></pre></td></tr></table></figure><p>解压simplescalar</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">tar xvf simpletools-2v0.tgz <br><span class="hljs-built_in">rm</span> -rf gcc-2.6.3<br>tar -xvzf simpleutils-990811.tar.gz<br></code></pre></td></tr></table></figure><h4 id="Simplescalar-utils编译安装"><a href="#Simplescalar-utils编译安装" class="headerlink" title="Simplescalar utils编译安装"></a><strong>Simplescalar utils编译安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">./configure --host=<span class="hljs-variable">$HOST</span> --target=<span class="hljs-variable">$TARGET</span> --with-gnu-as --with-gnu-ld --prefix=<span class="hljs-variable">$IDIR</span> <br>make CC=gcc-3.4 <br>sudo make install CC=gcc-3.4<br></code></pre></td></tr></table></figure><p>到此utils工具包安装完成</p><h4 id="Simplesim-3-0安装"><a href="#Simplesim-3-0安装" class="headerlink" title="Simplesim-3.0安装"></a><strong>Simplesim-3.0安装</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">make config-pisa<br>make CC=gcc-3.4<br></code></pre></td></tr></table></figure><h4 id="Simplescalar-gcc安装"><a href="#Simplescalar-gcc安装" class="headerlink" title="Simplescalar gcc安装"></a><strong>Simplescalar gcc安装</strong></h4><p>操作目录：gcc-2.7.2.3&#x2F;</p><p>PS:$IDIR&#x3D;&amp;HOME&#x2F;chronos&#x2F;simplescalar此时IDIR已改变</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Bash">tar xvzf gcc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$IDIR</span>/sslittle-na-sstrix/bin<br>./configure --host=<span class="hljs-variable">$HOST</span> --target=<span class="hljs-variable">$TARGET</span> --with-gnu-as --with-gnu-ld --prefix=<span class="hljs-variable">$IDIR</span>  <br><br>make LANGUAGES=<span class="hljs-string">&quot;c c++&quot;</span> CFLAGS=-O3 CC=gcc-3.4<br></code></pre></td></tr></table></figure><p>此时会报错：</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225419.png" alt="报错"></p><p>修改cxxmain.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">chmod</span> +w cxxmain.c<br></code></pre></td></tr></table></figure><p>在第cxxxmain.c 2978与2979行注释掉,修改后重新make：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">make clean <br>make <br></code></pre></td></tr></table></figure><p>备份相关文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> ..<br><span class="hljs-built_in">cd</span> sslittle-na-sstrix/include/sys <span class="hljs-built_in">cp</span> cdefs.h cdefs.h.bak<br><span class="hljs-built_in">cp</span> patched/sys/cdefs.h ../sslittle-na-sstrix/include/sys/<br>make enquire CC=gcc-3.4<br></code></pre></td></tr></table></figure><p>测试simlpescalar交叉编译的程序是否能够运行，用编译器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">../simplesim-3.0/sim-safe ./enquire -f &gt; float.h-cross<br></code></pre></td></tr></table></figure><p>出现以下结果则安装成功</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225436.png" alt="simplescalar安装成功"></p><p>将编译好的gcc安装到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo make install LANGUAGES=<span class="hljs-string">&quot;c c++&quot;</span> CFLAGS=-O3 CC=gcc-3.4 PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HOME</span>/chronos/simplescalar/bin<br></code></pre></td></tr></table></figure><p>测试simplescalar-gcc是否安装成功</p><p>写一个简单的c程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stido.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>sudo make install LANGUAGES=<span class="hljs-string">&quot;c c++&quot;</span> CFLAGS=-O3 CC=gcc<span class="hljs-number">-3.4</span> PATH=$PATH:$HOME/chronos/simplescalar/bin<br>simplescalar/simplesim<span class="hljs-number">-3.0</span>/sim-safe a.out <br></code></pre></td></tr></table></figure><p>切换命令解释器以适配chronos</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C">sudo mv /bin/sh sh.bak<br>sudo ln /bin/bash /bin/sh<br></code></pre></td></tr></table></figure><p>此环境默认jre为：</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920230155.png" alt="jre安装"></p><p>运行chronos</p><p>当前路径：chronos</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash"><span class="hljs-built_in">cd</span> gui<br>./gui.sh<br></code></pre></td></tr></table></figure><h1 id="软件运行结果"><a href="#软件运行结果" class="headerlink" title="软件运行结果"></a>软件运行结果</h1><p>出现如下界面：</p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225446.png" alt="chronos运行"></p><p>到此安装成功，配置好相关文件即可运行。</p><p>运行结果展示如下：</p><h2 id="processor配置"><a href="#processor配置" class="headerlink" title="processor配置"></a>processor配置</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920230300.png" alt="processor配置"></p><h2 id="循环边界配置"><a href="#循环边界配置" class="headerlink" title="循环边界配置"></a>循环边界配置</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225505.png" alt="insertsort分析"></p><h2 id="WCET分析结果"><a href="#WCET分析结果" class="headerlink" title="WCET分析结果"></a>WCET分析结果</h2><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225517.png" alt="分析结果1"></p><p><img src="https://imgs.bencorn.com/imgs/2022/09/20/20220920225531.png" alt="分析结果2"></p>]]></content>
    
    
    <categories>
      
      <category>WCET</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WCET</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW4 xv6 lazy page allocation</title>
    <link href="/2022/07/11/HW4-xv6-lazy-page-allocation/"/>
    <url>/2022/07/11/HW4-xv6-lazy-page-allocation/</url>
    
    <content type="html"><![CDATA[<h1 id="Homework-xv6-lazy-page-allocation"><a href="#Homework-xv6-lazy-page-allocation" class="headerlink" title="Homework: xv6 lazy page allocation"></a>Homework: xv6 lazy page allocation</h1><p> 本次作业要求实现一个对堆内存的延迟分配。</p><p> 实验链接：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-zero-fill.html</a></p><h2 id="Part-One：Eliminate-allocation-from-sbrk"><a href="#Part-One：Eliminate-allocation-from-sbrk" class="headerlink" title="Part One：Eliminate allocation from sbrk()"></a>Part One：Eliminate allocation from sbrk()</h2><p> 第一个任务是删除掉sbrk(n)系统调用实现，在sysproc.c中，手动注释掉该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_sbrk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> addr;<br>  <span class="hljs-type">int</span> n;<br><br>  <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;n) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  addr = myproc()-&gt;sz;<br>  <span class="hljs-comment">/*if(growproc(n) &lt; 0)</span><br><span class="hljs-comment">    return -1;</span><br><span class="hljs-comment">    */</span><br>  myproc()-&gt;sz += n;<br>  <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p> 将<code>growproc(n)</code>给注释掉过后，会出现以下的问题，该中断可以在trap.c中找到，终中断号14，发生page fault，在虚拟地址的0x4004引起该错误。</p><p><img src="https://imgs.bencorn.com/imgs/2022/07/11/20220711152745.png" alt="page fault"></p><p> 为什么会发生该错误呢？当我们注销掉<code>growproc(n)</code>过后？首先，<code>growproc(n)</code>函数，如果n是正数，会分配1个或者多个的物理内存页，并且将他们映射到调用该系统调用的进程空间的顶部；如果n是负数，则会从进程地址空间取消一个或者多个页并且释放相对应的物理页。也就是说，虽然我们改了进程的地址空间大小，但是没有具体映射到物理内存，就会导致该虚拟内存页错误。</p><h2 id="Part-Two：Lazy-allocation"><a href="#Part-Two：Lazy-allocation" class="headerlink" title="Part Two：Lazy allocation"></a>Part Two：Lazy allocation</h2><p> 在trap.c中实现一个延迟分配，只需要当虚拟内存发生页错误的时候，再触发分配物理内存。</p><p> 首先，我们可以从cprintf中发现，发生错误的地址是保存在cr2寄存器中，我们需要将该地址读出来，然后拿到它地址开始到一整个内存页的大小，然后未这个虚拟内存也创建物理内存页，并且进行映射。按照这样的思路喝题目提示，我们可以进行响应的代码编写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// page fault implemation</span><br><br><span class="hljs-keyword">if</span>(tf-&gt;trapno == T_PGFLT)&#123;<br>    uint va = PGROUNDDOWN(rcr2());<br>    <span class="hljs-keyword">if</span>(va &lt; myproc()-&gt;sz)&#123;<br>        <span class="hljs-type">char</span> *mem = kalloc();<br>        <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>            cprintf(<span class="hljs-string">&quot;out of memory!\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, PGSIZE);<br>    cprintf(<span class="hljs-string">&quot;kernel faulting in page at %x\n&quot;</span>, va);<br>    mappages(myproc()-&gt;pgdir, (<span class="hljs-type">char</span> *)va, PGSIZE, V2P(mem), PTE_W | PTE_U);<br>    <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 此处的mappages函数，在vm.c中是一个静态的函数，因此需要将其static修改掉，并且在trap.c中添加其函数定义进行链接<code> int mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm);</code></p><p><img src="https://imgs.bencorn.com/imgs/2022/07/13/20220713171334.png" alt="lazy allocation结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW3 system calls</title>
    <link href="/2022/07/01/HW3-system-calls/"/>
    <url>/2022/07/01/HW3-system-calls/</url>
    
    <content type="html"><![CDATA[<h1 id="Homework-xv6-system-calls"><a href="#Homework-xv6-system-calls" class="headerlink" title="Homework: xv6 system calls"></a>Homework: xv6 system calls</h1><p> 参考boot homework中的内容，为xv6操作系统添加一个系统调用。</p><p> 链接：<a href="https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html">https://pdos.csail.mit.edu/6.828/2018/homework/xv6-syscall.html</a></p><h2 id="Part-One-System-call-tracing"><a href="#Part-One-System-call-tracing" class="headerlink" title="Part One: System call tracing"></a>Part One: System call tracing</h2><p> 修改xv6内核，为每个系统调用打印一行，打印系统调用的名称和返回值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">char</span> syscall_name[][<span class="hljs-number">10</span>] = &#123;<br>[SYS_fork]      <span class="hljs-string">&quot;fork&quot;</span>,<br>[SYS_exit]      <span class="hljs-string">&quot;exit&quot;</span>,<br>[SYS_wait]      <span class="hljs-string">&quot;wait&quot;</span>,<br>[SYS_pipe]      <span class="hljs-string">&quot;pipe&quot;</span>,<br>[SYS_read]      <span class="hljs-string">&quot;read&quot;</span>,<br>[SYS_kill]      <span class="hljs-string">&quot;kill&quot;</span>,<br>[SYS_exec]      <span class="hljs-string">&quot;exec&quot;</span>,<br>[SYS_fstat]     <span class="hljs-string">&quot;fstat&quot;</span>,<br>[SYS_chdir]     <span class="hljs-string">&quot;chdir&quot;</span>,<br>[SYS_dup]       <span class="hljs-string">&quot;dup&quot;</span>,<br>[SYS_getpid]    <span class="hljs-string">&quot;getpid&quot;</span>,<br>[SYS_sbrk]      <span class="hljs-string">&quot;sbrk&quot;</span>,<br>[SYS_sleep]     <span class="hljs-string">&quot;sleep&quot;</span>,<br>[SYS_uptime]    <span class="hljs-string">&quot;uptime&quot;</span>,<br>[SYS_open]      <span class="hljs-string">&quot;open&quot;</span>,<br>[SYS_write]     <span class="hljs-string">&quot;write&quot;</span>,<br>[SYS_mknod]     <span class="hljs-string">&quot;mknod&quot;</span>,<br>[SYS_unlink]    <span class="hljs-string">&quot;unlink&quot;</span>,<br>[SYS_link]      <span class="hljs-string">&quot;link&quot;</span>,<br>[SYS_mkdir]     <span class="hljs-string">&quot;mkdir&quot;</span>,<br>[SYS_close]     <span class="hljs-string">&quot;close&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p> 首先类似于指针函数那样，准备一个名称数组，便于快速打印；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  num = curproc-&gt;tf-&gt;eax;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    curproc-&gt;tf-&gt;eax = syscalls[num]();<br>    cprintf(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, syscall_name[num], curproc-&gt;tf-&gt;eax);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            curproc-&gt;pid, curproc-&gt;name, num);<br>    curproc-&gt;tf-&gt;eax = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 然后添加打印具体的系统调用名称即可，根据x86的函数调用堆栈关系，返回值保存在eax寄存器之中，因此需要将进程页帧中的eax寄存器的值进行打印。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">curproc</span> =</span> myproc();<br><br>  num = curproc-&gt;tf-&gt;eax;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    curproc-&gt;tf-&gt;eax = syscalls[num]();<br>    cprintf(<span class="hljs-string">&quot;%s -&gt; %d\n&quot;</span>, syscall_name[num], curproc-&gt;tf-&gt;eax);<br>    <span class="hljs-type">int</span> *fd;<br>    <span class="hljs-keyword">switch</span>(num)&#123;<br>        <span class="hljs-keyword">case</span> SYS_fork:<br>            cprintf(<span class="hljs-string">&quot;sys_fork no args\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SYS_exit:<br>            cprintf(<span class="hljs-string">&quot;sys_exit no args\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SYS_wait:<br>            cprintf(<span class="hljs-string">&quot;sys_wait no args\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> SYS_pipe:<br>            <span class="hljs-keyword">if</span>(argptr(<span class="hljs-number">0</span>, (<span class="hljs-type">void</span>*)&amp;fd, <span class="hljs-number">2</span>*<span class="hljs-keyword">sizeof</span>(fd[<span class="hljs-number">0</span>]))&lt;<span class="hljs-number">0</span>)&#123;<br>                cprintf(<span class="hljs-string">&quot;error: sys_pipe cannot get the args\n&quot;</span>);<br>            &#125;<br>            cprintf(<span class="hljs-string">&quot;sys_pipe args: %p %p&quot;</span>,&amp;fd[<span class="hljs-number">0</span>],&amp;fd[<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    cprintf(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            curproc-&gt;pid, curproc-&gt;name, num);<br>    curproc-&gt;tf-&gt;eax = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 同样打印系统调用时的参数，仍然根据x86的堆栈关系，进行打印,具体的用法，在syscall.c的前边儿给出了几个辅助函数，进程的context内保存了%esp，通过从堆栈内部查找指定字节长度的值，来进行获取参数，同时参考具体的系统调用的程序来进行参数的获取于打印。</p><h2 id="Part-Two-Date-system-call"><a href="#Part-Two-Date-system-call" class="headerlink" title="Part Two: Date system call"></a>Part Two: Date system call</h2><p> 写一个用户态的应用，进行系统调用，给出具体的UTC时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span> <span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span> (date(&amp;r)) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;date failed\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;UTC date: %d-%d-%d %d:%d:%d\n&quot;</span>, r.year, r.month, r.day, r.hour, r.minute, r.second);<br>  <span class="hljs-built_in">exit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p> 首先添加一个用户程序，进行系统调用，并且将具体的日期输出到标准输出端口。同时在Makefile里边儿添加用户调用的编译选项。</p><p><img src="https://imgs.bencorn.com/imgs/2022/07/06/20220706234759.png" alt="uptime 系统调用组成"></p><p> 参照uptime的系统调用组成部分，对每个文件内的内容进行添加，分别是：</p><ul><li>在user.h中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">date</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> rtcdate*)</span>;<br></code></pre></td></tr></table></figure><ul><li>在usys.S中添加</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SYSCALL(date)<br></code></pre></td></tr></table></figure><ul><li>在syscall.h中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_date   22</span><br></code></pre></td></tr></table></figure><ul><li>在文件syscall.c中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">// syscalls array add</span><br>[SYS_date]    sys_date,<br></code></pre></td></tr></table></figure><ul><li>在文件sysproc.c中添加</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_date</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtcdate</span>*;</span><br>    <span class="hljs-keyword">if</span> (argptr(<span class="hljs-number">0</span>, (<span class="hljs-type">char</span>**)&amp;r, <span class="hljs-keyword">sizeof</span>(*r)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    cmostime(r);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 按照上述运行结果：</p><p><img src="https://imgs.bencorn.com/imgs/2022/07/06/20220706235454.png" alt="运行结果"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VPP Labs</title>
    <link href="/2022/03/22/VPP-Labs/"/>
    <url>/2022/03/22/VPP-Labs/</url>
    
    <content type="html"><![CDATA[<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><ul><li>Debian 10</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc g++ vim cmake curl wget ifconfig bridge-utils -y<br></code></pre></td></tr></table></figure><ul><li>repo添加</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -s https://packagecloud.io/install/repositories/fdio/release/script.deb.sh | sudo bash<br></code></pre></td></tr></table></figure><ul><li>安装VPP</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install vpp vpp-plugin-core vpp-plugin-dpdk -y<br><span class="hljs-comment"># 可选择的安装</span><br><span class="hljs-comment"># sudo apt-get install vpp vpp-plugin-core vpp-plugin-dpdk vpp-dbg vpp-dev vpp-ext-deps vpp-api-python vpp-api-java -y</span><br></code></pre></td></tr></table></figure><h1 id="正式实验"><a href="#正式实验" class="headerlink" title="正式实验"></a>正式实验</h1><h2 id="host-vpp连接实验"><a href="#host-vpp连接实验" class="headerlink" title="host-vpp连接实验"></a>host-vpp连接实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/interface.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/interface.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/03/22/20220322201107.jpeg" alt="Figure: Create Interface Topology"></p><p>根据如上的拓扑图，创建veth</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip <span class="hljs-built_in">link</span> add name vpp1out <span class="hljs-built_in">type</span> veth peer name vpp1host<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev vpp1out up<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev vpp1host up<br></code></pre></td></tr></table></figure><p>添加IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip addr add 10.10.1.1/24 dev vpp1host<br>ip addr show vpp1host<br></code></pre></td></tr></table></figure><p>创建vpp接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -eaf | grep vpp<br>sudo /usr/bin/vpp -c vpp1.conf<br></code></pre></td></tr></table></figure><p>vpp1.conf内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">unix <span class="hljs-punctuation">&#123;</span>cli-listen /run/vpp/cli-vpp1.sock<span class="hljs-punctuation">&#125;</span><br>api-segment <span class="hljs-punctuation">&#123;</span> prefix vpp1 <span class="hljs-punctuation">&#125;</span><br>plugins <span class="hljs-punctuation">&#123;</span> plugin dpdk_plugin.so <span class="hljs-punctuation">&#123;</span> disable <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>进入vpp1的shell界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vppctl -s /run/vpp/cli-vpp1.sock<br><span class="hljs-comment"># 创建接口</span><br>create host-interface name vpp1out<br>show hardware<br><span class="hljs-built_in">set</span> int state host-vpp1out up<br>show int<br><span class="hljs-comment"># 添加IP</span><br><span class="hljs-built_in">set</span> int ip address host-vpp1out 10.10.1.2/24<br>show int addr<br><br></code></pre></td></tr></table></figure><p>到此就完成了上述的创建链接的实验。</p><h2 id="trace-实验"><a href="#trace-实验" class="headerlink" title="trace 实验"></a>trace 实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/traces.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/traces.html</a></p><p>本实验沿用创建链接实验的环境，基本的trace命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看跟踪的buffer[max COUNT]</span><br>show trace<br><span class="hljs-comment"># 清除跟踪的buffer并且释放内存</span><br>clear trace<br><span class="hljs-comment"># 添加跟踪</span><br>trace add af-packet-input 10<br><span class="hljs-comment"># 可以跟踪的内容查看上述的链接</span><br></code></pre></td></tr></table></figure><h3 id="host2vpp"><a href="#host2vpp" class="headerlink" title="host2vpp"></a>host2vpp</h3><p>在vpp1的shell内选择上述跟踪的内容，在host上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping -c 1 10.10.1.2<br></code></pre></td></tr></table></figure><p>然后回到vpp1的shell内查看跟踪情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show trace<br>clear trace<br></code></pre></td></tr></table></figure><h3 id="vpp2host"><a href="#vpp2host" class="headerlink" title="vpp2host"></a>vpp2host</h3><p>在vpp1的shell内执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping 10.10.1.1<br>show trace<br></code></pre></td></tr></table></figure><h3 id="ARP-Table"><a href="#ARP-Table" class="headerlink" title="ARP Table"></a>ARP Table</h3><p>在vpp1的shell内：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">show</span> ip <span class="hljs-built_in">neighbors</span><br></code></pre></td></tr></table></figure><h3 id="Routing-Table"><a href="#Routing-Table" class="headerlink" title="Routing Table"></a>Routing Table</h3><p>在vpp1的shell内：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">show ip fib<br></code></pre></td></tr></table></figure><h2 id="连接两个VPP实例实验"><a href="#连接两个VPP实例实验" class="headerlink" title="连接两个VPP实例实验"></a>连接两个VPP实例实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/twovppinstances.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/twovppinstances.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/03/22/20220322201119.png" alt="Connect two FD.io VPP topology"></p><h3 id="vpp2-sock-创建"><a href="#vpp2-sock-创建" class="headerlink" title="vpp2.sock 创建"></a>vpp2.sock 创建</h3><p>本实验同样沿用vpp1的配置，我们类比创建vpp2链接，配置文件如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">unix &#123;cli-listen /run/vpp/cli-vpp2.sock&#125;<br>api-segment &#123; prefix vpp2 &#125;<br>plugins &#123; plugin dpdk_plugin.so &#123; <span class="hljs-built_in">disable</span> &#125; &#125;<br></code></pre></td></tr></table></figure><p>在host上执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vpp -c vpp2.conf<br></code></pre></td></tr></table></figure><p>进入vpp2的shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#host执行</span><br>sudo vppctl -s /run/vpp/cli-vpp2.sock<br><span class="hljs-comment">#vpp shell执行</span><br>show version<br>quit<br></code></pre></td></tr></table></figure><h3 id="memif接口创建"><a href="#memif接口创建" class="headerlink" title="memif接口创建"></a>memif接口创建</h3><p>在vpp1端创建memif接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host执行</span><br>sudo vppctl -s /run/vpp/cli-vpp1.sock<br><span class="hljs-comment"># vpp shell执行</span><br>create interface memif <span class="hljs-built_in">id</span> 0 master<br><span class="hljs-built_in">set</span> int state memif0/0 up<br><span class="hljs-built_in">set</span> int ip address memif0/0 10.10.2.1/24<br></code></pre></td></tr></table></figure><p>在vpp2端创建memif端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host执行</span><br>sudo vppctl -s /run/vpp/cli-vpp2.sock<br><span class="hljs-comment"># vpp shell执行</span><br>create interface memif <span class="hljs-built_in">id</span> 0 slave<br><span class="hljs-built_in">set</span> int state memif0/0 up<br><span class="hljs-built_in">set</span> int ip address memif0/0 10.10.2.2/24<br><br></code></pre></td></tr></table></figure><p>在vpp1端ping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vpp1 shell执行</span><br>ping 10.10.2.2<br></code></pre></td></tr></table></figure><p>在vpp2端ping</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vpp2 shell执行</span><br>ping 10.10.2.1<br></code></pre></td></tr></table></figure><h2 id="路由实验"><a href="#路由实验" class="headerlink" title="路由实验"></a>路由实验</h2><p>实验链接：<a href="https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/routing.html">https://s3-docs.fd.io/vpp/22.06/gettingstarted/progressivevpp/routing.html</a></p><p><img src="https://imgs.bencorn.com/imgs/2022/03/22/20220322201125.png" alt="Connect two FD.io VPP topology"></p><p>实验沿用之前的环境，设置host上的路由</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo ip route add 10.10.2.0/24 via 10.10.1.2<br>ip route<br></code></pre></td></tr></table></figure><p>在vpp2上设置返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip route add 10.10.1.0/24  via 10.10.2.1<br></code></pre></td></tr></table></figure><p>在host上ping vpp2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ping 10.10.2.2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project 1 Buffer Pool Manager</title>
    <link href="/2022/02/25/Project-1-Buffer-Pool-Manager/"/>
    <url>/2022/02/25/Project-1-Buffer-Pool-Manager/</url>
    
    <content type="html"><![CDATA[<h3 id="Lab-2-Summary"><a href="#Lab-2-Summary" class="headerlink" title="Lab 2 Summary"></a>Lab 2 Summary</h3><p> cmu15445第二个项目是关于在内存中实现buffer pool的，通过实现三个部分来加深对缓冲池的实现机制的理解，分别是LRU算法实现frame管理，单个buffer pool的管理，并行多个buffer pool的管理。</p><p> 实验地址：<a href="https://15445.courses.cs.cmu.edu/fall2021/project1/#buffer-pool-instance">https://15445.courses.cs.cmu.edu/fall2021/project1/#buffer-pool-instance</a></p><p> 首先谈一谈对整个page在磁盘和内存中的进出过程，理解到这些各部分过后，后续的实验就很好理解了；</p><p> 1、首先就是说DBMS不是直接去disk里拿到存储页儿，这个点儿但凡开始看这个课应该都可以理解；</p><p> 2、当执行某条SQL语句的时候，执行引擎先是去内存中的buffer pool里获取该页儿，这个时候会发生两种情况：</p><ul><li>当buffer pool内存在该页儿的时候，首先我们知道对页儿操作有两种，读和写，<code>但是写仍然是对于内存中buffer内的frame的修改，因此当多个线程操作的时候，有可能该缓存内的页儿没有写到disk内，因此这个时候该该页儿可能是dirty page</code>，所以这个时候就检测，如果该页儿时脏页儿，就先写回disk，然后再进行该页儿的操作，具体的操作由上层决定，返回指向该page的指针；</li><li>当buffer pool内不存在该页儿的时候，这个时候，buffer pool manager会从disk manager内从disk读取需要的page，然后缓存到buffer pool内，缓存进来过后，返回指向该page的指针给执行引擎；</li></ul><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170529.png" alt="DBMS Gets Page"></p><p> 3、如何管理好buffer pool内存中页儿的换进换出，通过策略性的控制，实现线程安全的线程控制：</p><ul><li>buffer pool：内存中的frame数组</li><li>page table：map[page_id] &#x3D; frame_id，page和frame的哈希表</li><li>replacer：控制页儿的置换与否</li><li>pin&#x2F;reference counter：正在使用该page的thread，pin_count为0的才会写回disk</li></ul><p> 当操作某个页儿的时候，不管是添加还是删除，还是从磁盘读取都要对该page进行pin操作，也就是说当前的页再被线程操作，不可以置换，而且这样的操作是原子的，因此得需要进行上锁。</p><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170604.png" alt="Buffer Pool Manager"></p><h3 id="LRU-Replacement-Policy"><a href="#LRU-Replacement-Policy" class="headerlink" title="LRU Replacement Policy"></a>LRU Replacement Policy</h3><h4 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h4><p> LRU置换算法，把使用频率最低的置换出去，体现在数据结构上就是队列的队尾给去掉，使用某个页儿时加入到队列的对头，当然再加入的时候得检测队列的大小是否超过容量；<code>LRUReplacer管理的是frame_id也就是确定buffer pool内的page是否可以被置换</code>，当我们把某些页儿给LRUReplacer时，通过lru策略管理他什么时候置换出去，而lru通过自身的算法优势来确定要victim哪些页儿；</p><ul><li>Victim：从buffer pool中置换出某个frame，victim要与buffer pool manager配合使用来置换页儿；</li><li>Pin：page有一个pin_count的数据结构来表示是否被线程使用，因此当某个page被pin的时候，表示正在被线程使用不可以被置换，因此对应到LRU就是这个page对应的frame不应该在可以被置换的队列内；</li><li>Unpin：该页儿可以被置换出去，因此将该page对应的frame加入可被置换的队列内，如果本身在的话就不用管了；</li></ul><p> LRU这个部分总结起来就是，这个部分是一种策略性的东西，是buffer pool manager的一个步骤，自身无法操作page那些的。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><h5 id="TODO-1-data-structure"><a href="#TODO-1-data-structure" class="headerlink" title="TODO 1 data structure"></a>TODO 1 data structure</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br> <span class="hljs-comment">// TODO(student): implement me!</span><br> std::mutex lru_latch_;<br> <span class="hljs-type">size_t</span> num_pages_;<br> std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; lru_list_;<br> std::unordered_map&lt;<span class="hljs-type">frame_id_t</span>, std::list&lt;<span class="hljs-type">frame_id_t</span>&gt;::iterator&gt; lru_map_&#123;&#125;;<br></code></pre></td></tr></table></figure><h5 id="TODO-2-constructor-and-destructor"><a href="#TODO-2-constructor-and-destructor" class="headerlink" title="TODO 2 constructor and destructor"></a>TODO 2 constructor and destructor</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">LRUReplacer::<span class="hljs-built_in">LRUReplacer</span>(<span class="hljs-type">size_t</span> num_pages) &#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  num_pages_ = num_pages;<br>&#125;<br><br>LRUReplacer::~<span class="hljs-built_in">LRUReplacer</span>() &#123;<br><span class="hljs-comment">// std::lock_guard&lt;std::mutex&gt; lock_guard(lru_latch_);</span><br>    <span class="hljs-comment">// 我人傻了，搞了2天，好蠢~~~</span><br>  lru_list_.<span class="hljs-built_in">clear</span>();<br>  lru_map_.<span class="hljs-built_in">clear</span>();<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="TODO-3-Victim"><a href="#TODO-3-Victim" class="headerlink" title="TODO 3 Victim"></a>TODO 3 Victim</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LRUReplacer::Victim</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> *frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (lru_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  *frame_id = lru_list_.<span class="hljs-built_in">back</span>();<br>  lru_map_.<span class="hljs-built_in">erase</span>(*frame_id);<br>  lru_list_.<span class="hljs-built_in">pop_back</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-4-Pin"><a href="#TODO-4-Pin" class="headerlink" title="TODO 4 Pin"></a>TODO 4 Pin</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LRUReplacer::Pin</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  <span class="hljs-keyword">auto</span> item = lru_map_.<span class="hljs-built_in">find</span>(frame_id);<br>  <span class="hljs-keyword">if</span> (item == lru_map_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  lru_list_.<span class="hljs-built_in">erase</span>(item-&gt;second);<br>  lru_map_.<span class="hljs-built_in">erase</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-5-Unpin"><a href="#TODO-5-Unpin" class="headerlink" title="TODO 5 Unpin"></a>TODO 5 Unpin</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LRUReplacer::Unpin</span><span class="hljs-params">(<span class="hljs-type">frame_id_t</span> frame_id)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(lru_latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (lru_list_.<span class="hljs-built_in">size</span>() &gt;= num_pages_) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (lru_map_.<span class="hljs-built_in">count</span>(frame_id) != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  lru_list_.<span class="hljs-built_in">push_front</span>(frame_id);<br>  lru_map_[frame_id] = lru_list_.<span class="hljs-built_in">begin</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make lru_replacer_test<br>./test/lru_replacer_test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170502.png" alt="LRU 本地测试"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --leak-check=full --suppressions=../build_support/valgrind.supp ./test/lru_replacer_test --gtest_filter=LRUReplacerTest.SimplePageTest<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170438.png" alt="LRU 内存检测"></p><h3 id="Buffer-Pool-Manager-Instance"><a href="#Buffer-Pool-Manager-Instance" class="headerlink" title="Buffer Pool Manager Instance"></a>Buffer Pool Manager Instance</h3><h4 id="个人理解-1"><a href="#个人理解-1" class="headerlink" title="个人理解"></a>个人理解</h4><p> Buffer Pool Manager主要实现几个功能，向disk写新的page，从disk里fetch page，刷新page等，这个部分千万千万反复看视频和PPT，当对page进行内容操作的时候会对该page进行pin，跟PPT上所说的一样。</p><h4 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h4><h5 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h5><h6 id="page-h"><a href="#page-h" class="headerlink" title="page.h"></a>page.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br> <span class="hljs-comment">/** Zeroes out the data that is held within the page. */</span><br> <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">ResetMemory</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">memset</span>(data_, OFFSET_PAGE_START, PAGE_SIZE); &#125;<br><br> <span class="hljs-comment">/** The actual data that is stored within a page. */</span><br> <span class="hljs-type">char</span> data_[PAGE_SIZE]&#123;&#125;;<br> <span class="hljs-comment">/** The ID of this page. */</span><br> <span class="hljs-type">page_id_t</span> page_id_ = INVALID_PAGE_ID;<br> <span class="hljs-comment">/** The pin count of this page. */</span><br> <span class="hljs-type">int</span> pin_count_ = <span class="hljs-number">0</span>;<br> <span class="hljs-comment">/** True if the page is dirty, i.e. it is different from its corresponding page on disk. */</span><br> <span class="hljs-type">bool</span> is_dirty_ = <span class="hljs-literal">false</span>;<br> <span class="hljs-comment">/** Page latch. */</span><br> ReaderWriterLatch rwlatch_;<br></code></pre></td></tr></table></figure><h6 id="buffer-pool-manager-instance-h"><a href="#buffer-pool-manager-instance-h" class="headerlink" title="buffer_pool_manager_instance.h"></a>buffer_pool_manager_instance.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/** Number of pages in the buffer pool. */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> pool_size_;<br>  <span class="hljs-comment">/** How many instances are in the parallel BPM (if present, otherwise just 1 BPI) */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> num_instances_ = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">/** Index of this BPI in the parallel BPM (if present, otherwise just 0) */</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> instance_index_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/** Each BPI maintains its own counter for page_ids to hand out, must ensure they mod back to its instance_index_ */</span><br>  std::atomic&lt;<span class="hljs-type">page_id_t</span>&gt; next_page_id_ = instance_index_;<br><br>  <span class="hljs-comment">/** Array of buffer pool pages. */</span><br>  Page *pages_;<br>  <span class="hljs-comment">/** Pointer to the disk manager. */</span><br>  DiskManager *disk_manager_ __attribute__((__unused__));<br>  <span class="hljs-comment">/** Pointer to the log manager. */</span><br>  LogManager *log_manager_ __attribute__((__unused__));<br>  <span class="hljs-comment">/** Page table for keeping track of buffer pool pages. */</span><br>  std::unordered_map&lt;<span class="hljs-type">page_id_t</span>, <span class="hljs-type">frame_id_t</span>&gt; page_table_;<br>  <span class="hljs-comment">/** Replacer to find unpinned pages for replacement. */</span><br>  Replacer *replacer_;<br>  <span class="hljs-comment">/** List of free pages. */</span><br>  std::list&lt;<span class="hljs-type">frame_id_t</span>&gt; free_list_;<br>  <span class="hljs-comment">/** This latch protects shared data structures. We recommend updating this comment to describe what it protects. */</span><br>  std::mutex latch_;<br></code></pre></td></tr></table></figure><h6 id="disk-manager-h"><a href="#disk-manager-h" class="headerlink" title="disk_manager.h"></a>disk_manager.h</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Write a page to the database file.</span><br><span class="hljs-comment"> * @param page_id id of the page</span><br><span class="hljs-comment"> * @param page_data raw page data</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WritePage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *page_data)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Read a page from the database file.</span><br><span class="hljs-comment"> * @param page_id id of the page</span><br><span class="hljs-comment"> * @param[out] page_data output buffer</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReadPage</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">char</span> *page_data)</span></span>;<br></code></pre></td></tr></table></figure><h5 id="TODO-1-FlushPgImp"><a href="#TODO-1-FlushPgImp" class="headerlink" title="TODO 1 FlushPgImp"></a>TODO 1 FlushPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BufferPoolManagerInstance::FlushPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Make sure you call DiskManager::WritePage!</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">if</span> (page_id == INVALID_PAGE_ID) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item == page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id = item-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-2-FlushAllPgsImp"><a href="#TODO-2-FlushAllPgsImp" class="headerlink" title="TODO 2 FlushAllPgsImp"></a>TODO 2 FlushAllPgsImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BufferPoolManagerInstance::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// You can do it!</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : page_table_) &#123;<br>    <span class="hljs-type">frame_id_t</span> frame_id = item.second;<br>    Page *page = &amp;pages_[frame_id];<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-3-NewPgImp"><a href="#TODO-3-NewPgImp" class="headerlink" title="TODO 3 NewPgImp"></a>TODO 3 NewPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call AllocatePage!</span><br>  <span class="hljs-comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span><br>  <span class="hljs-comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span><br>  <span class="hljs-comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span><br>  <span class="hljs-comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id;<br>  Page *page = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">if</span> (!free_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    frame_id = free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>    page = &amp;pages_[frame_id];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frame_id)) &#123;<br>    page = &amp;pages_[frame_id];<br>    <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    &#125;<br>    page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-type">page_id_t</span> new_page_id = <span class="hljs-built_in">AllocatePage</span>();<br>  page-&gt;page_id_ = new_page_id;<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>  page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br><br>  page_table_[page-&gt;<span class="hljs-built_in">GetPageId</span>()] = frame_id;<br>  *page_id = page-&gt;<span class="hljs-built_in">GetPageId</span>();<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br><br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-4-FetchPgImp"><a href="#TODO-4-FetchPgImp" class="headerlink" title="TODO 4 FetchPgImp"></a>TODO 4 FetchPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">BufferPoolManagerInstance::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 1.     Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.1    If P exists, pin it and return it immediately.</span><br>  <span class="hljs-comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span><br>  <span class="hljs-comment">//        Note that pages are always found from the free list first.</span><br>  <span class="hljs-comment">// 2.     If R is dirty, write it back to the disk.</span><br>  <span class="hljs-comment">// 3.     Delete R from the page table and insert P.</span><br>  <span class="hljs-comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span><br><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-type">frame_id_t</span> frame_id;<br>  Page *page = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item != page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    frame_id = item-&gt;second;<br>    page = &amp;pages_[frame_id];<br>    page-&gt;pin_count_++;<br>    replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>    <span class="hljs-keyword">return</span> page;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!free_list_.<span class="hljs-built_in">empty</span>()) &#123;<br>    frame_id = free_list_.<span class="hljs-built_in">front</span>();<br>    free_list_.<span class="hljs-built_in">pop_front</span>();<br>    page = &amp;pages_[frame_id];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (replacer_-&gt;<span class="hljs-built_in">Victim</span>(&amp;frame_id)) &#123;<br>    page = &amp;pages_[frame_id];<br>    <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>      disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>    &#125;<br>    page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  page-&gt;page_id_ = page_id;<br>  page-&gt;pin_count_ = <span class="hljs-number">1</span>;<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  disk_manager_-&gt;<span class="hljs-built_in">ReadPage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>  page_table_[page-&gt;<span class="hljs-built_in">GetPageId</span>()] = frame_id;<br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br><br>  <span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-5-DeletePgImp"><a href="#TODO-5-DeletePgImp" class="headerlink" title="TODO 5 DeletePgImp"></a>TODO 5 DeletePgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BufferPoolManagerInstance::DeletePgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// 0.   Make sure you call DeallocatePage!</span><br>  <span class="hljs-comment">// 1.   Search the page table for the requested page (P).</span><br>  <span class="hljs-comment">// 1.   If P does not exist, return true.</span><br>  <span class="hljs-comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span><br>  <span class="hljs-comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span><br><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br><br>  <span class="hljs-built_in">DeallocatePage</span>(page_id);<br><br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item == page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id = item-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">GetPinCount</span>() != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">IsDirty</span>()) &#123;<br>    disk_manager_-&gt;<span class="hljs-built_in">WritePage</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>(), page-&gt;<span class="hljs-built_in">GetData</span>());<br>  &#125;<br><br>  replacer_-&gt;<span class="hljs-built_in">Pin</span>(frame_id);<br>  page_table_.<span class="hljs-built_in">erase</span>(page-&gt;<span class="hljs-built_in">GetPageId</span>());<br>  page-&gt;pin_count_ = <span class="hljs-number">0</span>;<br>  page-&gt;is_dirty_ = <span class="hljs-literal">false</span>;<br>  page-&gt;<span class="hljs-built_in">ResetMemory</span>();<br>  page-&gt;page_id_ = INVALID_PAGE_ID;<br>  free_list_.<span class="hljs-built_in">push_back</span>(frame_id);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-6-UnpinPgImp"><a href="#TODO-6-UnpinPgImp" class="headerlink" title="TODO 6 UnpinPgImp"></a>TODO 6 UnpinPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">BufferPoolManagerInstance::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(latch_)</span></span>;<br>  <span class="hljs-keyword">auto</span> item = page_table_.<span class="hljs-built_in">find</span>(page_id);<br>  <span class="hljs-keyword">if</span> (item == page_table_.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-type">frame_id_t</span> frame_id = item-&gt;second;<br>  Page *page = &amp;pages_[frame_id];<br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">GetPinCount</span>() &lt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  page-&gt;pin_count_--;<br>  <span class="hljs-keyword">if</span> (is_dirty) &#123;<br>    page-&gt;is_dirty_ = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (page-&gt;<span class="hljs-built_in">GetPinCount</span>() &lt;= <span class="hljs-number">0</span>) &#123;<br>    replacer_-&gt;<span class="hljs-built_in">Unpin</span>(frame_id);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make buffer_pool_manager_instance_test<br>./test/buffer_pool_manager_instance_test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170639.png" alt="Buffer Pool Manager Instance 本地测试"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --leak-check=full --suppressions=../build_support/valgrind.supp ./test/buffer_pool_manager_instance_test --gtest_filter=BufferPoolManagerInstanceTest.BinaryDataTest:BufferPoolManagerInstanceTest.SampleTest<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170659.png" alt="Buffer Pool Manager Instance内存检测"></p><h3 id="Parallel-Buffer-Pool-Manager"><a href="#Parallel-Buffer-Pool-Manager" class="headerlink" title="Parallel Buffer Pool Manager"></a>Parallel Buffer Pool Manager</h3><h4 id="个人理解-2"><a href="#个人理解-2" class="headerlink" title="个人理解"></a>个人理解</h4><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228175932.png" alt="multiple buffer pools"></p><p> 并行buffer pool manager，这个部分其实是想让我们实现一个并行的数据库优化，也就是四个数据库优化中的第一个，multiple buffer pools，估计后边儿的实验老师会围绕这几个优化分别进行项目的制作，太牛b啊，这个部分的实现是采用了第二个Hash的方式来实现对每一个page的分配，也就是说当我们拿到一个page的时候，根据page_id来确定该page保存在那个buffer pool，注意：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">page_id_t</span> <span class="hljs-title">BufferPoolManagerInstance::AllocatePage</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">page_id_t</span> next_page_id = next_page_id_;<br>  next_page_id_ += num_instances_;<br>  <span class="hljs-built_in">ValidatePageId</span>(next_page_id);<br>  <span class="hljs-keyword">return</span> next_page_id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BufferPoolManagerInstance::ValidatePageId</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">page_id_t</span> page_id)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-built_in">assert</span>(page_id % num_instances_ == instance_index_);  <span class="hljs-comment">// allocated pages mod back to this BPI</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 通过观察上述的代码跟踪，可以分析得出，每次对page_id的分配就是对其进行hash取模来判断是存在哪个pool；然后为了达到并行，我们直接每个函数内操作该buffer pool instance内地数据就好了，其他的就是分配页儿的策略了，看如何达到比较好的性能，哈哈哈我不会，我就每次newpage的时候去每个instance挨个找，性能可能会极差。</p><h4 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h4><h5 id="TODO-1-Structure"><a href="#TODO-1-Structure" class="headerlink" title="TODO 1 Structure"></a>TODO 1 Structure</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">private</span>:<br> std::mutex parallel_buffer_pool_latch_;<br> <span class="hljs-type">size_t</span> num_instance_;<br> <span class="hljs-type">size_t</span> pool_size_;<br> <span class="hljs-type">size_t</span> start_index_;<br> std::vector&lt;BufferPoolManagerInstance *&gt; buffer_pool_manager_;<br></code></pre></td></tr></table></figure><h5 id="TODO-2-Constructor"><a href="#TODO-2-Constructor" class="headerlink" title="TODO 2 Constructor"></a>TODO 2 Constructor</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">ParallelBufferPoolManager::<span class="hljs-built_in">ParallelBufferPoolManager</span>(<span class="hljs-type">size_t</span> num_instances, <span class="hljs-type">size_t</span> pool_size, DiskManager *disk_manager,<br>                                                     LogManager *log_manager) &#123;<br>  <span class="hljs-comment">// Allocate and create individual BufferPoolManagerInstances</span><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(parallel_buffer_pool_latch_)</span></span>;<br>  num_instance_ = num_instances;<br>  pool_size_ = pool_size;<br>  start_index_ = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instance_; ++i) &#123;<br>    buffer_pool_manager_.<span class="hljs-built_in">push_back</span>(<br>        <span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferPoolManagerInstance</span>(pool_size_, num_instance_, i, disk_manager, log_manager));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-3-Destructor"><a href="#TODO-3-Destructor" class="headerlink" title="TODO 3 Destructor"></a>TODO 3 Destructor</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Update constructor to destruct all BufferPoolManagerInstances and deallocate any associated memory</span><br>ParallelBufferPoolManager::~<span class="hljs-built_in">ParallelBufferPoolManager</span>() &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instance_; ++i) &#123;<br>    <span class="hljs-keyword">delete</span> buffer_pool_manager_[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-4-GetPoolSize"><a href="#TODO-4-GetPoolSize" class="headerlink" title="TODO 4 GetPoolSize"></a>TODO 4 GetPoolSize</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">ParallelBufferPoolManager::GetPoolSize</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// Get size of all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">return</span> pool_size_ * num_instances_;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-5-GetBufferPoolManager"><a href="#TODO-5-GetBufferPoolManager" class="headerlink" title="TODO 5 GetBufferPoolManager"></a>TODO 5 GetBufferPoolManager</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">BufferPoolManager *<span class="hljs-title">ParallelBufferPoolManager::GetBufferPoolManager</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Get BufferPoolManager responsible for handling given page id. You can use this method in your other methods.</span><br>  <span class="hljs-keyword">return</span> buffer_pool_manager_[page_id % num_instance_];<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="TODO-6-FetchPgImp"><a href="#TODO-6-FetchPgImp" class="headerlink" title="TODO 6 FetchPgImp"></a>TODO 6 FetchPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::FetchPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Fetch page for page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">FetchPage</span>(page_id);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-7-UnpinPgImp"><a href="#TODO-7-UnpinPgImp" class="headerlink" title="TODO 7 UnpinPgImp"></a>TODO 7 UnpinPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::UnpinPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id, <span class="hljs-type">bool</span> is_dirty)</span> </span>&#123;<br>  <span class="hljs-comment">// Unpin page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">UnpinPage</span>(page_id, is_dirty);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-8-FlushPgImp"><a href="#TODO-8-FlushPgImp" class="headerlink" title="TODO 8 FlushPgImp"></a>TODO 8 FlushPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::FlushPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Flush page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">FlushPage</span>(page_id);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-9-NewPgImp"><a href="#TODO-9-NewPgImp" class="headerlink" title="TODO 9 NewPgImp"></a>TODO 9 NewPgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Page *<span class="hljs-title">ParallelBufferPoolManager::NewPgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> *page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// create new page. We will request page allocation in a round robin manner from the underlying</span><br>  <span class="hljs-comment">// BufferPoolManagerInstances</span><br>  <span class="hljs-comment">// 1.   From a starting index of the BPMIs, call NewPageImpl until either 1) success and return 2) looped around to</span><br>  <span class="hljs-comment">// starting index and return nullptr</span><br>  <span class="hljs-comment">// 2.   Bump the starting index (mod number of instances) to start search at a different BPMI each time this function</span><br>  <span class="hljs-comment">// is called</span><br><br>  <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_guard</span><span class="hljs-params">(parallel_buffer_pool_latch_)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = start_index_; i &lt; start_index_ + num_instance_; ++i) &#123;<br>    BufferPoolManager *manager = buffer_pool_manager_[i % num_instance_];<br>    Page *page = manager-&gt;<span class="hljs-built_in">NewPage</span>(page_id);<br>    <span class="hljs-keyword">if</span> (page != <span class="hljs-literal">nullptr</span>) &#123;<br>      start_index_ = (i + <span class="hljs-number">1</span>) % num_instance_;<br>      <span class="hljs-keyword">return</span> page;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-10-DeletePgImp"><a href="#TODO-10-DeletePgImp" class="headerlink" title="TODO 10 DeletePgImp"></a>TODO 10 DeletePgImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ParallelBufferPoolManager::DeletePgImp</span><span class="hljs-params">(<span class="hljs-type">page_id_t</span> page_id)</span> </span>&#123;<br>  <span class="hljs-comment">// Delete page_id from responsible BufferPoolManagerInstance</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">GetBufferPoolManager</span>(page_id)-&gt;<span class="hljs-built_in">DeletePage</span>(page_id);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="TODO-11-FlushAllPgsImp"><a href="#TODO-11-FlushAllPgsImp" class="headerlink" title="TODO 11 FlushAllPgsImp"></a>TODO 11 FlushAllPgsImp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ParallelBufferPoolManager::FlushAllPgsImp</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// flush all pages from all BufferPoolManagerInstances</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; num_instance_; ++i) &#123;<br>    buffer_pool_manager_[i]-&gt;<span class="hljs-built_in">FlushAllPages</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Test-2"><a href="#Test-2" class="headerlink" title="Test"></a>Test</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make parallel_buffer_pool_manager_test<br>./test/parallel_buffer_pool_manager_test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170750.png" alt="Parallel Buffer Pool Manager 本地测试"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">valgrind --leak-check=full --suppressions=../build_support/valgrind.supp ./test/parallel_buffer_pool_manager_test --gtest_filter=ParallelBufferPoolManagerTest.BinaryDataTest:ParallelBufferPoolManagerTest.Sample<br>Test<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170817.png" alt="Parallel Buffer Pool Manager 内存测试"></p><h4 id="Gradescope"><a href="#Gradescope" class="headerlink" title="Gradescope"></a>Gradescope</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">make format<br>make check-lint<br>make check-clang-tidy<br><br>zip project1-submission.zip \<br>   src/include/buffer/lru_replacer.h \<br>   src/buffer/lru_replacer.cpp \<br>   src/include/buffer/buffer_pool_manager_instance.h \<br>   src/buffer/buffer_pool_manager_instance.cpp \<br>   src/include/buffer/parallel_buffer_pool_manager.h \<br>   src/buffer/parallel_buffer_pool_manager.cpp<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2022/02/28/20220228170844.png" alt="Gradescope"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p> 仿佛打开新世界的大门啊，嗯怎么说，总结几点需要注意的吧：</p><ul><li>LRU的析构函数（其他的也是）还是手动释放一下内存比较好，但是不要愚蠢</li><li>并行buffer pool的页分配，参照代码注释采用轮询的时候，可以考虑分配的更加均匀，反正我是上一次分配buffer pool的下一个来，挨着来找；可能一开始会比较均匀，但是最终由于读取那些page每个被访问的概率不一样，其实这也是假想的负载均衡，反正我象不太清楚，能大概的做一个global policy就好了，达到目的</li><li>然后就是反复看视频和PPT，加深理解</li></ul><p> 行，基本Over，继续学习，太菜了~</p>]]></content>
    
    
    <categories>
      
      <category>CMU15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sdn network orders</title>
    <link href="/2022/01/22/sdn-network-orders/"/>
    <url>/2022/01/22/sdn-network-orders/</url>
    
    <content type="html"><![CDATA[<h1 id="OVS"><a href="#OVS" class="headerlink" title="OVS"></a>OVS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">ovs-vsctl add-br br0<br>ovs-vsctl add-port veth0<br>ovs-vsctl del-port veth0<br>ovs-vsctl show<br><br>ovs-appctl fdb/show br0<br><br>ovs-ofctl dump-flows br0<br>ovs-ofctl add-flow br0 action=normal (普通交换机)<br>ovs-ofctl add-flow br0 input:veth0,action=output:veth1 (端口)<br></code></pre></td></tr></table></figure><h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-img create -f qcow2 imagename.qcow2 10G<br>qemu-system-x86_64 -m 2048 —enable-kvm <br>Linux 开kvm是 —enable-kvm ，mac是 accel=hvf<br></code></pre></td></tr></table></figure><h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns <span class="hljs-built_in">ls</span><br>ip netns add user1-namespace<br>ip netns <span class="hljs-built_in">exec</span> ns-name bash-command<br></code></pre></td></tr></table></figure><h1 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip <span class="hljs-built_in">link</span> <br>ip <span class="hljs-built_in">link</span> add<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev devicename master brname<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev devicename up<br>ip address add 10.0.14.3/24 dev devicename<br>ip <span class="hljs-built_in">link</span> add veth0 <span class="hljs-built_in">type</span> veth peer name veth1<br></code></pre></td></tr></table></figure><h1 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">brctl show<br>brctl addbr brname<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>qemu frequent usings</title>
    <link href="/2022/01/22/qemu-frequent-usings/"/>
    <url>/2022/01/22/qemu-frequent-usings/</url>
    
    <content type="html"><![CDATA[<h3 id="qemu-system-x86-64"><a href="#qemu-system-x86-64" class="headerlink" title="qemu-system-x86_64"></a>qemu-system-x86_64</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qemu">qemu-system-x86_64 -m 1024 --enbale-kvm -net nic,macaddr=11:22:33:44:55;66 -hda linux.img -cdrom debian.iso<br></code></pre></td></tr></table></figure><h3 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h3><p>​创建一个虚拟磁盘，raw&#x2F;qcow2两种格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qemu">qemu-img create -f qcow2 disk.img 1G<br></code></pre></td></tr></table></figure><h3 id="libguestfs-tools"><a href="#libguestfs-tools" class="headerlink" title="libguestfs-tools"></a>libguestfs-tools</h3><p>​调整盘的大小并拷贝进去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qemu">qemu-img create -f qcow2 newdisk.img 1G<br>virt-resize —expand /dev/sda1 olddisk.img newdisk.img<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>qemu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker bug collect</title>
    <link href="/2022/01/22/docker-bug-collect/"/>
    <url>/2022/01/22/docker-bug-collect/</url>
    
    <content type="html"><![CDATA[<ul><li>bug-1、You have reached your pull rate limit. You may increase the limit by authenticating and upgrading: <a href="https://www.docker.com/increase-rate-limits">https://www.docker.com/increase-rate-limits</a></li></ul><p>​检查docker的源的问题，然后尝试更换源来解决；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">cat</span> docker | grep <span class="hljs-string">&#x27;\\-\\-registry\\-mirror&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;&lt;https://hub-mirror.c.163.com&gt;&quot;</span>,<br>    <span class="hljs-string">&quot;&lt;https://mirror.baidubce.com&gt;&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后重启一下docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl daemon-reload<br>sudo systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li>bug-2 Error response from daemon: could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network</li></ul><p>​手动设置好当前的docker的网络，然后重新创建该节点就ok了</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker network create --subnet <span class="hljs-number">172.18</span>.<span class="hljs-number">0.1</span>/<span class="hljs-number">16</span> -d=bridge -o com.docker.network.bridge.enable_ip_masquerade=true -o com.docker.network.driver.mtu=<span class="hljs-number">1500</span> --ipv6 --subnet fc00:f853:ccd:e793::/<span class="hljs-number">64</span> kind<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPM build</title>
    <link href="/2022/01/22/rpm-build/"/>
    <url>/2022/01/22/rpm-build/</url>
    
    <content type="html"><![CDATA[<h1 id="1、rpmbuild-安装"><a href="#1、rpmbuild-安装" class="headerlink" title="1、rpmbuild 安装"></a>1、rpmbuild 安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install make<br>yum install gcc<br>yum install rpm-build<br>yum install rpmdevtools<br>rpmdev-setuptree<br><span class="hljs-comment"># 查看安装情况</span><br>rpmbuild --showrc | grep topdir<br></code></pre></td></tr></table></figure><h1 id="2、创建用户用于打包"><a href="#2、创建用户用于打包" class="headerlink" title="2、创建用户用于打包"></a>2、创建用户用于打包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#创建用户</span><br>useradd rpmuser <br>su - rpmuser <br><br><span class="hljs-comment">#定义工作目录(或车间)吧</span><br>vi ~/.rpmmacros <br>%_topdir   /home/rpmuser/rpmbuild    <span class="hljs-comment">##目录可以自定义 </span><br><br><span class="hljs-built_in">mkdir</span> ~/rpmbuild  <br><br><span class="hljs-comment">#在topdir下建立需要的目录</span><br><span class="hljs-built_in">cd</span> ~/rpmbuild  <br><span class="hljs-built_in">mkdir</span> -pv &#123;BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS&#125; <br></code></pre></td></tr></table></figure><h1 id="3、整理源码"><a href="#3、整理源码" class="headerlink" title="3、整理源码"></a>3、整理源码</h1><p>rpmbuild安装完成以后我门就需要将我们的源码放到 SOURCE 文件夹下。我门的源码可能是一个tar.gz 的包、也可能是几个文件。tar.gz源码包的名字格式应该为 helloword-1.0.0.tar.gz (其实就是名字-版本号.tar.gz)</p><h1 id="4、编写Spec"><a href="#4、编写Spec" class="headerlink" title="4、编写Spec"></a>4、编写Spec</h1><p>在SPECS文件夹下新建 xxx.spec 打包脚本，将源码编译打包成rpm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi  xxx.spec <br><br>Name:           hellorpm           <span class="hljs-comment">#名字为源码tar.gz 包的名字 </span><br>Version:        1.0.0             <span class="hljs-comment">#版本号，一定要与tar.gz包的一致哦 </span><br>Release:        1%&#123;?dist&#125;         <span class="hljs-comment">#释出号，也就是第几次制作rpm </span><br>Summary:       helloword   <span class="hljs-comment">#软件包简介，最好不要超过50字符 </span><br><br>License:        GPL                   <span class="hljs-comment">#许可，GPL还是BSD等  </span><br>URL:            <span class="hljs-comment">#可以写一个网址 </span><br>Packager:       abel <br>Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz   <br><span class="hljs-comment">#定义用到的source，也就是你的源码</span><br><br>BuildRoot:      %_topdir/BUILDROOT         <br><span class="hljs-comment">#这个是软件make install 的测试安装目录.</span><br><br>BuildRequires:  gcc,make                           <span class="hljs-comment">#制作过程中用到的软件包 </span><br>Requires:       python-apscheduler &gt;= 2.1.2-1.el7,python-daemon &gt;= 1.6-1.el7  <span class="hljs-comment">#软件运行依赖的软件包，也可以指定最低版本如 bash &gt;= 1.1.1 </span><br>%description                <span class="hljs-comment">#描述，随便写                 </span><br>%prep                          ＃打包开始                    <br>%setup -q                      <span class="hljs-comment">#这个作用静默模式解压并cd                               </span><br><br>%build              <span class="hljs-comment">#编译制作阶段，主要目的就是编译，如果不用编译就为空 </span><br>./configure \\                                     <br> %&#123;?_smp_mflags&#125;          <span class="hljs-comment">#make后面的意思是：如果就多处理器的话make时并行编译 </span><br><br>%install                        <span class="hljs-comment">#安装阶段                        </span><br><span class="hljs-built_in">rm</span> -rf %&#123;buildroot&#125;             <span class="hljs-comment">#先删除原来的安装的，如果你不是第一次安装的话 </span><br> <span class="hljs-built_in">cp</span> -rp %_topdir/BUILD/%&#123;name&#125;-%&#123;version&#125;/*  <span class="hljs-variable">$RPM_BUILD_ROOT</span> <br><span class="hljs-comment">#将需要需要打包的文件从BUILD 文件夹中拷贝到BUILDROOT文件夹下。</span><br><br><span class="hljs-comment">#下面的几步pre、post、preun、postun 没必要可以不写 </span><br>%pre        <span class="hljs-comment">#rpm安装前制行的脚本 </span><br><br>%post       <span class="hljs-comment">#安装后执行的脚本 </span><br><br>%preun      <span class="hljs-comment">#卸载前执行的脚本 </span><br><br>%postun     <span class="hljs-comment">#卸载后执行的脚本 </span><br><br>%clean <span class="hljs-comment">#清理段,删除buildroot </span><br><span class="hljs-built_in">rm</span> -rf %&#123;buildroot&#125; <br><br>%files  <span class="hljs-comment">#rpm要包含的文件 </span><br>%defattr (-,root,root,-)   <span class="hljs-comment">#设定默认权限，如果下面没有指定权限，则继承默认 </span><br>/etc/hello/word/helloword.c           <span class="hljs-comment">#将你需要打包的文件或目录写下来</span><br><br><span class="hljs-comment">###  7.chagelog section  改变日志段 </span><br>%changelog<br></code></pre></td></tr></table></figure><h1 id="5、打包"><a href="#5、打包" class="headerlink" title="5、打包"></a>5、打包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpmbuild  <br>-ba 既生成src.rpm又生成二进制rpm <br>-bs 只生成src的rpm <br>-bb 只生二进制的rpm <br>-bp 执行到pre <br>-bc 执行到 build段 <br>-bi 执行install段 <br>-bl 检测有文件没包含<br></code></pre></td></tr></table></figure><h1 id="6、bugfix"><a href="#6、bugfix" class="headerlink" title="6、bugfix"></a>6、bugfix</h1><ul><li>rpmbuild: Empty %files file debugsourcefiles.list</li></ul><p>解决方法：在gcc的时候添加-g选项生成debuginfo信息</p><p><a href="https://bugzilla.redhat.com/show_bug.cgi?id=1583329">https://bugzilla.redhat.com/show_bug.cgi?id=1583329</a></p><h1 id="7、demo测试"><a href="#7、demo测试" class="headerlink" title="7、demo测试"></a>7、demo测试</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul><li>main.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span> <span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Test Main\\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Makefile</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>OBJS = main.c<br><span class="hljs-section">main: $&#123;OBJS&#125;</span><br>            gcc -g -o main $&#123;OBJS&#125;<br><span class="hljs-section">install:</span><br>            install -m 755 main <span class="hljs-variable">$(RPM_INSTALL_ROOT)</span>/usr/local/bin/main<br></code></pre></td></tr></table></figure><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">mkdir ~/rpmbuild<br>cd ~/rpmbuild<br>mkdir -p BUILD SPECS RPMS SOURCES SRPMS<br></code></pre></td></tr></table></figure><h2 id="创建main-0-1-spec"><a href="#创建main-0-1-spec" class="headerlink" title="创建main-0.1.spec"></a>创建main-0.1.spec</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs perl">Summary: test rpm<br>Name: main<br>Version: <span class="hljs-number">0</span>.<span class="hljs-number">1</span><br>Release: <span class="hljs-number">1</span><br>License: GPL<br>Group: NONE<br>Source: main-<span class="hljs-number">0</span>.<span class="hljs-number">1</span>.tar.gz<br>Url: &lt;http:<span class="hljs-regexp">//</span>www.bencorn.com&gt;<br>Packager: Lin<br>BuildRoot: %&#123;_tmppath&#125;/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root<br><br>%description<br>exercise: how to <span class="hljs-keyword">use</span>  rpm <span class="hljs-keyword">and</span> rpmbuild<br><br>%prep<br>%setup -<span class="hljs-keyword">q</span><br><br>%build<br>make<br><br>%install<br>rm -rf %&#123;buildroot&#125;<br><span class="hljs-keyword">mkdir</span> -p %&#123;buildroot&#125;/usr/<span class="hljs-keyword">local</span>/bin<br>make install RPM_INSTALL_ROOT=%&#123;buildroot&#125;<br><br>%files<br>/usr/<span class="hljs-keyword">local</span>/bin/main<br><br>%changelog<br>* Sun Aug  <span class="hljs-number">1</span> <span class="hljs-number">23</span>:<span class="hljs-number">13</span>:<span class="hljs-number">44</span> EDT <span class="hljs-number">2021</span> bencorn &lt;<span class="hljs-number">1143005768</span>@qq.com&gt; <span class="hljs-number">0</span>.<span class="hljs-number">1</span><br>- build the program<br></code></pre></td></tr></table></figure><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpmbuild -ba main-0.1.spec<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://imgs.bencorn.com/imgs/2022/01/22/20220122214200.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rpm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubebuilder</title>
    <link href="/2022/01/22/Kubebuilder/"/>
    <url>/2022/01/22/Kubebuilder/</url>
    
    <content type="html"><![CDATA[<h2 id="kubebuilder-install"><a href="#kubebuilder-install" class="headerlink" title="kubebuilder install"></a>kubebuilder install</h2><h3 id="go安装"><a href="#go安装" class="headerlink" title="go安装"></a>go安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/golang.org/</span>&gt;)<br></code></pre></td></tr></table></figure><h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/engine/i</span>nstall<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/docs.docker.com/</span>engine<span class="hljs-regexp">/install/</span>&gt;)<br><br>bug fix参见docker：[&lt;https:<span class="hljs-regexp">//</span>www.notion.so<span class="hljs-regexp">/docker-70e41d6ca1bd4b2b966c9d247ce628a4&gt;](&lt;https:/</span><span class="hljs-regexp">/www.notion.so/</span>docker-<span class="hljs-number">70</span>e41d6ca1bd4b2b966c9d247ce628a4&gt;)<br></code></pre></td></tr></table></figure><h3 id="SIG-CLI-安装"><a href="#SIG-CLI-安装" class="headerlink" title="SIG CLI 安装"></a>SIG CLI 安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>kubernetes.io<span class="hljs-regexp">/docs/</span>tasks<span class="hljs-regexp">/tools/i</span>nstall-kubectl-linux<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/kubectl.docs.kubernetes.io/i</span>nstallation/&gt;)<br></code></pre></td></tr></table></figure><p>​kind 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -Lo ./kind &lt;https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64&gt;<br><span class="hljs-built_in">chmod</span> +x ./kind<br><span class="hljs-built_in">mv</span> ./kind /some-dir-in-your-PATH/kind<br></code></pre></td></tr></table></figure><p>​kustome 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GOBIN=$(<span class="hljs-built_in">pwd</span>)/ GO111MODULE=on go get sigs.k8s.io/kustomize/kustomize/v3<br></code></pre></td></tr></table></figure><h3 id="kubebuilder安装"><a href="#kubebuilder安装" class="headerlink" title="kubebuilder安装"></a>kubebuilder安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">os=$(go <span class="hljs-built_in">env</span> GOOS)<br><span class="hljs-built_in">arch</span>=$(go <span class="hljs-built_in">env</span> GOARCH)<br><br><span class="hljs-comment"># 下载 kubebuilder 并解压到 tmp 目录中</span><br>curl -L &lt;https://go.kubebuilder.io/dl/2.3.1/<span class="hljs-variable">$&#123;os&#125;</span>/<span class="hljs-variable">$&#123;arch&#125;</span>&gt; | tar -xz -C /tmp/<br><br><span class="hljs-comment"># 将 kubebuilder 移动到一个长期的路径，并将其加入环境变量 path 中</span><br><span class="hljs-comment"># （如果你把 kubebuilder 放在别的地方，你需要额外设置 KUBEBUILDER_ASSETS 环境变量）</span><br><br>sudo <span class="hljs-built_in">mv</span> /tmp/kubebuilder_2.3.1_<span class="hljs-variable">$&#123;os&#125;</span>_<span class="hljs-variable">$&#123;arch&#125;</span> /usr/local/kubebuilder<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/kubebuilder/bin<br><span class="hljs-comment"># 或者添加到/etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="First-Program"><a href="#First-Program" class="headerlink" title="First Program"></a>First Program</h2><p><a href="https://cloudnative.to/kubebuilder/quick-start.html">https://cloudnative.to/kubebuilder/quick-start.html</a></p><h2 id="development-a-demo"><a href="#development-a-demo" class="headerlink" title="development a demo"></a>development a demo</h2><h3 id="go安装-1"><a href="#go安装-1" class="headerlink" title="go安装"></a>go安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/golang.org/</span>&gt;)<br></code></pre></td></tr></table></figure><h3 id="docker安装-1"><a href="#docker安装-1" class="headerlink" title="docker安装"></a>docker安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>docs.docker.com<span class="hljs-regexp">/engine/i</span>nstall<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/docs.docker.com/</span>engine<span class="hljs-regexp">/install/</span>&gt;)<br><br>bug fix参见docker：[&lt;https:<span class="hljs-regexp">//</span>www.notion.so<span class="hljs-regexp">/docker-70e41d6ca1bd4b2b966c9d247ce628a4&gt;](&lt;https:/</span><span class="hljs-regexp">/www.notion.so/</span>docker-<span class="hljs-number">70</span>e41d6ca1bd4b2b966c9d247ce628a4&gt;)<br></code></pre></td></tr></table></figure><h3 id="SIG-CLI-安装-1"><a href="#SIG-CLI-安装-1" class="headerlink" title="SIG CLI 安装"></a>SIG CLI 安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">参照网站：[&lt;https:<span class="hljs-regexp">//</span>kubernetes.io<span class="hljs-regexp">/docs/</span>tasks<span class="hljs-regexp">/tools/i</span>nstall-kubectl-linux<span class="hljs-regexp">/&gt;](&lt;https:/</span><span class="hljs-regexp">/kubectl.docs.kubernetes.io/i</span>nstallation/&gt;)<br></code></pre></td></tr></table></figure><p>​kind 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -Lo ./kind &lt;https://kind.sigs.k8s.io/dl/v0.11.1/kind-linux-amd64&gt;<br><span class="hljs-built_in">chmod</span> +x ./kind<br><span class="hljs-built_in">mv</span> ./kind /some-dir-in-your-PATH/kind<br></code></pre></td></tr></table></figure><p>​kustome 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">GOBIN=$(<span class="hljs-built_in">pwd</span>)/ GO111MODULE=on go get sigs.k8s.io/kustomize/kustomize/v3<br></code></pre></td></tr></table></figure><h3 id="kubebuilder安装-1"><a href="#kubebuilder安装-1" class="headerlink" title="kubebuilder安装"></a>kubebuilder安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">os=$(go <span class="hljs-built_in">env</span> GOOS)<br><span class="hljs-built_in">arch</span>=$(go <span class="hljs-built_in">env</span> GOARCH)<br><br><span class="hljs-comment"># 下载 kubebuilder 并解压到 tmp 目录中</span><br>curl -L &lt;https://go.kubebuilder.io/dl/2.3.1/<span class="hljs-variable">$&#123;os&#125;</span>/<span class="hljs-variable">$&#123;arch&#125;</span>&gt; | tar -xz -C /tmp/<br><br><span class="hljs-comment"># 将 kubebuilder 移动到一个长期的路径，并将其加入环境变量 path 中</span><br><span class="hljs-comment"># （如果你把 kubebuilder 放在别的地方，你需要额外设置 KUBEBUILDER_ASSETS 环境变量）</span><br><br>sudo <span class="hljs-built_in">mv</span> /tmp/kubebuilder_2.3.1_<span class="hljs-variable">$&#123;os&#125;</span>_<span class="hljs-variable">$&#123;arch&#125;</span> /usr/local/kubebuilder<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/kubebuilder/bin<br><span class="hljs-comment"># 或者添加到/etc/profile</span><br></code></pre></td></tr></table></figure><h2 id="Demo-实现"><a href="#Demo-实现" class="headerlink" title="Demo 实现"></a>Demo 实现</h2><h3 id="kind-搭建多节点集群"><a href="#kind-搭建多节点集群" class="headerlink" title="kind 搭建多节点集群"></a>kind 搭建多节点集群</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># cluster with 1 control-plane nodes and 3 workers</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Cluster</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kind.x-k8s.io/v1alpha4</span><br><span class="hljs-attr">nodes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">control-plane</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">role:</span> <span class="hljs-string">worker</span><br><span class="hljs-string">kind</span> <span class="hljs-string">create</span> <span class="hljs-string">cluster</span> <span class="hljs-string">--config</span> <span class="hljs-string">kind-1-3.yaml</span><br></code></pre></td></tr></table></figure><p>​创建好一个单控制节点，多计算节点集群</p><h3 id="创建kubebuilder项目"><a href="#创建kubebuilder项目" class="headerlink" title="创建kubebuilder项目"></a>创建kubebuilder项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubebuilder init --domain demo.org<br>kubebuilder create api --group system --version v1 --kind Sysctl<br></code></pre></td></tr></table></figure><p>​修改基本的逻辑，我们希望调用api的时候，检测spec数据结构的值，根据值做出相应的系统调用实现，现在做sysctl的系统调用，并且我们把它给打印到日志里边儿。</p><ul><li>数据结构</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SysctlCall 检查值进行系统调用</span><br>SysctlCall <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sysctl_call,omitempty&quot;`</span><br></code></pre></td></tr></table></figure><ul><li>Reconcile</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *SysctlReconciler)</span></span> Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, <span class="hljs-type">error</span>) &#123;<br>l := log.FromContext(ctx)<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;demo start&quot;</span>)<br><span class="hljs-keyword">var</span> sysctlCall systemv1.Sysctl<br><span class="hljs-keyword">if</span> err := r.Get(ctx, req.NamespacedName, &amp;sysctlCall); err != <span class="hljs-literal">nil</span> &#123;<br>l.Error(err, <span class="hljs-string">&quot;unable to fetch sysctlCall&quot;</span>)<br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, client.IgnoreNotFound(err)<br>&#125;<br><br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;r.Get returns value&quot;</span>, <span class="hljs-string">&quot;sysctlCall&quot;</span>, sysctlCall)<br><span class="hljs-keyword">if</span> strings.EqualFold(sysctlCall.Spec.SysctlCall, <span class="hljs-string">&quot;Y&quot;</span>) &#123;<br><span class="hljs-keyword">var</span> whoami []<span class="hljs-type">byte</span><br><span class="hljs-keyword">var</span> cmd *exec.Cmd<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br>cmd = exec.Command(<span class="hljs-string">&quot;whoami&quot;</span>)<br><span class="hljs-keyword">if</span> whoami, err = cmd.Output(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;sysctl called&quot;</span>, <span class="hljs-string">&quot;bash/whoami&quot;</span>, <span class="hljs-type">string</span>(whoami))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;sysctl not called&quot;</span>)<br>&#125;<br>l.V(<span class="hljs-number">0</span>).Info(<span class="hljs-string">&quot;demo end&quot;</span>)<br><span class="hljs-comment">// your logic here</span><br><span class="hljs-keyword">return</span> ctrl.Result&#123;&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>system_v1_sysctl.yaml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">system.demo.org/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Sysctl</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">sysctl-sample</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># Add fields here</span><br>  <span class="hljs-attr">sysctl_call:</span> <span class="hljs-string">Y</span><br></code></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><ul><li>窗口一</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make install <br>make run<br></code></pre></td></tr></table></figure><ul><li>窗口二</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kubectl apply -f config/samples/system_v1_sysctl.yaml<br></code></pre></td></tr></table></figure><ul><li>结果</li></ul><p><img src="https://imgs.bencorn.com/imgs/2022/01/22/20220122213329.png" alt="实现结果"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>工具记录</title>
    <link href="/2022/01/22/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/01/22/%E5%B7%A5%E5%85%B7%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Google学术"><a href="#Google学术" class="headerlink" title="Google学术"></a>Google学术</h1><p> 第一步、获取管理员权限，如windows：</p><ul><li>win+R，输入gpedit.msc</li><li>计算机配置</li><li>windows设置</li><li>安全设置</li><li>本地策略</li><li>安全选项设置为禁用,重启生效<br><img src="https://imgs.bencorn.com/imgs/2022/01/22/20220122132810.png" alt="安全项设置"></li></ul><p>第二步、修改host文件，如windows：</p><ul><li>获取完管理员权限过后</li><li>C:\Windows\System32\drivers\etc</li><li>修改host文件，添加以下内容：</li></ul><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># google 学术<br><span class="hljs-number">172.245.241.129</span> scholar.google.com<br><span class="hljs-number">172.245.241.129</span> scholar.google.com.hk<br><span class="hljs-number">172.245.241.129</span> scholar.google.com.tw<br><span class="hljs-number">172.245.241.129</span> scholar.google.com.sg<br><span class="hljs-number">172.245.241.129</span> scholar.googleusercontent.com<br><br></code></pre></td></tr></table></figure><p>好了大功告成，这下就可以愉快看论文了。</p><h1 id="Codeforces"><a href="#Codeforces" class="headerlink" title="Codeforces"></a>Codeforces</h1><p>codeforces.com是由于google字体加载慢，然后也是修改一下host就可以很快了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">#codeforce<br>font.<span class="hljs-keyword">im</span> fonts.googleapis.<span class="hljs-keyword">com</span><br>font.<span class="hljs-keyword">im</span> fonts.gstatic.<span class="hljs-keyword">com</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project 0 C++ Primer</title>
    <link href="/2021/11/13/Project-0-C-Primer/"/>
    <url>/2021/11/13/Project-0-C-Primer/</url>
    
    <content type="html"><![CDATA[<h2 id="Lab-1-Summary"><a href="#Lab-1-Summary" class="headerlink" title="Lab 1 Summary"></a>Lab 1 Summary</h2><p> cmu15445第一个项目是学习C++，包括C++的面向对象、C++11&#x2F;14&#x2F;17特性，如智能指针等。同时也是对计算机基础知识的一个基本检验。</p><p> 实验地址（以后可能用不了）：<a href="https://15445.courses.cs.cmu.edu/fall2021/project0/">https://15445.courses.cs.cmu.edu/fall2021/project0/</a></p><p> 首先说一下这个部分用到的基本原理：</p><ul><li>1、CPU cache会将一维数组进行缓存，因此对RowMatrix中二维数组内存的开辟和使用Matrix中的linear一维数组，这样可以更好的使用CPU cache这一机制，提升代码速度；</li><li>2、C++多态，以及智能指针unique_ptr独占指针实现安全；</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p> 接下来是每个部分的实现，可能会有错误的地方，C++语言特性目前还不是特别的熟悉，菜~</p><h3 id="TODO-1-Construct-a-new-Matrix-instance"><a href="#TODO-1-Construct-a-new-Matrix-instance" class="headerlink" title="TODO 1 Construct a new Matrix instance"></a>TODO 1 Construct a new Matrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Matrix</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols) &#123;<br>    rows_ = rows;<br>    cols_ = cols;<br>    <span class="hljs-type">int</span> len = rows * cols;<br>    linear_ = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-built_in">memset</span>(linear_, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(T) * len);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-2-Destroy-a-matrix-instance"><a href="#TODO-2-Destroy-a-matrix-instance" class="headerlink" title="TODO 2 Destroy a matrix instance"></a>TODO 2 Destroy a matrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Matrix</span>() &#123; <span class="hljs-keyword">delete</span>[] linear_; &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-3-Construct-a-new-RowMatrix-instance"><a href="#TODO-3-Construct-a-new-RowMatrix-instance" class="headerlink" title="TODO 3 Construct a new RowMatrix instance"></a>TODO 3 Construct a new RowMatrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">RowMatrix</span>(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols) : <span class="hljs-built_in">Matrix</span>&lt;T&gt;(rows, cols) &#123;<br>    data_ = <span class="hljs-keyword">new</span> T *[rows];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>      data_[i] = <span class="hljs-keyword">this</span>-&gt;linear_ + i * cols;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-4-Implementation-getter-and-setter"><a href="#TODO-4-Implementation-getter-and-setter" class="headerlink" title="TODO 4 Implementation getter and setter"></a>TODO 4 Implementation getter and setter</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetRowCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;rows_; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetColumnCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;cols_; &#125;<br><br><span class="hljs-function">T <span class="hljs-title">GetElement</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-keyword">this</span>-&gt;rows_ || j &lt; <span class="hljs-number">0</span> || j &gt;= <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;Void Get Element: index is out of range.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> data_[i][j];<br>  &#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetElement</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, T val)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= <span class="hljs-keyword">this</span>-&gt;rows_ || j &lt; <span class="hljs-number">0</span> || j &gt;= <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;Void Set Element: index out of range&quot;</span>);<br>    &#125;<br>    data_[i][j] = val;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-5-Fill-from-source-container"><a href="#TODO-5-Fill-from-source-container" class="headerlink" title="TODO 5 Fill from source container"></a>TODO 5 Fill from source container</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FillFrom</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;T&gt; &amp;source)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    <span class="hljs-type">int</span> size = source.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (size != <span class="hljs-keyword">this</span>-&gt;rows_ * <span class="hljs-keyword">this</span>-&gt;cols_) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Exception</span>(ExceptionType::OUT_OF_RANGE, <span class="hljs-string">&quot;source does not contain the required number of elements&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>      <span class="hljs-keyword">this</span>-&gt;linear_[i] = source[i];<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-6-Destroy-a-RowMatrix-instance"><a href="#TODO-6-Destroy-a-RowMatrix-instance" class="headerlink" title="TODO 6 Destroy a RowMatrix instance"></a>TODO 6 Destroy a RowMatrix instance</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">~<span class="hljs-built_in">RowMatrix</span>() <span class="hljs-keyword">override</span> &#123; <span class="hljs-keyword">delete</span>[] data_; &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-7-RowMatrix-ADD"><a href="#TODO-7-RowMatrix-ADD" class="headerlink" title="TODO 7 RowMatrix ADD"></a>TODO 7 RowMatrix ADD</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">Add</span>(<span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;<br>    <span class="hljs-comment">// TODO(P0): Add implementation</span><br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>() || matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> rows = matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>();<br>    <span class="hljs-type">int</span> cols = matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; ret = std::make_unique&lt;RowMatrix&lt;T&gt;&gt;(rows, cols);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>        ret-&gt;<span class="hljs-built_in">SetElement</span>(i, j, matrixA-&gt;<span class="hljs-built_in">GetElement</span>(i, j) + matrixB-&gt;<span class="hljs-built_in">GetElement</span>(i, j));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-8-RowMatrix-Multiply"><a href="#TODO-8-RowMatrix-Multiply" class="headerlink" title="TODO 8 RowMatrix Multiply"></a>TODO 8 RowMatrix Multiply</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">Multiply</span>(<span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixB) &#123;<br>    <span class="hljs-comment">// TODO(P0): Add implementation</span><br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> rows = matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>();<br>    <span class="hljs-type">int</span> lines = matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br>    <span class="hljs-type">int</span> cols = matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>();<br><br>    std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; ret = std::make_unique&lt;RowMatrix&lt;T&gt;&gt;(rows, cols);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; lines; ++k) &#123;<br>          ret-&gt;<span class="hljs-built_in">SetElement</span>(i, j, ret-&gt;<span class="hljs-built_in">GetElement</span>(i, j) + matrixA-&gt;<span class="hljs-built_in">GetElement</span>(i, k) * matrixB-&gt;<span class="hljs-built_in">GetElement</span>(k, j));<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-9-RowMatrix-GEMM"><a href="#TODO-9-RowMatrix-GEMM" class="headerlink" title="TODO 9 RowMatrix GEMM"></a>TODO 9 RowMatrix GEMM</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">static</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt; <span class="hljs-built_in">GEMM</span>(<span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixA, <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixB,<br>                                            <span class="hljs-type">const</span> RowMatrix&lt;T&gt; *matrixC) &#123;<br>    <span class="hljs-comment">// TODO(P0): Add implementation</span><br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixB-&gt;<span class="hljs-built_in">GetRowCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (matrixA-&gt;<span class="hljs-built_in">GetRowCount</span>() != matrixC-&gt;<span class="hljs-built_in">GetRowCount</span>() || matrixB-&gt;<span class="hljs-built_in">GetColumnCount</span>() != matrixC-&gt;<span class="hljs-built_in">GetColumnCount</span>()) &#123;<br>      <span class="hljs-keyword">return</span> std::unique_ptr&lt;RowMatrix&lt;T&gt;&gt;(<span class="hljs-literal">nullptr</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">Multiply</span>(matrixA, matrixB);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(ret.<span class="hljs-built_in">get</span>(), matrixC);<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="Tests"><a href="#Tests" class="headerlink" title="Tests"></a>Tests</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd build<br>make start_test<br>./test/start_test<br><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2021/11/13/20211113143446.png" alt="测试结果1"></p><p><img src="https://imgs.bencorn.com/imgs/2021/11/13/20211113143508.png" alt="测试结果2"></p><h2 id="Gradescope"><a href="#Gradescope" class="headerlink" title="Gradescope"></a>Gradescope</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">make format<br>make check-lint<br>make check-clang-tidy<br>cd ..<br>zip -q -r project0-submission.zip src/include/primer/p0_starter.h<br><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2021/11/13/20211113174633.png" alt="grade测试结果"></p>]]></content>
    
    
    <categories>
      
      <category>CMU15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU15445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab2 Memory Management</title>
    <link href="/2021/08/13/Lab2-Memory-Management/"/>
    <url>/2021/08/13/Lab2-Memory-Management/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>实验地址：<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab2/">https://pdos.csail.mit.edu/6.828/2018/labs/lab2/</a></p><p>lab2我们将建立操作系统对内存的管理，其中内存管理分为了两个部分：物理内存管理和虚拟内存管理</p><h1 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h1><p>JOS 通过一个链表来管理物理内存，写一个极其简易的物理页分配器，这个部分的最大的难度在于对 JOS 内存布局的理解。</p><h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p>在文件 <code>kern/pmap.c</code> 中，实现下面的所有函数。</p><h3 id="boot-alloc"><a href="#boot-alloc" class="headerlink" title="boot_alloc()"></a>boot_alloc()</h3><p>根据函数的解释说明，我们得知，boot_alloc() 是 JOS 操作系统在设置虚拟内存系统的时候使用的物理内存分配器。</p><p>从代码中我们可以看到，在设置虚拟内存系统的时候，维护了一个全局的 nextfree 指针，该指针指着下一个空闲的地址，而且这个指针只的刚好是 extend memory 里边儿的 kernel.ld 中指定的内核 bss 的结束地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">   <span class="hljs-comment">// Allocate a chunk large enough to hold &#x27;n&#x27; bytes, then update</span><br>   <span class="hljs-comment">// nextfree.  Make sure nextfree is kept aligned</span><br>   <span class="hljs-comment">// to a multiple of PGSIZE.</span><br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// LAB 2: Your code here.</span><br><br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)&#123;<br>       <span class="hljs-keyword">return</span> nextfree;<br>   &#125;<br><br>   result = nextfree;<br>   nextfree = ROUNDUP(nextfree + n, PGSIZE);<br><br>   <span class="hljs-keyword">if</span>((<span class="hljs-type">uint32_t</span>)nextfree - KERNBASE &gt; (npages * PGSIZE))&#123;<br>       panic(<span class="hljs-string">&quot;Out of memory!\n&quot;</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><p>因此我们参照具体的内容，当调用值 n 的时候，按照页的大小，进行分配并且返回该内存页的起始地址。</p><h3 id="mem-init"><a href="#mem-init" class="headerlink" title="mem_init()"></a>mem_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Allocate an array of npages &#x27;struct PageInfo&#x27;s and store it in &#x27;pages&#x27;.</span><br><span class="hljs-comment">// The kernel uses this array to keep track of physical pages: for</span><br><span class="hljs-comment">// each physical page, there is a corresponding struct PageInfo in this</span><br><span class="hljs-comment">// array.  &#x27;npages&#x27; is the number of physical pages in memory.  Use memset</span><br><span class="hljs-comment">// to initialize all fields of each struct PageInfo to 0.</span><br><span class="hljs-comment">// Your code goes here:</span><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*)boot_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PageInfo) * npages);<br><span class="hljs-built_in">memset</span>(pages, <span class="hljs-number">0</span> ,<span class="hljs-keyword">sizeof</span>(pages));<br></code></pre></td></tr></table></figure><p> 创建一个数组，这个数组也就是所有的物理页了，然后初始化所有的 pages 为 0。</p><h3 id="page-init"><a href="#page-init" class="headerlink" title="page_init()"></a>page_init()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// The example code here marks all physical pages as free.</span><br>    <span class="hljs-comment">// However this is not truly the case.  What memory is free?</span><br>    <span class="hljs-comment">//  1) Mark physical page 0 as in use.</span><br>    <span class="hljs-comment">//     This way we preserve the real-mode IDT and BIOS structures</span><br>    <span class="hljs-comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span><br>    <span class="hljs-comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span><br>    <span class="hljs-comment">//     is free.</span><br>    <span class="hljs-comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span><br>    <span class="hljs-comment">//     never be allocated.</span><br>    <span class="hljs-comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span><br>    <span class="hljs-comment">//     Some of it is in use, some is free. Where is the kernel</span><br>    <span class="hljs-comment">//     in physical memory?  Which pages are already in use for</span><br>    <span class="hljs-comment">//     page tables and other data structures?</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Change the code to reflect this.</span><br>    <span class="hljs-comment">// NB: DO NOT actually touch the physical memory corresponding to</span><br>    <span class="hljs-comment">// free pages!</span><br>    <span class="hljs-type">size_t</span> i;<br>    page_free_list = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//page 0 in use</span><br>    pages[<span class="hljs-number">0</span>].pp_ref = <span class="hljs-number">1</span>;<br>    pages[<span class="hljs-number">0</span>].pp_link = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//[PGSIZE, npages_basemem) is free</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; npages_basemem; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">0</span>;<br>        pages[i].pp_link = page_free_list;<br>        page_free_list = &amp;pages[i];<br>    &#125;<br>    <br>    <span class="hljs-comment">//IO hole [IOPHYSMEM, EXTPYSMEM) must never be allocated</span><br>    <span class="hljs-keyword">for</span>(;i &lt; EXTPHYSMEM  / PGSIZE; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>        pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//extended memory [EXTPHYSMEM, nextfree) is in use</span><br>    <span class="hljs-comment">//tip boot_alloc algned to PGSIZE</span><br>    <span class="hljs-keyword">for</span>(; i &lt; PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>        pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//rest extended memory is free</span><br>    <span class="hljs-keyword">for</span>(; i &lt; npages; i++)&#123;<br>        pages[i].pp_ref = <span class="hljs-number">0</span>;<br>        pages[i].pp_link = page_free_list;<br>        page_free_list = &amp;pages[i];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="page-alloc"><a href="#page-alloc" class="headerlink" title="page_alloc()"></a>page_alloc()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Hint: use page2kva and memset</span><br><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-keyword">if</span> (page_free_list == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span>* <span class="hljs-title">page</span> =</span> page_free_list;<br>page_free_list = page-&gt;pp_link;<br>page-&gt;pp_ref = <span class="hljs-number">0</span>;<br>page-&gt;pp_link = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span>(alloc_flags &amp; ALLOC_ZERO)&#123;<br><span class="hljs-built_in">memset</span>(page2kva(page), <span class="hljs-string">&#x27;\0&#x27;</span>, PGSIZE);<br>&#125;<br><br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="page-free"><a href="#page-free" class="headerlink" title="page_free()"></a>page_free()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> PageInfo *pp)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span><br><span class="hljs-comment">// pp-&gt;pp_link is not NULL.</span><br><span class="hljs-keyword">if</span>(pp-&gt;pp_ref)&#123;<br>panic(<span class="hljs-string">&quot;page-&gt;pp_ref is nonzero!\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pp-&gt;pp_link)&#123;<br>panic(<span class="hljs-string">&quot;page-&gt;pp_link is not NULL!\n&quot;</span>);<br>&#125;<br><br>pp-&gt;pp_link = page_free_list;<br>page_free_list = pp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="check-page-free-list-x2F-check-page-alloc"><a href="#check-page-free-list-x2F-check-page-alloc" class="headerlink" title="check_page_free_list()&#x2F;check_page_alloc()"></a>check_page_free_list()&#x2F;check_page_alloc()</h3><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-18-19-43-04.png" alt="Exercise 1 result"></p><h1 id="Part-2：Virtual-Memory"><a href="#Part-2：Virtual-Memory" class="headerlink" title="Part 2：Virtual Memory"></a>Part 2：Virtual Memory</h1><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><p>阅读 intel 80386 手册，对 x86 的段、页式管理有一个初步的理解。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"> Selector  +--------------+         +-----------+<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     |<span class="hljs-string"> Segmentation </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  Paging   </span>|<br>Software             |<span class="hljs-string">              </span>|<span class="hljs-string">--------&gt;</span>|<span class="hljs-string">           </span>|<span class="hljs-string">----------&gt;  RAM</span><br><span class="hljs-string">            Offset   </span>|<span class="hljs-string">  Mechanism   </span>|<span class="hljs-string">         </span>|<span class="hljs-string"> Mechanism </span>|<br>          ----------&gt;|<span class="hljs-string">              </span>|<span class="hljs-string">         </span>|<span class="hljs-string">           </span>|<br>                     +--------------+         +-----------+<br>            Virtual                   Linear                Physical<br></code></pre></td></tr></table></figure><p>在 X86 的逻辑中，虚拟地址包含一个段选择子和偏移地址，线性地址是段地址转换过后但是没有在页地址转换之前的地址。物理地址是最后得到的地址，可以通过硬件地址总线访问 RAM。</p><h2 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual,Linear,and Physical Addresses"></a>Virtual,Linear,and Physical Addresses</h2><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-19-11-33-12.png" alt="Page Translation"></p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><p>在 JOS 中，一个 C 的指针就是虚拟地址的 offset。在 <code>boot/boots.S</code> 中，GDT 将所有的段的地址都以 0 为起始地址，0xffffffff 为界限，这样就可以有效的让段地址转换变得较为简单。这样就可以让线性地址就是虚拟地址的偏移地址，JOS 的老师通过这样的方式让我们专注于页的转换。</p><p>打开 QEMU monitor 过后，Ctrl-a c 打开控制界面，我用的 WSL 还打开了一堆 QQ 之类的软件儿，可能有快捷键冲突，因此可以使用这条命令来试一试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br>qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log<br></code></pre></td></tr></table></figure><p>这个时候，在按照相应的命令来进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qemu">xp /Nx paddr 可以看到物理内存地址<br>x /Nx addr 可以看到虚拟内存地址<br>info registers可以看到寄存器内容<br>info mem可以看到已经有的页表映射的虚拟地址空间，以及访问他们的优先级<br>info pg可以看到当前页表的结构<br></code></pre></td></tr></table></figure><h2 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h2><p>在未来的实验中，通常会同时将相同的物理页面映射到多个虚拟地址（或多个环境的地址空间中）。 我们将在与物理页对应的 struct PageInfo 的 pp_ref 字段中保存对每个物理页的引用次数的计数。 当物理页的计数变为零时，该页可以被释放，因为它不再被使用。</p><p>一般来说，这个计数应该等于所有页表中物理页出现在 UTOP 下面的次数（UTOP 以上的映射大多是在引导时由内核设置的，不应该被释放，所以不需要引用计数）。我们还将使用它来跟踪我们保留的指向页目录页面的指针数量，进而跟踪页目录对页表页面的引用数量。</p><p>使用 page_alloc 时要小心。 它返回的页面的引用计数始终为 0，因此一旦您对返回的页面执行了某些操作（例如将其插入页表），pp_ref 就应该递增。 有时这是由其他函数（例如 page_insert）处理的，有时调用 page_alloc 的函数必须直接执行此操作。</p><h2 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h2><p>这个部分开始对页表进行管理，写一些例程来管理 page table，插入和删除 linear-to-physical 的映射，并且创建 page table pages 当需要的时候。</p><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><p>要实现的函数在 <code>kern/pmap.c</code> 文件中，在实现下列函数之前，需要弄懂页表管理以及多个宏的含义。</p><h4 id="pgdir-walk"><a href="#pgdir-walk" class="headerlink" title="pgdir_walk()"></a>pgdir_walk()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">pgdir_walk</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> create)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pde_t</span> *pde;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span><br><br>pde = &amp;pgdir[PDX(va)];<br><br><span class="hljs-keyword">if</span>(!(*pde &amp; PTE_P))&#123;<br><span class="hljs-keyword">if</span>(create == <span class="hljs-literal">false</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>page = page_alloc(ALLOC_ZERO);<br><span class="hljs-keyword">if</span>(page == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>page-&gt;pp_ref ++;<br>*pde = page2pa(page) | PTE_P | PTE_W | PTE_U;<br>&#125;<br>&#125;<br><br>pte = (<span class="hljs-type">pte_t</span>*)KADDR(PTE_ADDR(*pde));<br><br><span class="hljs-keyword">return</span> &amp;pte[PTX(va)];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="boot-map-region"><a href="#boot-map-region" class="headerlink" title="boot_map_region()"></a>boot_map_region()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">boot_map_region</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">size_t</span> size, <span class="hljs-type">physaddr_t</span> pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-type">size_t</span> numpage = ROUNDUP(size, PGSIZE)  / PGSIZE;<br><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; numpage; i ++)&#123;<br>pte = pgdir_walk(pgdir, (<span class="hljs-type">void</span>*) va, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(pte == <span class="hljs-literal">NULL</span>)&#123;<br>panic(<span class="hljs-string">&quot;boot_map_region: out of memory!\n&quot;</span>);<br>&#125;<br><br>*pte = (pa | perm | PTE_P);<br><br>va += PGSIZE;<br>pa += PGSIZE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a>page_lookup()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_lookup</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va, <span class="hljs-type">pte_t</span> **pte_store)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pde_t</span> *pde;<br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span><br><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span>(pte == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span>(*pte_store)&#123;<br>*pte_store = pte;<br>&#125;<br><br>page = pa2page(PTE_ADDR(*pte));<br><span class="hljs-keyword">return</span> page;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a>page_remove()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_remove</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-type">void</span> *va)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span> <br><br>page = page_lookup(pgdir, va, &amp;pte);<br><span class="hljs-keyword">if</span>(page == <span class="hljs-literal">NULL</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>page_decref(page);<br>tlb_invalidate(pgdir, va);<br>*pte = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="page-insert"><a href="#page-insert" class="headerlink" title="page_insert()"></a>page_insert()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">page_insert</span><span class="hljs-params">(<span class="hljs-type">pde_t</span> *pgdir, <span class="hljs-keyword">struct</span> PageInfo *pp, <span class="hljs-type">void</span> *va, <span class="hljs-type">int</span> perm)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in</span><br><span class="hljs-type">pte_t</span> *pte;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">page</span>;</span><br><br>pte = pgdir_walk(pgdir, va, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">if</span>(!pte)&#123;<br><span class="hljs-keyword">return</span> -E_NO_MEM;<br>&#125;<br><br><span class="hljs-keyword">if</span>(*pte &amp; PTE_P)&#123;<br><span class="hljs-keyword">if</span>(PTE_ADDR(*pte) == page2pa(pp))&#123;<br>pp-&gt;pp_ref --;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>tlb_invalidate(pgdir, va);<br>page_remove(pgdir, va);<br>&#125;<br>&#125;<br><br>pp-&gt;pp_ref ++;<br><br>*pte = page2pa(pp) | perm | PTE_P;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="check-page"><a href="#check-page" class="headerlink" title="check_page()"></a>check_page()</h4><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-19-22-00-19.png" alt="virtual memory result"></p><h1 id="Part-3：Kernel-Address-Space"><a href="#Part-3：Kernel-Address-Space" class="headerlink" title="Part 3：Kernel Address Space"></a>Part 3：Kernel Address Space</h1><p>JOS 将处理器的 32-bit 线性地址空间划分为两个部分。在 <code>inc/memlayout.h</code> 中可以看到。</p><p>我们将在实验 3 中开始加载和运行的用户环境（进程）将控制下部的布局和内容，而内核始终保持对上部的完全控制。</p><p>分割线是由 inc&#x2F;memlayout.h 中的符号 ULIM 随意定义的，为内核保留了大约 256MB 的虚拟地址空间。 这解释了为什么我们需要在实验 1 中为内核提供如此高的链接地址：否则内核的虚拟地址空间中将没有足够的空间来同时映射到其下方的用户环境。</p><h2 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h2><p>由于内核和用户内存都存在于每个环境的地址空间中，因此我们必须使用 x86 页表中的权限位来允许用户代码仅访问地址空间的用户部分。 否则，用户代码中的错误可能会覆盖内核数据，从而导致崩溃或更细微的故障； 用户代码还可能窃取其他环境的私有数据。 请注意，可写权限位（PTE_W）会影响用户和内核代码！</p><p>用户环境将没有权限访问 ULIM 以上的任何内存，而内核将能够读写该内存。 对于地址范围 [UTOP,ULIM)，内核和用户环境都具有相同的权限：可以读取但不能写入该地址范围。 该地址范围用于向用户环境公开某些只读的内核数据结构。 最后，UTOP下面的地址空间是供用户环境使用的； 用户环境将设置访问该内存的权限。</p><h2 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h2><p>现在将在 UTOP 之上设置地址空间：地址空间的内核部分。<br>inc&#x2F;memlayout.h 显示应该使用的布局。<br>使用刚刚编写的函数来设置适当的线性到物理映射。</p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><p>完善 mem_init()中缺失的代码，位置在 check_page()之后。</p><h4 id="mem-init-1"><a href="#mem-init-1" class="headerlink" title="mem_init()"></a>mem_init()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map &#x27;pages&#x27; read-only by the user at linear address UPAGES</span><br><span class="hljs-comment">// Permissions:</span><br><span class="hljs-comment">//    - the new image at UPAGES -- kernel R, user R</span><br><span class="hljs-comment">//      (ie. perm = PTE_U | PTE_P)</span><br><span class="hljs-comment">//    - pages itself -- kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U | PTE_P);<br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Use the physical memory that &#x27;bootstack&#x27; refers to as the kernel</span><br><span class="hljs-comment">// stack.  The kernel stack grows down from virtual address KSTACKTOP.</span><br><span class="hljs-comment">// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)</span><br><span class="hljs-comment">// to be the kernel stack, but break this into two pieces:</span><br><span class="hljs-comment">//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory</span><br><span class="hljs-comment">//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if</span><br><span class="hljs-comment">//       the kernel overflows its stack, it will fault rather than</span><br><span class="hljs-comment">//       overwrite memory.  Known as a &quot;guard page&quot;.</span><br><span class="hljs-comment">//     Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KSTACKTOP - KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// Map all of physical memory at KERNBASE.</span><br><span class="hljs-comment">// Ie.  the VA range [KERNBASE, 2^32) should map to</span><br><span class="hljs-comment">//      the PA range [0, 2^32 - KERNBASE)</span><br><span class="hljs-comment">// We might not have 2^32 - KERNBASE bytes of physical memory, but</span><br><span class="hljs-comment">// we just set up the mapping anyway.</span><br><span class="hljs-comment">// Permissions: kernel RW, user NONE</span><br><span class="hljs-comment">// Your code goes here:</span><br>boot_map_region(kern_pgdir, KERNBASE, <span class="hljs-number">0xffffffff</span> - KERNBASE, <span class="hljs-number">0</span>, PTE_W);<br></code></pre></td></tr></table></figure><h4 id="check-kern-pgdir-x2F-check-page-installed-pgdir"><a href="#check-kern-pgdir-x2F-check-page-installed-pgdir" class="headerlink" title="check_kern_pgdir()&#x2F;check_page_installed_pgdir()"></a>check_kern_pgdir()&#x2F;check_page_installed_pgdir()</h4><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-20-07-38-24.png" alt="Exercise 5 result"></p><p><img src="https://imgs.bencorn.com/imgs/Lab2-Memory-Management-2023-07-20-07-42-21.png" alt="make grade"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW2 shell</title>
    <link href="/2021/08/13/HW2-shell/"/>
    <url>/2021/08/13/HW2-shell/</url>
    
    <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>1、阅读 xv6 book 的第 0 章：<a href="./book-rev10.pdf">点击下载</a></p><p>2、下载 6.828 shell 文件：<a href="./sh.c">点击下载</a></p><p>3、将下列代码粘贴到 t.sh 文件内</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> &gt; y<br><span class="hljs-built_in">cat</span> &lt; y | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">wc</span> &gt; y1<br><span class="hljs-built_in">cat</span> y1<br><span class="hljs-built_in">rm</span> y1<br><span class="hljs-built_in">ls</span> |  <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> | <span class="hljs-built_in">wc</span><br><span class="hljs-built_in">rm</span> y<br></code></pre></td></tr></table></figure><p>4、编译并且执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o sh sh.c<br>./sh &lt; t.sh<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-24-05.png" alt="sh"></p><p>产生了错误，没有实现，接下来进行实现。</p><h1 id="Executing-simple-commands"><a href="#Executing-simple-commands" class="headerlink" title="Executing simple commands"></a>Executing simple commands</h1><h2 id="实现-ls"><a href="#实现-ls" class="headerlink" title="实现 ls"></a>实现 ls</h2><p>查看 exec manual 页，阅读 execv 并且答应错误信息当 exec 失败的时候，然后实现 ls 的 case 命令，根据 type 定义，我们只需要实现 case ‘ ‘ 的情况：</p><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-31-31.png" alt="execv 参数"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27; &#x27;</span>:<br>   ecmd = (<span class="hljs-keyword">struct</span> execcmd*)cmd;<br>   <span class="hljs-keyword">if</span>(ecmd-&gt;argv[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>     _exit(<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">// fprintf(stderr, &quot;exec not implemented\n&quot;);</span><br>   <span class="hljs-comment">// Your code here ...</span><br>   <span class="hljs-type">int</span> res = execv(ecmd-&gt;argv[<span class="hljs-number">0</span>],ecmd-&gt;argv);<br>   <span class="hljs-keyword">if</span>(res == <span class="hljs-number">-1</span>)&#123;<br>       <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;exec fails!\n&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-30-49.png" alt="/bin/ls"></p><h2 id="I-x2F-O-redirection"><a href="#I-x2F-O-redirection" class="headerlink" title="I&#x2F;O redirection"></a>I&#x2F;O redirection</h2><p>直接参照 xv6-book 实现重定向就 ok，关闭当前进程的文件描述符，而文件描述符总是从最小的开始增长，所以当我们打开一个文件时，我们将输入&#x2F;输出的标准描述符绑定到该文件上边儿，然后跑 runcmd 就可以直接使用了，完成I&#x2F;O 重定向：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&gt;&#x27;</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&lt;&#x27;</span>:<br>  rcmd = (<span class="hljs-keyword">struct</span> redircmd*)cmd;<br>  <span class="hljs-comment">//fprintf(stderr, &quot;redir not implemented\n&quot;);</span><br>  <span class="hljs-comment">// Your code here ...</span><br>  close(rcmd-&gt;fd);<br>  <span class="hljs-type">int</span> fd = open(rcmd-&gt;file,rcmd-&gt;flags,O_CREAT|O_WRONLY|O_RDONLY);<br>  <span class="hljs-keyword">if</span>(fd == <span class="hljs-number">-1</span>)&#123;<br>      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>,<span class="hljs-string">&quot;could not open file %s\n&quot;</span>, rcmd-&gt;file);<br>      _exit(<span class="hljs-number">1</span>);<br>  &#125;<br>  runcmd(rcmd-&gt;cmd);<br>  <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-43-42.png" alt="/bin/cat &lt; x.txt"></p><h2 id="Implement-pipes"><a href="#Implement-pipes" class="headerlink" title="Implement pipes"></a>Implement pipes</h2><p>手动实现一个管道，参考讲义中的管道，直接写，我们将父进程的标准输出绑定到管道的一端，将子进程的标准输出绑定到管道的另一端，这样就可以实现父进程从管道的一端输出，子进程从管道的一端输入，然后我们让子进程跑在管道的左端，父进程跑在管道的右端，父进程等待子进程完成并且退出再执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;|&#x27;</span>:<br>  pcmd = (<span class="hljs-keyword">struct</span> pipecmd*)cmd;<br>  <span class="hljs-comment">//fprintf(stderr, &quot;pipe not implemented\n&quot;);</span><br>  <span class="hljs-comment">// Your code here ...</span><br>  <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>  pipe(pipefd);<br><br>  <span class="hljs-type">int</span> process = fork1();<br>  <span class="hljs-keyword">if</span>(process == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-comment">// child process</span><br>      <span class="hljs-comment">// pipe left side</span><br>      close(<span class="hljs-number">1</span>);<br>      dup(pipefd[<span class="hljs-number">1</span>]);<br>      close(pipefd[<span class="hljs-number">0</span>]);<br>      close(pipefd[<span class="hljs-number">1</span>]);<br>      runcmd(pcmd-&gt;left);<br>  &#125;<br>  <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-comment">// parent process</span><br>      <span class="hljs-comment">// pipe right side</span><br>      close(<span class="hljs-number">0</span>);<br>      dup(pipefd[<span class="hljs-number">0</span>]);<br>      close(pipefd[<span class="hljs-number">0</span>]);<br>      close(pipefd[<span class="hljs-number">1</span>]);<br>      wait(<span class="hljs-number">0</span>);<br>      runcmd(pcmd-&gt;right);<br>  &#125;<br>  <span class="hljs-keyword">break</span>;<br><br></code></pre></td></tr></table></figure><p>手动补全 tt.sh 文件，然后尝试看能否正确运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>/bin/ls &gt; y<br>/bin/cat &lt; y | /bin/sort | /bin/uniq | /bin/wc &gt; y1<br>/bin/cat y1<br>/bin/rm y1<br>/bin/ls |  /bin/sort | /bin/uniq | /bin/wc<br>/bin/rm y<br><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/HW2-shell-2023-04-30-11-51-25.png" alt="pipe test"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HW1 boot xv6</title>
    <link href="/2021/08/12/HW1-boot-xv6/"/>
    <url>/2021/08/12/HW1-boot-xv6/</url>
    
    <content type="html"><![CDATA[<h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><p>1、拉取 xv6 源代码文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 6.828<br><span class="hljs-built_in">cd</span> 6.828<br>git <span class="hljs-built_in">clone</span> git://github.com/mit-pdos/xv6-public.git<br></code></pre></td></tr></table></figure><p>2、编译 xv6</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> xv6-public<br>make<br></code></pre></td></tr></table></figure><h1 id="Finding-and-breaking-at-an-address"><a href="#Finding-and-breaking-at-an-address" class="headerlink" title="Finding and breaking at an address"></a>Finding and breaking at an address</h1><p>1、找到内核的入口点的地址，即 _start 的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nm kernel | grep _start<br></code></pre></td></tr></table></figure><p>在这个例子中，地址是 0x0010000c</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-20-25-30.png" alt="_start"></p><p>2、在 QEMU-GDB 内跑内核代码，并且设置刚刚找到的断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make qemu-gdb<br></code></pre></td></tr></table></figure><p>并且在另外一个 shell 中，使用 gdb，并且输入<code>target remote:26000</code>连接上qemu进行调试，通过添加断点，我们可以让 qemu 执行停在内核的入口地址处。</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-20-31-11.png" alt="breakpoint at 0x0010000c"></p><h1 id="Exercise：What-is-on-the-stack"><a href="#Exercise：What-is-on-the-stack" class="headerlink" title="Exercise：What is on the stack"></a>Exercise：What is on the stack</h1><p>当我们在断点 0x0010000c 处查看寄存器和 stack 内的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gdb"><br>info reg<br>x/24x $esp<br><br></code></pre></td></tr></table></figure><p>我们可以关注一下一些我们处理过的寄存器，一个是和堆栈相关的寄存器 <code>%esp</code> 和 <code>%eip</code>，在源代码中，从 bootasm.S 中设置堆栈为 C 语言建立堆栈开始，xv6 将堆栈的上限设置为 0x7c00，堆栈从 0x7c00 增长到了 0x7bdc 的位置，同时 <code>%ebp</code> 保存了上一次压栈的位置 0x7bf8，由于此时打了断点，可以看到 <code>%eip</code> 寄存器的值刚好指向 0x10000c 的位置。由于此时运行 boot loader 进入实模式，此时的 <code>%eflags</code> 寄存器的权限处于最高权限，代码段寄存器 <code>%cs</code> 的值，正好是 kernel.ld 中的 0x80100000 中的 0x8，此时数据段寄存器 <code>%ds</code> 正好指向对其过后的 0x10，然后是控制寄存器 <code>%cr0</code> 开起 32-bit 模式。以上寄存器的值符合运行的实际逻辑，压栈的大小，得去分析指令的条数来验证，这里没有验证，计算起来好复杂，反正是对的。</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-20-35-08.png" alt="寄存器值"></p><p>然后，我们就实际来看一看堆栈里边儿的内容吧。堆栈里的内容，我们可以通过单条指令执行来查看。</p><p><img src="https://imgs.bencorn.com/imgs/HW1-boot-xv6-2023-04-27-21-11-21.png" alt="堆栈内容"></p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab1 Booting a PC</title>
    <link href="/2021/08/09/Lab1-Booting-a-PC/"/>
    <url>/2021/08/09/Lab1-Booting-a-PC/</url>
    
    <content type="html"><![CDATA[<p>   lab1 主要是介绍一个PC启动时如何办到的，分为了三个部分：熟悉 x86 汇编语言、熟悉 QEMU x86 模拟器、熟悉 PC 加电启动过程，然后主要的代码在 kernel 文件夹下边儿。</p><p>​实验链接：<a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/">https://pdos.csail.mit.edu/6.828/2018/labs/lab1/</a></p><h2 id="实验文件安装"><a href="#实验文件安装" class="headerlink" title="实验文件安装"></a>实验文件安装</h2><p>​实验环境：Ubuntu 20.04 LTS WSL</p><p>​环境配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install gcc g++ build-essential gdb gcc-multilib qemu qemu-system<br></code></pre></td></tr></table></figure><p>​环境检测，查看是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">objdump -i<br>gcc -m32 -print-libgcc-file-name<br></code></pre></td></tr></table></figure><p>​下载 git 仓库，并尝试安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 6.828<br><span class="hljs-built_in">cd</span> 6.828<br>git <span class="hljs-built_in">clone</span> https://pdos.csail.mit.edu/6.828/2018/jos.git lab<br><span class="hljs-built_in">cd</span> lab<br></code></pre></td></tr></table></figure><p>​基本的一些操作命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br>make qemu<br>make grade<br></code></pre></td></tr></table></figure><h2 id="Part-1：PC-Bootstrap"><a href="#Part-1：PC-Bootstrap" class="headerlink" title="Part 1：PC Bootstrap"></a>Part 1：PC Bootstrap</h2><p>​这个部分主要是学习 X86 汇编语言，并且学习如何通过 QEMU 和 QEMU&#x2F;GDB 进行 debug。</p><h3 id="x86-assembly"><a href="#x86-assembly" class="headerlink" title="x86 assembly"></a>x86 assembly</h3><ul><li>PC Assembly Book：<a href="./pcasm-book.pdf">点击下载</a> </li><li>内联汇编：<a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html">http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html</a></li><li>80368编程指导：<a href="./i386.pdf">点击下载</a>  <a href="https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm">https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm</a></li><li>IA-32 Intel Architecture 开发手册：<a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a></li></ul><h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h4><p>​要求：熟悉 X86 汇编，并且了解 C 语言内联汇编的方式，这个之前做汇编学习过，也在 CSAPP 中学习过，可以直接过了就。</p><h3 id="Simulating-the-x86"><a href="#Simulating-the-x86" class="headerlink" title="Simulating the x86"></a>Simulating the x86</h3><p>​实验通过 QEMU 模拟 X86 的环境，并进行相关的系统模拟启动执行，下边儿进行具体的步骤操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> lab<br>make<br>make qemu<br>make qemu-nox<br></code></pre></td></tr></table></figure><p>make 的时候，进行编译生成 ELF 的 image 镜像，并且将它保存到了 obj&#x2F;kern&#x2F;kernel.img 这个地方，镜像里边儿保存了两个部分：obj&#x2F;boot&#x2F;boot和obj&#x2F;kernel</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-34-26.png" alt="make"></p><p>make qemu 或者 make qemu-nox 的时候从磁盘上启动该镜像，并且进入一个 Shell 的小界面如下图，该 shell 提供了两条命令：help、kerninfo</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-35-12.png" alt="make qemu"></p><p>退出 qemu 的话，只需要 ctrl+a x 按顺序按下去。然后，如果是在没有桌面环境的情况下，可以考虑使用 make qemu-nox 的命令行，这样就可以直接在 shell 上显示。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-36-45.png" alt="make qemu-nox"></p><h3 id="物理内存地址"><a href="#物理内存地址" class="headerlink" title="物理内存地址"></a>物理内存地址</h3><p>​这个部分进行了JOS物理内存地址的学习，当执行 kerninfo 的时候显示了部分信息，这个部分的信息是 JOS 内核的一些基本内存信息：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-38-22.png" alt="kernifo"></p><p>​可以看到这个部分的物理内存地址的分布情况，intel 处理器在研发过程中，从最早的 16 位到后来的 32 位、64 位，CPU 的寻址能力在提升，其物理地址空间也在变化，但总体而言 80386 的内存地址如下：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-40-54.png" alt="PC&#39;s physical address layout"></p><p>​也就是说，在 PC 启动的时候 CPU 运行在实模式，只能进行 1M 的访存，然后进入保护模式过后才拥有 4G 的内存访问能力，Intel 进行了访问的拓展，所以内存地址如上图呈现。</p><p>​其中，上述内存布局我觉得应该掌握一些基本的常识：</p><ul><li>第一代 PC 的 16-bits 的 Intel 8086 处理器，只能访问 1Mb 的内存，最早的 PC 机物理地址空间开始于 0x00000000，结束于 0x0000FFFF 而不是 0xFFFFFFFF 的 64KB</li><li>Low Memory 的 640KB 的空间只能用于随机的访问（RAM）</li><li>从 0x000A0000 开始到 0x000F0000 的 384KB 的空间被保留用于硬件的寻址，比如 VGA</li><li>1M 保留空间种最重要的部分是 BIOS ROM，占据从 0x000C0000 到 0x00100000 的 64KB 空间，BIOS 主要是进行硬件检查和初始化工作，最后从硬盘或者 CD-ROM 上装载系统，并且交接控制权给操作系统</li></ul><p>JOS 只是用前物理内存的 256M，假装机子有 32-bit 的物理地址空间。</p><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>​我们尝试进行debug的方式学习，在同一个目录下打开两个窗口，让gdb连接上QEMU进行调试，然后去学习BIOS是如何进行工作的。实验中提供了一个.gdbinit的文件，设置gdb调试的时候使用16位的模式，并且让gdb监听QEMU。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span> qemu-gdb<br><span class="hljs-built_in">make</span> gdb<br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-20-53-45.png" alt="make gdb"></p><p>​可以看到，gdb 使用了该 .gdbint 文件进行操作，并且成功监听 QEMU。当前的架构是为 i8086 也就是 16-bits 模式，这个时候会执行一条指令：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">[f000:fff0] <span class="hljs-number">0xffff0</span>: ljmp <span class="hljs-number">$0</span>x3630,<span class="hljs-number">$0</span>xf000e05b<br><span class="hljs-number">0x0000fff0</span> <span class="hljs-keyword">in</span> ?()<br></code></pre></td></tr></table></figure><p>​这条指令是gdb反汇编产生的代码，可以看到：</p><ul><li>IBM PC 启动执行的物理地址是再 0x000ffff0，它正是在 ROM BIOS 的高 64KB 的位置</li><li>PC 执行的时候执行：CS &#x3D; 0xf000 和 IP &#x3D; 0xfff0</li><li>执行的第一条指令是 jmp，并且跳去的地址是 0xf000e05b，也就是 CS &#x3D; 0xf000，IP &#x3D; 0xe05b</li></ul><p>​思考一个问题就是为什么 QEMU 里边儿显示的会这样执行？其实这个是 Intel 8086 处理器的设计有关，由于 BIOS 在 PC 中是 “hard-wired” 到物理地址范围0x000f0000-0x000fffff，这样设计是为了保证 PC 加电的时候能够立马执行并且控制系统，因为这个时候 RAM 内存中是没有可以执行的软件儿的（这个软件儿就是 OS）。QEMU emulator 它自带了 BIOS，当处理器重置的时候，QEMU 的虚拟处理器像正常的 CPU 那样，先是进入实模式并且设置 [CS:IP] 为 [0xf000:0xfff0]，这样可以让它根据CS:IP 进行访问；</p><p>实模式下，CPU 寻址方式是根据 CS:IP 的值来的，physical address &#x3D; 16 * segment + offset，因此：</p><p>​16 * 0xf000 + 0xfff0</p><p>​&#x3D; 0xf0000 + 0xfff0</p><p>​&#x3D; 0xffff0</p><h4 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h4><p>​要求：使用 GDB 命令 si（step instruction）进行单步跟踪，大致了解 BIOS 干了什么，而不需要太清楚细节。</p><p>​1、学习一个链接，关于计算机IO的：<a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm">http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm</a></p><p>​2、我们进行单步的跟踪得到如下的结果：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-01-10.png" alt="gdb si"></p><p>​总而言之，当 BIOS 运行的时候，它设置好中断描述符表，初始化各种设备比如 VGA 显示器、这个时候 QEMU 中的 “Starting SeaBIOS” 就是初始化显示器过后显示的。在完成 PCI bus 和各种重要的 BIOS 知道的设备初始话过后，它开始寻找可以启动的设备比如软盘、硬盘、CD-ROM，当发现可以启动的设备过后，BIOS 读取该设备中的bootloader 并且将控制权移交给 bootloader。</p><h2 id="Part-2：The-Boot-Loader"><a href="#Part-2：The-Boot-Loader" class="headerlink" title="Part 2：The Boot Loader"></a>Part 2：The Boot Loader</h2><p>​PC 中的软盘、硬盘都可以被划分为一个个的大小为 512 字节的扇区，一个扇区是一次磁盘操作的最小粒度，每一次读取或者写入都必须是一个或者多个扇区。如果一个磁盘是可以用来启动的操作系统的，就把这个磁盘的第一个扇区叫做启动扇区，当 BIOS 找到一个可以启动的软盘或者硬盘过后，它就会将这 512 个字节加载到内存物理地址为 0x7c00 到0x7dff中，然后执行 jmp 来设置 CS:IP 为0000:7c00，转移控制给 boot loader 程序。和 BIOS 的加载地址一样，这些地址都是规定好的标准地址。</p><p>​在 6.828 中采用传统的硬盘启动机制，意识是说 boot loader 程序的大小必须小于512 字节，然后整个 boot loader 是由一个汇编文件，boot&#x2F;boot.S 以及一个 C 语言的文件，boot&#x2F;main.c 组成，其必须具备两个功能：</p><p>​1、boot loader 需要讲 CPU 从 16-bits 实模式切换到 32-bits 保护模式，只有在保护模式下边儿才可以完成超过 1M 的访存能力，并且在保护模式下，segment:offset pair 转换成物理地址的方式也不再是简单的乘以 16，而实更为复杂的段页式模式；</p><p>​2、boot loader 通过 x86 特定的 I&#x2F;O 指令访问 IDE 设备寄存器，从磁盘中将 JOS 的内核读入内存</p><p>​说明：boot loader 来说，有一个文件比较重要，obj&#x2F;boot&#x2F;boot.asm，这个文件是真实运行的 boot loader 程序的反汇编版本，可以和它的源码 boot.S 和main.c 比较。同理，obj&#x2F;kern&#x2F;kernel.asm 也是 JOS kernel 的反汇编版本，后边儿调试应该会用到。</p><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h4><p>​要求：在地址 0x7c00 处设置断点，这是 boot sector 被加载的位置。然后让程序继续运行直到这个断点。跟踪 &#x2F;boot&#x2F;boot.S 文件的每一条指令，同时使用 boot.S 文件和系统为你反汇编出来的文件 obj&#x2F;boot&#x2F;boot.asm。你也可以使用 GDB 的 x&#x2F;i 指令来获取去任意一个机器指令的反汇编指令，把源文件 boot.S 文件和 boot.asm 文件以及在 GDB 反汇编出来的指令进行比较。追踪到 bootmain 函数中，而且还要具体追踪到readsect() 子函数里面。找出和 readsect() C 语言程序的每一条语句所对应的汇编指令，回到 bootmain()，然后找出把内核文件从磁盘读取到内存的那个 for 循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p><p>​我们首先查看 boot.S 和 main.c 中源码文件中的内容：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">#include &lt;<span class="hljs-keyword">inc</span>/mmu<span class="hljs-number">.</span>h&gt;<br><br># Start the <span class="hljs-meta">CPU</span>: switch to <span class="hljs-number">32</span>-bit protected mode, jump <span class="hljs-keyword">into</span> C.<br># The BIOS loads this code from the first sector of the hard disk <span class="hljs-keyword">into</span><br># memory <span class="hljs-meta">at</span> physical address <span class="hljs-number">0x7c00</span> <span class="hljs-keyword">and</span> starts executing <span class="hljs-keyword">in</span> real mode<br># with %cs=<span class="hljs-number">0</span> %ip=7c00.<br><span class="hljs-meta"></span><br><span class="hljs-meta">.set</span> PROT_MODE_CSEG, <span class="hljs-number">0x8</span>         # kernel code <span class="hljs-meta">segment</span> selector<br><span class="hljs-meta">.set</span> PROT_MODE_DSEG, <span class="hljs-number">0x10</span>        # kernel data <span class="hljs-meta">segment</span> selector<br><span class="hljs-meta">.set</span> CR0_PE_ON,      <span class="hljs-number">0x1</span>         # protected mode enable flag<br><span class="hljs-meta"></span><br><span class="hljs-meta">.globl</span> start<br><span class="hljs-symbol">start:</span><br><span class="hljs-meta">  .code16</span>                     # Assemble for <span class="hljs-number">16</span>-bit mode<br>  <span class="hljs-keyword">cli</span>                         # Disable interrupts<br>  <span class="hljs-keyword">cld</span>                         # String operations increment<br><br>  # Set <span class="hljs-meta">up</span> the important data <span class="hljs-meta">segment</span> registers (<span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-built_in">SS</span>).<br>  xorw    %ax,%ax             # <span class="hljs-meta">Segment</span> number <span class="hljs-meta">zero</span><br>  movw    %ax,%ds             # -&gt; Data <span class="hljs-meta">Segment</span><br>  movw    %ax,%es             # -&gt; Extra <span class="hljs-meta">Segment</span><br>  movw    %ax,%ss             # -&gt; Stack <span class="hljs-meta">Segment</span><br><br>  # Enable A20:<br>  #   For backwards compatibility with the earliest PCs, physical<br>  #   address line <span class="hljs-number">20</span> is tied low, so that addresses higher than<br>  #   1MB wrap around to <span class="hljs-meta">zero</span> by <span class="hljs-meta">default</span>.  This code undoes this.<br><span class="hljs-symbol">seta20.1:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.1</span><br><br>  movb    <span class="hljs-number">$0</span>xd1,%al               # <span class="hljs-number">0xd1</span> -&gt; port <span class="hljs-number">0x64</span><br>  outb    %al,<span class="hljs-number">$0</span>x64<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">seta20.2:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.2</span><br><br>  movb    <span class="hljs-number">$0</span>xdf,%al               # <span class="hljs-number">0xdf</span> -&gt; port <span class="hljs-number">0x60</span><br>  outb    %al,<span class="hljs-number">$0</span>x60<br><br>  # Switch from real to protected mode, using a bootstrap GDT<br>  # <span class="hljs-keyword">and</span> <span class="hljs-meta">segment</span> translation that makes virtual addresses <br>  # identical to their physical addresses, so that the <br>  # effective memory map does <span class="hljs-keyword">not</span> change during the switch.<br>  <span class="hljs-keyword">lgdt</span>    gdtdesc<br>  movl    %cr0, %eax<br>  orl     $CR0_PE_ON, %eax<br>  movl    %eax, %cr0<br>  <br>  # Jump to next instruction, but <span class="hljs-keyword">in</span> <span class="hljs-number">32</span>-bit code <span class="hljs-meta">segment</span>.<br>  # Switches processor <span class="hljs-keyword">into</span> <span class="hljs-number">32</span>-bit mode.<br>  ljmp    $PROT_MODE_CSEG, $protcseg<br><span class="hljs-meta"></span><br><span class="hljs-meta">  .code32</span>                     # Assemble for <span class="hljs-number">32</span>-bit mode<br><span class="hljs-symbol">protcseg:</span><br>  # Set <span class="hljs-meta">up</span> the protected-mode data <span class="hljs-meta">segment</span> registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="hljs-meta">segment</span> selector<br>  movw    %ax, %ds                # -&gt; <span class="hljs-built_in">DS</span>: Data <span class="hljs-meta">Segment</span><br>  movw    %ax, %es                # -&gt; <span class="hljs-built_in">ES</span>: Extra <span class="hljs-meta">Segment</span><br>  movw    %ax, %fs                # -&gt; <span class="hljs-built_in">FS</span><br>  movw    %ax, %gs                # -&gt; <span class="hljs-built_in">GS</span><br>  movw    %ax, %ss                # -&gt; <span class="hljs-built_in">SS</span>: Stack <span class="hljs-meta">Segment</span><br>  <br>  # Set <span class="hljs-meta">up</span> the stack pointer <span class="hljs-keyword">and</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">into</span> C.<br>  movl    $start, %esp<br>  <span class="hljs-keyword">call</span> bootmain<br><br>  # If bootmain returns (it shouldn<span class="hljs-string">&#x27;t), loop.</span><br><span class="hljs-string">spin:</span><br><span class="hljs-string">  jmp spin</span><br><span class="hljs-string"></span><br><span class="hljs-string"># Bootstrap GDT</span><br><span class="hljs-string">.p2align 2                                # force 4 byte alignment</span><br><span class="hljs-string">gdt:</span><br><span class="hljs-string">  SEG_NULL# null seg</span><br><span class="hljs-string">  SEG(STA_X|STA_R, 0x0, 0xffffffff)# code seg</span><br><span class="hljs-string">  SEG(STA_W, 0x0, 0xffffffff)        # data seg</span><br><span class="hljs-string"></span><br><span class="hljs-string">gdtdesc:</span><br><span class="hljs-string">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="hljs-string">  .long   gdt                             # address gdt</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>​然后是 main.c 中几个函数的内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/x86.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;inc/elf.h&gt;</span></span><br><br><span class="hljs-comment">/**********************************************************************</span><br><span class="hljs-comment"> * This a dirt simple boot loader, whose sole job is to boot</span><br><span class="hljs-comment"> * an ELF kernel image from the first IDE hard disk.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * DISK LAYOUT</span><br><span class="hljs-comment"> *  * This program(boot.S and main.c) is the bootloader.  It should</span><br><span class="hljs-comment"> *    be stored in the first sector of the disk.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * The 2nd sector onward holds the kernel image.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * The kernel image must be in ELF format.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * BOOT UP STEPS</span><br><span class="hljs-comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span><br><span class="hljs-comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span><br><span class="hljs-comment"> *    into memory and jumps to it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * Assuming this boot loader is stored in the first sector of the</span><br><span class="hljs-comment"> *    hard-drive, this code takes over...</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * control starts in boot.S -- which sets up protected mode,</span><br><span class="hljs-comment"> *    and a stack so C code then run, then calls bootmain()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span><br><span class="hljs-comment"> **********************************************************************/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SECTSIZE512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELFHDR((struct Elf *) 0x10000) <span class="hljs-comment">// scratch space</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">uint32_t</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">readseg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint32_t</span>, <span class="hljs-type">uint32_t</span>)</span>;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">bootmain</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span><br><br><span class="hljs-comment">// read 1st page off disk</span><br>readseg((<span class="hljs-type">uint32_t</span>) ELFHDR, SECTSIZE*<span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// is this a valid ELF?</span><br><span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)<br><span class="hljs-keyword">goto</span> bad;<br><br><span class="hljs-comment">// load each program segment (ignores ph flags)</span><br>ph = (<span class="hljs-keyword">struct</span> Proghdr *) ((<span class="hljs-type">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);<br>eph = ph + ELFHDR-&gt;e_phnum;<br><span class="hljs-keyword">for</span> (; ph &lt; eph; ph++)<br><span class="hljs-comment">// p_pa is the load address of this segment (as well</span><br><span class="hljs-comment">// as the physical address)</span><br>readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);<br><br><span class="hljs-comment">// call the entry point from the ELF header</span><br><span class="hljs-comment">// note: does not return!</span><br>((<span class="hljs-type">void</span> (*)(<span class="hljs-type">void</span>)) (ELFHDR-&gt;e_entry))();<br><br>bad:<br>outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>outw(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br><span class="hljs-comment">/* do nothing */</span>;<br>&#125;<br><br><span class="hljs-comment">// Read &#x27;count&#x27; bytes at &#x27;offset&#x27; from kernel into physical address &#x27;pa&#x27;.</span><br><span class="hljs-comment">// Might copy more than asked</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readseg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> pa, <span class="hljs-type">uint32_t</span> count, <span class="hljs-type">uint32_t</span> offset)</span><br>&#123;<br><span class="hljs-type">uint32_t</span> end_pa;<br><br>end_pa = pa + count;<br><br><span class="hljs-comment">// round down to sector boundary</span><br>pa &amp;= ~(SECTSIZE - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// translate from bytes to sectors, and kernel starts at sector 1</span><br>offset = (offset / SECTSIZE) + <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span><br><span class="hljs-comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span><br><span class="hljs-comment">// we load in increasing order.</span><br><span class="hljs-keyword">while</span> (pa &lt; end_pa) &#123;<br><span class="hljs-comment">// Since we haven&#x27;t enabled paging yet and we&#x27;re using</span><br><span class="hljs-comment">// an identity segment mapping (see boot.S), we can</span><br><span class="hljs-comment">// use physical addresses directly.  This won&#x27;t be the</span><br><span class="hljs-comment">// case once JOS enables the MMU.</span><br>readsect((<span class="hljs-type">uint8_t</span>*) pa, offset);<br>pa += SECTSIZE;<br>offset++;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">waitdisk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-comment">// wait for disk reaady</span><br><span class="hljs-keyword">while</span> ((inb(<span class="hljs-number">0x1F7</span>) &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x40</span>)<br><span class="hljs-comment">/* do nothing */</span>;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">uint32_t</span> offset)</span><br>&#123;<br><span class="hljs-comment">// wait for disk to be ready</span><br>waitdisk();<br><br>outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">// count = 1</span><br>outb(<span class="hljs-number">0x1F3</span>, offset);<br>outb(<span class="hljs-number">0x1F4</span>, offset &gt;&gt; <span class="hljs-number">8</span>);<br>outb(<span class="hljs-number">0x1F5</span>, offset &gt;&gt; <span class="hljs-number">16</span>);<br>outb(<span class="hljs-number">0x1F6</span>, (offset &gt;&gt; <span class="hljs-number">24</span>) | <span class="hljs-number">0xE0</span>);<br>outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);<span class="hljs-comment">// cmd 0x20 - read sectors</span><br><br><span class="hljs-comment">// wait for disk to be ready</span><br>waitdisk();<br><br><span class="hljs-comment">// read a sector</span><br>insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE/<span class="hljs-number">4</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​研究上述的两段儿代码，我们可以知道基本的过程，首先这两段儿程序共同构成了 boot loader 程序，并且这两段儿程序放到磁盘的第一个扇区作为启动扇区。BIOS 加载该扇区，同时这两段代码先执行的是 boot.S，在 boot.S 中从实模式切换到保护模式，并且建立好堆栈，在堆栈建立好过后才能够开始运行 C 代码，这个时候执行 main.c 中的函数bootmain()，然后 bootmain() 将内核加载进来过后，开始将控制权交给 JOS Kernel，这样就完成了启动工作。</p><p>​能够回答以下问题：</p><ul><li><p>处理器从什么时候开始执行 32 位代码？究竟是什么导致从 16 位模式切换到 32 位模式？</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">  .code32</span>                     # Assemble for <span class="hljs-number">32</span>-bit mode<br><span class="hljs-symbol">protcseg:</span><br>  # Set <span class="hljs-meta">up</span> the protected-mode data <span class="hljs-meta">segment</span> registers<br>  movw    $PROT_MODE_DSEG, %ax    # Our data <span class="hljs-meta">segment</span> selector<br>  movw    %ax, %ds                # -&gt; <span class="hljs-built_in">DS</span>: Data <span class="hljs-meta">Segment</span><br>  movw    %ax, %es                # -&gt; <span class="hljs-built_in">ES</span>: Extra <span class="hljs-meta">Segment</span><br>  movw    %ax, %fs                # -&gt; <span class="hljs-built_in">FS</span><br>  movw    %ax, %gs                # -&gt; <span class="hljs-built_in">GS</span><br>  movw    %ax, %ss                # -&gt; <span class="hljs-built_in">SS</span>: Stack <span class="hljs-meta">Segment</span><br>  <br>  # Set <span class="hljs-meta">up</span> the stack pointer <span class="hljs-keyword">and</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">into</span> C.<br>  movl    $start, %esp<br>  <span class="hljs-keyword">call</span> bootmain<br><br></code></pre></td></tr></table></figure><p>系统从.code32部分开始执行32位代码如上所示；</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.globl</span> start<br><span class="hljs-symbol">start:</span><br><span class="hljs-meta">  .code16</span>                     # Assemble for <span class="hljs-number">16</span>-bit mode<br>  <span class="hljs-keyword">cli</span>                         # Disable interrupts<br>  <span class="hljs-keyword">cld</span>                         # String operations increment<br><br>  # Set <span class="hljs-meta">up</span> the important data <span class="hljs-meta">segment</span> registers (<span class="hljs-built_in">DS</span>, <span class="hljs-built_in">ES</span>, <span class="hljs-built_in">SS</span>).<br>  xorw    %ax,%ax             # <span class="hljs-meta">Segment</span> number <span class="hljs-meta">zero</span><br>  movw    %ax,%ds             # -&gt; Data <span class="hljs-meta">Segment</span><br>  movw    %ax,%es             # -&gt; Extra <span class="hljs-meta">Segment</span><br>  movw    %ax,%ss             # -&gt; Stack <span class="hljs-meta">Segment</span><br></code></pre></td></tr></table></figure><p>CPU首先是运行在实模式，这个时候的 boot loader 运行在 16-bits 模式下边儿，这个时候中断屏蔽；由于之前 BIOS 执行的时候我们不清楚会不会寄存器内的内容是否会变我们无法保证，因此将 <code>%ax</code> 内的内容设置为0过后赋值给 <code>%ds、%es、%ss</code> 三个寄存器来清零；</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">  # Enable A20:<br>  #   For backwards compatibility with the earliest PCs, physical<br>  #   address line <span class="hljs-number">20</span> is tied low, so that addresses higher than<br>  #   1MB wrap around to <span class="hljs-meta">zero</span> by <span class="hljs-meta">default</span>.  This code undoes this.<br><span class="hljs-symbol">seta20.1:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.1</span><br><br>  movb    <span class="hljs-number">$0</span>xd1,%al               # <span class="hljs-number">0xd1</span> -&gt; port <span class="hljs-number">0x64</span><br>  outb    %al,<span class="hljs-number">$0</span>x64<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">seta20.2:</span><br>  inb     <span class="hljs-number">$0</span>x64,%al               # Wait for <span class="hljs-keyword">not</span> busy<br>  testb   <span class="hljs-number">$0</span>x2,%al<br>  <span class="hljs-keyword">jnz</span>     seta20<span class="hljs-number">.2</span><br><br>  movb    <span class="hljs-number">$0</span>xdf,%al               # <span class="hljs-number">0xdf</span> -&gt; port <span class="hljs-number">0x60</span><br>  outb    %al,<span class="hljs-number">$0</span>x60<br></code></pre></td></tr></table></figure><p>由于运行在实模式下，物理主线的低 20 位是没有用到的，以至于总是使用高地址的 1 M 内存，因此需要开启 A20 模式，来让这些位可以使用。为什么这样可以让 A20 开启呢？在 Intel 设计中，通过键盘控制器寄存器来实现 A20 开启，如主线 port 描述中所述：<a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p><img src="https://imgs.bencorn.com/imgs/2021/08/11/+08000811143425.png" alt="port"></p><p><img src="https://imgs.bencorn.com/imgs/2021/08/11/+08000811143314.png" alt="port value"></p><p><img src="https://imgs.bencorn.com/imgs/2021/08/11/+08000811143708.png" alt="A20"></p><p>可以看到，其中 0x64 端口是键盘控制器，当 0xd1 值输出到 0x64 port 里边儿，这个时候使 A20 gate 受到控制，然后再向 0x0060 port 写入 0xdf，这个时候根据port 描述可知，直接 enable address A20，至此 CPU 可以达到寻址范围增加，开启A20 成功。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># Switch from real to protected mode, using a bootstrap GDT<br># <span class="hljs-keyword">and</span> <span class="hljs-meta">segment</span> translation that makes virtual addresses <br># identical to their physical addresses, so that the <br># effective memory map does <span class="hljs-keyword">not</span> change during the switch.<br><span class="hljs-keyword">lgdt</span>    gdtdesc<br>movl    %cr0, %eax<br>orl     $CR0_PE_ON, %eax<br>movl    %eax, %cr0<br><br># Jump to next instruction, but <span class="hljs-keyword">in</span> <span class="hljs-number">32</span>-bit code <span class="hljs-meta">segment</span>.<br># Switches processor <span class="hljs-keyword">into</span> <span class="hljs-number">32</span>-bit mode.<br>ljmp    $PROT_MODE_CSEG, $protcseg<br></code></pre></td></tr></table></figure><p>由上述知道，CR0_PE_ON 里边儿的值是 0x1，这个是保护模式 enable 的标志，加载好全局描述符表过后，cr0 控制器要通过异或将标志位打开，同时最后执行一个 jmp 指令，其中 $PROT_MODE_CSEG，这个是 JOS kernel 的代码段地址，在保护模式下运行该代码段，这样就顺利切换到了 Kernel。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"># Bootstrap GDT<br><span class="hljs-meta">.p2align</span> <span class="hljs-number">2</span>                                # force <span class="hljs-number">4</span> <span class="hljs-built_in">byte</span> alignment<br><span class="hljs-symbol">gdt:</span><br>  SEG_NULL# null <span class="hljs-built_in">seg</span><br>  <span class="hljs-built_in">SEG</span>(STA_X|STA_R, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)# code <span class="hljs-built_in">seg</span><br>  <span class="hljs-built_in">SEG</span>(STA_W, <span class="hljs-number">0x0</span>, <span class="hljs-number">0xffffffff</span>)        # data <span class="hljs-built_in">seg</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">gdtdesc:</span><br><span class="hljs-meta">  .word</span>   <span class="hljs-number">0x17</span>                            # sizeof(gdt) - <span class="hljs-number">1</span><br><span class="hljs-meta">  .long</span>   gdt                             # address gdt<br></code></pre></td></tr></table></figure><p>其中 lgdt gdtdesc，把 gdtdesc 标识符的值送入全局映射描述符表 GDTR 中，CPU 的 GDTR中 保存了 gdt 的起始地址和 gdt 表的长，其中 GDTR 是一个位宽位 48 的寄存器，低 16 位表示该表的长度，高 32 表示该表在内存中的起始位置。gdtdesc 是一个标识符，其中前 2 个字节表示 gdt 表大小，后 4 个字节表示 gdt 表的内存中地址起始位置。</p><p>而 gdt 描述符分为了三个段，分别是 null seg、code seg、data seg，而 JOS 中是没有分段机制的，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是 0x0，大小都是 0xfffffffff &#x3D; 4GB。</p><p>其中 SEG() 函数我们可以在 mmu.h 中找到，它是一个宏函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Macros to build GDT entries in assembly.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEG_NULL\</span><br><span class="hljs-meta">.word 0, 0;\</span><br><span class="hljs-meta">.byte 0, 0, 0, 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEG(type,base,lim)\</span><br><span class="hljs-meta">.word (((lim) &gt;&gt; 12) &amp; 0xffff), ((base) &amp; 0xffff);\</span><br><span class="hljs-meta">.byte (((base) &gt;&gt; 16) &amp; 0xff), (0x90 | (type)),\</span><br><span class="hljs-meta">(0xC0 | (((lim) &gt;&gt; 28) &amp; 0xf)), (((base) &gt;&gt; 24) &amp; 0xff)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span><span class="hljs-comment">// not __ASSEMBLER__</span></span><br><br></code></pre></td></tr></table></figure></li></ul><p>其中函数参数优势按个，分别是 type 表示了访问权限，base 表示这个段的起始地址，lim 表示这个段的大小界限。</p><p> 完成上述步骤过后，就可以 call bootmain，这个时候将 kernel.img 从磁盘中读进来，然后就可以开始执行啦。</p><ul><li>引导加载程序执行 的最后一条指令是什么，它刚刚加载的内核的第一条指令是什么？</li></ul><p>最后一条指令是bootmain程序中的((void (*)(void)) (ELFHDR-&gt;e_entry))(); 即跳转到操作系统内核程序的起始指令处。</p><p>它刚刚加载的第一条指令是位于 kern&#x2F;entry.S 文件中的第一句，movw $0x1234,0x472</p><ul><li>内核的第一条指令在哪里？</li></ul><p>kern&#x2F;entry.S</p><ul><li>引导加载程序如何决定它必须读取多少个扇区才能从磁盘获取整个内核？它在哪里找到这些信息？</li></ul><p>引导加载程序读取操作系统文件 Program Header Table 中，这个表会描述整个内核占了几个扇区，需要读取多少个段才可以将内核加载进来；这些信息保存在 kernel.img 的ELF 头部信息当中</p><h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>​学习 boot&#x2F;main.c，在此之前需要学习 C 语言的指针，这个也是一个难点，同时需要学习 ELF 文件的格式，这样才能够继续阅读代码。</p><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h4><p>​要求：阅读 K&amp;R 中 5.1-5.5，学习 C 语言中指针和地址，然后下载 pointers.c 文件，运行它，并且搞懂那些值为什么会这样出现。其中该程序如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">16</span>);<br>    <span class="hljs-type">int</span> *c;<br>    <span class="hljs-type">int</span> i;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);<br><br>    c = a;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>a[i] = <span class="hljs-number">100</span> + i;<br>    c[<span class="hljs-number">0</span>] = <span class="hljs-number">200</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c[<span class="hljs-number">1</span>] = <span class="hljs-number">300</span>;<br>    *(c + <span class="hljs-number">2</span>) = <span class="hljs-number">301</span>;<br>    <span class="hljs-number">3</span>[c] = <span class="hljs-number">302</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c = c + <span class="hljs-number">1</span>;<br>    *c = <span class="hljs-number">400</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    c = (<span class="hljs-type">int</span> *) ((<span class="hljs-type">char</span> *) c + <span class="hljs-number">1</span>);<br>    *c = <span class="hljs-number">500</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5: a[0] = %d, a[1] = %d, a[2] = %d, a[3] = %d\n&quot;</span>,<br>   a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>]);<br><br>    b = (<span class="hljs-type">int</span> *) a + <span class="hljs-number">1</span>;<br>    c = (<span class="hljs-type">int</span> *) ((<span class="hljs-type">char</span> *) a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6: a = %p, b = %p, c = %p\n&quot;</span>, a, b, c);<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> ac, <span class="hljs-type">char</span> **av)</span><br>&#123;<br>    f();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​编译并执行所得结果如下所示，结果分析：</p><p>​学习完 CSAPP 咱们都应该知道，指针是指向某个内存地址的一个标识，而且指针也是具有不同的类型的，C 语言提供了访问指针地址的操作，同样提供了访问该地址位置的值的操作，指针操作是会改变该内存地址的值的，因此，不论多少指针或者说指针张啥样，只要修改其中任何一个指针的值，则其他指向该地址的指针的值都会改变，因此我们可以知道：</p><p>​a、b、c均是指向int类型的指针，不同点是 a 是采用数组的方式直接静态分配了内存，其大小为 4*4 字节，并且 a 执行数组的起始地址即 a[0]；b 采用动态 malloc 的方式分配了 16 个字节的 void 类型地址，并且 b 指向这块内存的起始地址；c 只是命名了一个空指针，其单纯指向一个地址，没有大小或者说指针自身大小即根据多少位机子判断，其指向内存中的某个 int 的地址；我们也应该知道 int 是 4 个字节，指针大小和计算机位数有关，如 64-bits 的是 8 字节，32-bits 是 4 字节；</p><p>​c &#x3D; a 让 c 和 a 同时指向了一块儿数组内存地址的起始地址，所以 c 和 a 就没有任何区别了就；</p><p>​第二行结果中，先循环修改了 a 的内容，然后修改 c[0] 中的值，由于 c 和 a 指向同一内存地址，因此 a[0] 的值改变；</p><p>第三行结果中，由于c进行了修改，c和a相同，那么a的值也进行了改变，只是说访问内存的方式不同罢了，其中几种访问都是一次内存增加int个字节大小；</p><p>第四次结果中，只改变了 c[1] 的值，因此和第三次比较只进行了 c[1] 的改变；</p><p>​第五次结果中，先是将 c[1] 通过 char 指针增长 1 个字节，访问 c[2] 的前 1 个字节，再将其转换成了 int 类型，因此目前 c 指向 int* a[1] 的后 3 个字节，同时起内存长度是 4 个字节，因此当前 c 指向的内存的末尾是 a[2] 的前 1 个字节的尾巴，再让 *c &#x3D; 500 的时候，a[1]、a[2] 的值都进行了改变；</p><p>​第六次结果中，我们可以通过地址的大小发现，刚好验证了第五次中结果为啥是这样。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-20-59.png" alt="pointer.c results"></p><h4 id="ELF-kernel-img"><a href="#ELF-kernel-img" class="headerlink" title="ELF kernel.img"></a>ELF kernel.img</h4><p>​单独列了一个标题为 ELF 的文件，主要是为了好好学习 ELF，这个部分有一些复杂的信息，需要进行记录和积累。<a href="./elf.pdf">点击可下载elf.pdf</a></p><p>​在 6.828 中，可以将 ELF 文件看作是一个带有固定的 header 的可执行代码文件，其中代码被分成了不同的段包含了 code、data 等等，这些地址是在文件中定义好了的而boot loader 不会定义这些地址，这些东西可以根据描述的地址加载进内存直接进行执行。</p><p>​一个 ELF 二进制文件中，包含一个指定长度的头部，候面跟了几个代码块，这些个代码块可以分为程序和数据，可以在 inc&#x2F;elf.h 中看到如下结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> JOS_INC_ELF_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JOS_INC_ELF_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_MAGIC 0x464C457FU<span class="hljs-comment">/* &quot;\x7FELF&quot; in little endian */</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Elf</span> &#123;</span><br><span class="hljs-type">uint32_t</span> e_magic;<span class="hljs-comment">// must equal ELF_MAGIC</span><br><span class="hljs-type">uint8_t</span> e_elf[<span class="hljs-number">12</span>];<br><span class="hljs-type">uint16_t</span> e_type;<br><span class="hljs-type">uint16_t</span> e_machine;<br><span class="hljs-type">uint32_t</span> e_version;<br><span class="hljs-type">uint32_t</span> e_entry;<br><span class="hljs-type">uint32_t</span> e_phoff;<br><span class="hljs-type">uint32_t</span> e_shoff;<br><span class="hljs-type">uint32_t</span> e_flags;<br><span class="hljs-type">uint16_t</span> e_ehsize;<br><span class="hljs-type">uint16_t</span> e_phentsize;<br><span class="hljs-type">uint16_t</span> e_phnum;<br><span class="hljs-type">uint16_t</span> e_shentsize;<br><span class="hljs-type">uint16_t</span> e_shnum;<br><span class="hljs-type">uint16_t</span> e_shstrndx;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proghdr</span> &#123;</span><br><span class="hljs-type">uint32_t</span> p_type;<br><span class="hljs-type">uint32_t</span> p_offset;<br><span class="hljs-type">uint32_t</span> p_va;<br><span class="hljs-type">uint32_t</span> p_pa;<br><span class="hljs-type">uint32_t</span> p_filesz;<br><span class="hljs-type">uint32_t</span> p_memsz;<br><span class="hljs-type">uint32_t</span> p_flags;<br><span class="hljs-type">uint32_t</span> p_align;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Secthdr</span> &#123;</span><br><span class="hljs-type">uint32_t</span> sh_name;<br><span class="hljs-type">uint32_t</span> sh_type;<br><span class="hljs-type">uint32_t</span> sh_flags;<br><span class="hljs-type">uint32_t</span> sh_addr;<br><span class="hljs-type">uint32_t</span> sh_offset;<br><span class="hljs-type">uint32_t</span> sh_size;<br><span class="hljs-type">uint32_t</span> sh_link;<br><span class="hljs-type">uint32_t</span> sh_info;<br><span class="hljs-type">uint32_t</span> sh_addralign;<br><span class="hljs-type">uint32_t</span> sh_entsize;<br>&#125;;<br><br><span class="hljs-comment">// Values for Proghdr::p_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_LOAD1</span><br><br><span class="hljs-comment">// Flag bits for Proghdr::p_flags</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_EXEC1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_WRITE2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_PROG_FLAG_READ4</span><br><br><span class="hljs-comment">// Values for Secthdr::sh_type</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_NULL0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_PROGBITS1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_SYMTAB2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHT_STRTAB3</span><br><br><span class="hljs-comment">// Values for Secthdr::sh_name</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF_SHN_UNDEF0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* !JOS_INC_ELF_H */</span></span><br></code></pre></td></tr></table></figure><p>​program section中我们关注以下几个部分：</p><ul><li><p>.text：程序可执行指令；</p></li><li><p>.rodata：只读数据；</p></li><li><p>.data：data section 包含了已经初始话的数据，比如全局变量 int x  &#x3D; 5；</p></li><li><p>.bss ： 存放未初始化的变量， 但是在ELF中只需要记录 .bss 的起始地址和长度。Loader and  program 必须自己将 .bss 段清零</p></li></ul><p>我们可以通过<code>objdump -h obj/kern/kernel</code>来查看所有的名字和地址范围：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-26-57.png" alt="kernel headers"></p><p>​在 JOS 中我们只关注上述的几个段，有一些我们需要特别关注的，比如 VMA（link address）、LMA（load addres），其中 LMA 就是程序运行的时候加载到内存中的位置，VMA 的话比较复杂，主要是用来添加或者执行一些共享的库之类的，在 JOS 中没有使用该段。</p><p>​我们同样可以通过<code>objdump -h obj/boot/boot.out</code>来查看 boot loader .text区域：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-25-21.png" alt="boot.out header"></p><p>​我们可以看到其 LMA 的地址和 VMA 的地址都是 0x7c00，这个和我们之前看到的 BIOS 启动跳转的地址相同。</p><p>​同理，我们可以通过 <code>objdump -x obj/kern/kernel</code> 来查看整个kernel的header信息等。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-28-30.png" alt="kernel header all"></p><p>​我们可以看到 LOAD 中的需要加载到内存中的区域，vaddr 是虚拟地址、paddr 是物理地址、加载区域大小 filesz&#x2F;memsz，在 boot&#x2F;main.c 中，ph-&gt;p_pa 每个程序头的字段都包含段的目标物理地址。BIOS 将引导扇区加载到内存中，从 0x7c00 开始，因此这是引导扇区的起始地址，由于这个地址也是引导扇区执行的地方，所以它也是链接地址，我们设置连接地址 <code>-Ttext 0x7c00</code> 到链接器 boot&#x2F;Makefrag，链接器将产生正确的代码地址。</p><h4 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h4><p>​要求：先跟踪部分 boot loader 中的一小部分步骤，然后修改 boot&#x2F;Makefrag 中的链接地址，查看其行为。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#</span><br><span class="hljs-comment"># Makefile fragment for the JOS kernel.</span><br><span class="hljs-comment"># This is NOT a complete makefile;</span><br><span class="hljs-comment"># you must run GNU make in the top-level directory</span><br><span class="hljs-comment"># where the GNUmakefile is located.</span><br><span class="hljs-comment">#</span><br><br>OBJDIRS += boot<br><br>BOOT_OBJS := <span class="hljs-variable">$(OBJDIR)</span>/boot/boot.o <span class="hljs-variable">$(OBJDIR)</span>/boot/main.o<br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/%.o: boot/%.c<br>@echo + cc -Os <span class="hljs-variable">$&lt;</span><br>@mkdir -p $(@D)<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(CC)</span> -nostdinc <span class="hljs-variable">$(KERN_CFLAGS)</span> -Os -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/%.o: boot/%.S<br>@echo + as <span class="hljs-variable">$&lt;</span><br>@mkdir -p $(@D)<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(CC)</span> -nostdinc <span class="hljs-variable">$(KERN_CFLAGS)</span> -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/main.o: boot/main.c<br>@echo + cc -Os <span class="hljs-variable">$&lt;</span><br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(CC)</span> -nostdinc <span class="hljs-variable">$(KERN_CFLAGS)</span> -Os -c -o <span class="hljs-variable">$(OBJDIR)</span>/boot/main.o boot/main.c<br><br><span class="hljs-variable">$(OBJDIR)</span>/boot/boot: <span class="hljs-variable">$(BOOT_OBJS)</span><br>@echo + ld boot/boot<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(LD)</span> <span class="hljs-variable">$(LDFLAGS)</span> -N -e start -Ttext 0x7C00 -o <span class="hljs-variable">$@</span>.out <span class="hljs-variable">$^</span><br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(OBJDUMP)</span> -S <span class="hljs-variable">$@</span>.out &gt;<span class="hljs-variable">$@</span>.asm<br><span class="hljs-variable">$(V)</span><span class="hljs-variable">$(OBJCOPY)</span> -S -O binary -j .text <span class="hljs-variable">$@</span>.out <span class="hljs-variable">$@</span><br><span class="hljs-variable">$(V)</span>perl boot/sign.pl <span class="hljs-variable">$(OBJDIR)</span>/boot/boot<br></code></pre></td></tr></table></figure><p>​我们可以看到，通过编译生成了 boot&#x2F; 文件夹下的内容，并且在最后根据地址进行链接，我们尝试修改 0x7c00 为错误的地址 0x7000，看会如何执行；</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-32-41.png" alt="0x7000 error"></p><p>​我们可以看到在这个情况下边儿，由于 boot loader 加载地址，无法正常启动，导致 BIOS 不断重启去寻找可以启动的盘，此时的 qemu 就陷入了死循环，当我们把地址改为正确的时候，则可以正常启动，不过得执行命令 make clean 再重新编译。</p><h4 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h4><p>​要求：使用 GDB 中 x 命令来检测地址，其中 x&#x2F;Nx ADDR 命令打印从 ADDR 开始的 N 个字的地址。测试 0x00100000 地址开始的 8 个字的内存，然后再引导程序进入内核时再次检查，他们为什么不同？第二个断点有什么？</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-37-22.png" alt="x/Nx ADDR"></p><p>​我们知道在 ELF 头中保存了一个叫做 e_entry 的字段，该字段中保存了程序中入口点的地址，也就是 kernel 的入口地址，我们根据要求查看进入内核前后的该处地址情况，发现在运行内核过后，内存 0x0010000 中加载了内核的代码地址。</p><h2 id="Part-3：The-Kernel"><a href="#Part-3：The-Kernel" class="headerlink" title="Part 3：The Kernel"></a>Part 3：The Kernel</h2><p>​第三个部分我们开始研究内核，在将内核加载到内存中，并且根据 e_entry 字段进入内核代码过后，CPU 流水开始执行 kernel，JOS 运行了起来。</p><h3 id="虚拟内存解决位置依赖"><a href="#虚拟内存解决位置依赖" class="headerlink" title="虚拟内存解决位置依赖"></a>虚拟内存解决位置依赖</h3><p>​操作系统的内核通常被链接到非常高的虚拟地址如（0x00100000）下运行，以便留下处理器虚拟地址空间的低地址部分供用户程序使用。</p><p>​许多机子在地址范围无法到达 0xf0100000，因此我们不能在该处存储内核，我们可以使用处理器提供的内存管理硬件将虚拟地址 0xf0100000（内核代码期望云运行的链接地址）映射到物理地址 0x00100000（引导加载程序将内核加载到物理内存中）。</p><p>​我们目前不需要掌握细节，我们只需要知道可以通过 kern&#x2F;entrypgdir.c 中静态初始化的页面目录和页表来完成此操作，映射前 4M 的物理内存就可以启动并运行起来。在内存映射的过程中有一个非常重要的寄存器，cr0 控制寄存器，当我们在 kern&#x2F;entry.S 中设置 CR0_PG 标志位过后，内存映射打开，这个时候的虚拟地址被映射成了物理地址。此处我们开启了页机制，我们将虚拟地址 0xf0000000 到 0xffffffff 映射到 0x000000000到 0x0ffffffff。</p><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h4><p>​要求：使用GDB调试跟踪内核并且停止在 <code>movl %eax, %cr0</code> 部分，并且检测内存0x00100000 和 0xf0100000，并且单步跟踪 GDB，查看内存前后内容的差别。</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-41-51.png" alt="kernel.asm 指令地址"></p><p>​我们可以在 <code>obj/kern/kernel.asm</code> 反汇编得到的代码中看到，<code>movl %eax, %cr0</code> 的代码地址为 0xf0100020，因此我们在此处设置断点，并且观察前后cr0寄存器的行为和内容；出现一个小错误就是，这里的 0xf0100020 是虚拟地址，我们需要跟踪映射过后的实际的地址，而实际的映射规则正如前边儿提到的，因此我们设置的断点应该为 0x00100020；</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-45-13.png" alt="breakpoint"></p><p>​我们可以看到，在该命令执行之后，原本放在 0xf0100000 处的内容映射到了0x00100000 处，因为这两个地方的值完全一样。</p><p>​接下来我们将 <code>movl %eax, %cr0</code> 注释掉，查看会发生什么：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-46-49.png" alt="make qemu no %cr0"></p><p>​会发现，操作系统无法启动，这个时候由于没有开启页机制，kernel 的地址映射没有成功，从而超出了寻址范围，导致操作系统内核无法启动，修改回去可以成功启动。</p><h3 id="格式化输出到控制台"><a href="#格式化输出到控制台" class="headerlink" title="格式化输出到控制台"></a>格式化输出到控制台</h3><p>​这个小节主要是为了说明，操作系统中是没有 printf() 这种函数的，我们需要去写一个可以输出到界面的比如 vga 的输出，并且封装来供使用，比如当前的 kernel 中就提供了三个和输出相关的文件 kern&#x2F;printf.c，lib&#x2F;printfmt.c 和 kern&#x2F;console.c，我们需要学习这三个咋搞起来的还有他们之间的关系。</p><h4 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h4><p>​要求：在printfmt.c中省略了打印八进制数的格式，%o的格式选项，需要我们进行补充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// (unsigned) octal</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br><span class="hljs-comment">// Replace this with your code.</span><br><span class="hljs-comment">//putch(&#x27;X&#x27;, putdat);</span><br><span class="hljs-comment">//putch(&#x27;X&#x27;, putdat);</span><br><span class="hljs-comment">//putch(&#x27;X&#x27;, putdat);</span><br><span class="hljs-comment">//</span><br>num = getint(&amp;ap,lflag);<br><span class="hljs-keyword">if</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)num &lt;<span class="hljs-number">0</span>)&#123;<br>putch(<span class="hljs-string">&#x27;-&#x27;</span>,putdat);<br>num = -(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) num;<br>&#125;<br><br>base = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">goto</span> number;<br><br></code></pre></td></tr></table></figure><p>​这个还行，只需要照着前边儿的 10 进制进行复制就好了，基本没有难度，补充完毕就ok，接下来是回答一堆问题：</p><ul><li>1、解释 printf.c 和 console.c 之间的接口，尤其是 console.c 导出了什么函数，printf.c 如何使用这些函数？</li></ul><p>printf.c 使用了 console.c 的 cputchar() 函数，通过直接调用该函数完成输出到vga 上；同时 printf.c 也使用 printfmt.c 中包装过的 console.c 中的函数，这样便于格式化的输出到屏幕上。</p><ul><li>2、解释console.c中的一段儿程序：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// What is the purpose of this?</span><br><span class="hljs-keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;<br><span class="hljs-type">int</span> i;<br><br>memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">uint16_t</span>));<br><span class="hljs-keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)<br>crt_buf[i] = <span class="hljs-number">0x0700</span> | <span class="hljs-string">&#x27; &#x27;</span>;<br>crt_pos -= CRT_COLS;<br>&#125;<br></code></pre></td></tr></table></figure><p>​由于当前的输出是到 VGA 显示，这个地方是检测 ctr_pos 指针施否超出了 CTR 的范围，如果超出了，则需要对超出部分的显示缓存内容清零，并且对 ctr_pos 进行重新设置回到该位置。</p><ul><li>3、跟踪下边儿的一段儿代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span>, z = <span class="hljs-number">4</span>;<br>cprintf(<span class="hljs-string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);<br></code></pre></td></tr></table></figure><p>​cprintf()，fmt指向什么？ap又指向什么？</p><p>​这一段儿代码我们可以考虑插入到内核的任何位置，为了便于跟踪，我们可以考虑到加入的内核的初始化的地方 <code>kern/init.c</code>，因此我们加入过后进行跟踪：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">i386_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> edata[], end[];<br><br><span class="hljs-comment">// Before doing anything else, complete the ELF loading process.</span><br><span class="hljs-comment">// Clear the uninitialized global data (BSS) section of our program.</span><br><span class="hljs-comment">// This ensures that all static/global variables start out zero.</span><br><span class="hljs-built_in">memset</span>(edata, <span class="hljs-number">0</span>, end - edata);<br><br><span class="hljs-comment">// Initialize the console.</span><br><span class="hljs-comment">// Can&#x27;t call cprintf until after we do this!</span><br>cons_init();<br><br>cprintf(<span class="hljs-string">&quot;6828 decimal is %o octal!\n&quot;</span>, <span class="hljs-number">6828</span>);<br><br><span class="hljs-comment">// Lab 1 exercise 8</span><br>&#123;<br><span class="hljs-comment">// Trace the execution of the following code step-by-step</span><br><br>Lab1_exercise8_3:<br>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">3</span>, z = <span class="hljs-number">4</span>;<br>cprintf(<span class="hljs-string">&quot;x %d, y %d, z %d\n&quot;</span>,x, y, z);<br>&#125;<br><br>Lab1_exercise8_4:<br>&#123;<br><span class="hljs-comment">// Run the following code</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br>cprintf(<span class="hljs-string">&quot;H%x Wo%s\n&quot;</span>,<span class="hljs-number">57616</span>, &amp;i);<br>&#125;<br>Lab1_exercise8_5:<br>&#123;<br><span class="hljs-comment">// y = ?</span><br>cprintf(<span class="hljs-string">&quot;x=%d y=%d\n&quot;</span>,<span class="hljs-number">3</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Test the stack backtrace function (lab 1 only)</span><br>test_backtrace(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// Drop into the kernel monitor.</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>monitor(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​我们在<code>obj/kern.kernel.asm</code> 中找到添加的代码的位置，打上断点进行跟踪，具体方法和前边儿的调试方法相同，于是得到以下结果：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-21-59-53.png" alt="init"></p><p>​单步运行，跟踪每个 call 中 cons_putc,va_arg 和 vcprintf，对于 cons_putc 列出参数，对于 va_arg，列出 ap 在调用前后分别指向什么，对于 vcprintf 列出参数和值</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-00-29.png" alt="printfmt.c"></p><p>​其他的也类似挨着跟踪一下就好了，可以看到调用链和每次传入的值。对于其中的可变参数的实现，我们可以在 inc&#x2F;stdarg.h 中找到，为什么可以实现可变参数主要原因是因为函数的参数压栈是从左到右依次进栈的，然后根据这个规则进行取就好了。</p><ul><li>4、运行下边儿的代码，查看结果是什么：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br>   cprintf(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br></code></pre></td></tr></table></figure><p>​结果是：hell0，World，这个地方的输出跟ASCII码有关，凑成了 hell0 world</p><ul><li>5、下边儿的代码，y后边儿会输出什么？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">cprintf(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>​y 后边儿跟了一个未知的数</p><ul><li>6、GCC改变调用的时候参数压栈顺序，如何修改 cprintf() 函数可以让他输出可变个数的参数？</li></ul><p>如果是从右往左进行压栈，我们可以考虑传进去一个参数个数的值，然后我们获取参数的从末尾开始拿就好了</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>​我们最后来研究一下 X86 上的 C 语言栈，我们会实现一个 backtrace 的函数，来对栈内的参数和 IP 信息等进行打印出来。</p><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a>Exercise 9</h4><p>​要求：判断内核在哪个地方初始化的栈，并且判断栈在内存中的位置，内核是如何为栈保存空间的？并且在这个保留区域的 “end” 是堆栈指针最初指向的位置嘛？</p><p>栈的初始化，最先是在 boot loader 中，然后在进入内核过后，内核也对栈进行了重新初始化。​entry.S 中初始化的，然后初始化的时候我去调用 kernel.asm 文件，然后观察栈的大小啥的：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-05-44.png" alt="entry.S"></p><p>在 memlayout.h 和 mmu.h 中可以找到内核栈的相关情况，理论上只要是空闲的物理地址都可以作为栈，JOS 对栈的定义在 memlayout.h 中：</p><ul><li>内核在 entry.S 中进行栈的重新初始化</li><li>栈在内存中的位置，KSTACKTOP：KERNBASE（0xF0000000）</li><li>内核为栈预留 KSTKIZE（8*PGSIZE，PGSIZE&#x3D;4096） 的空间</li></ul><h4 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h4><p>​要求：为了熟悉 X86 中 C 调用约定，test_backtrace 在 obj&#x2F;kern&#x2F;kernel.asm 中找到函数地址，在那里设置一个断点，然后检查内核启动后每次调用它会发生什么。每个递归嵌套级别的 test_backtrace 推入堆栈的32位字是多少，这些字是什么？</p><p>首先，我们再次熟悉x86栈的约定是长什么样：</p><p><img src="https://imgs.bencorn.com/imgs/2021/08/12/+08000812150935.png" alt="x86 堆栈结构"></p><p>​每个栈帧中保存了上述的信息，其中，<code>%esp</code> 寄存器始终指向栈顶，并且每一次入栈的时候，<code>%esp</code> 的减少，在 32-bit 模式下，堆栈只能保存 32-bit 的值，并且 <code>%esp</code> 总是可以被 4 整除。</p><p>​<code>%ebp</code> 寄存器，基址寄存器，每一次函数调用压栈的时候，将 <code>%esp</code> 的值保存到 <code>%ebp</code>中，每一次都这样按照这个约定，这样的话每次取 <code>%ebp</code> 的上一次的值就可以拿到栈的调用链。</p><h4 id="Exercise-11"><a href="#Exercise-11" class="headerlink" title="Exercise 11"></a>Exercise 11</h4><p>​于是基于上述 exercise 10 中堆栈的描述约定的方式，我们可以进行栈的跟踪打印，实现方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Your code here.</span><br><span class="hljs-comment">// Lab 1 exercise 9</span><br><br><span class="hljs-type">uint32_t</span> ebp,*p,eip; <br>ebp = read_ebp();<br><br>cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br><span class="hljs-keyword">while</span>(ebp != <span class="hljs-number">0</span>)&#123;<br>p = (<span class="hljs-type">uint32_t</span>*) ebp;<br>eip = p[<span class="hljs-number">1</span>];<br>cprintf(<span class="hljs-string">&quot;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, ebp, eip, p[<span class="hljs-number">2</span>], p[<span class="hljs-number">3</span>], p[<span class="hljs-number">4</span>], p[<span class="hljs-number">5</span>], p[<span class="hljs-number">6</span>]);<br>ebp = p[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​然后将其添加到内核的 cmd 中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Command</span> <span class="hljs-title">commands</span>[] =</span> &#123;<br>&#123; <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;Display this list of commands&quot;</span>, mon_help &#125;,<br>&#123; <span class="hljs-string">&quot;kerninfo&quot;</span>, <span class="hljs-string">&quot;Display information about the kernel&quot;</span>, mon_kerninfo &#125;,<br>&#123; <span class="hljs-string">&quot;backtrace&quot;</span>,<span class="hljs-string">&quot;Display the stack backtrace info&quot;</span>,mon_backtrace&#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>​此时，我们就可以在内核启动的时候，调用 <code>backtrace</code> 完成堆栈跟踪展示信息了就。</p><h4 id="Exercise-12"><a href="#Exercise-12" class="headerlink" title="Exercise 12"></a>Exercise 12</h4><p>​要求：打印 debug info 出来，利用 eip，在 kern&#x2F;kdebug.c 中完成检测；并且完成 stab_binsearch 取寻找一个地址的行号编号，然后添加 debuginfo_eip 到mon_backtrace 中，然后查看施否能够打印出来；</p><p>​先手动完成命令行的查看，然后编写二分搜索，阅读给出的 stab_binsearch 函数，按照二分的模板写吧和算法相同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Search within [lline, rline] for the line number stab.</span><br>      <span class="hljs-comment">// If found, set info-&gt;eip_line to the right line number.</span><br>      <span class="hljs-comment">// If not found, return -1.</span><br>      <span class="hljs-comment">//</span><br>      <span class="hljs-comment">// Hint:</span><br>      <span class="hljs-comment">//      There&#x27;s a particular stabs type used for line numbers.</span><br>      <span class="hljs-comment">//      Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span><br>      <span class="hljs-comment">//      which one.</span><br>      <span class="hljs-comment">// Your code here.</span><br><br>      stab_binsearch(stabs,&amp;lline,&amp;rline,N_SLINE,addr);<br>      <span class="hljs-keyword">if</span>(lline &lt;= rline)&#123;<br>              info-&gt;eip_line = stabs[lline].n_desc;<br>      &#125;<br>      <span class="hljs-keyword">else</span>&#123;<br>              cprintf(<span class="hljs-string">&quot;line not find\n&quot;</span>);<br>              <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>​然后就是在 mon_backtrace 中添加：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mon_backtrace</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv, <span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br><span class="hljs-comment">// Your code here.</span><br><span class="hljs-comment">// Lab 1 exercise 9</span><br><br><span class="hljs-type">uint32_t</span> ebp,*p,eip; <br>ebp = read_ebp();<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Eipdebuginfo</span> <span class="hljs-title">info</span>;</span><br><br>cprintf(<span class="hljs-string">&quot;Stack backtrace:\n&quot;</span>);<br><span class="hljs-keyword">while</span>(ebp != <span class="hljs-number">0</span>)&#123;<br><br>p = (<span class="hljs-type">uint32_t</span>*) ebp;<br>eip = p[<span class="hljs-number">1</span>];<br>cprintf(<span class="hljs-string">&quot;ebp %08x  eip %08x  args %08x %08x %08x %08x %08x\n&quot;</span>, ebp, eip, p[<span class="hljs-number">2</span>], p[<span class="hljs-number">3</span>], p[<span class="hljs-number">4</span>], p[<span class="hljs-number">5</span>], p[<span class="hljs-number">6</span>]);<br><br><span class="hljs-type">int</span> c = debuginfo_eip(eip,&amp;info);<br><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-type">int</span> fn_offset = eip - info.eip_fn_addr;<br>cprintf(<span class="hljs-string">&quot;%s:%d: %.*s+%d\n&quot;</span>, info.eip_file, info.eip_line, info.eip_fn_namelen, info.eip_fn_name, fn_offset);<br>&#125;<br><br>ebp = p[<span class="hljs-number">0</span>];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>​然后尝试 make grade 一下，完结撒花完成整个实验：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-34-46.png" alt="tests OK"></p><p>​至此 Lab1 完结撒花。</p><p>补充一个点儿，有可能在 grade 的时候会失败，具体原因是由于 qemu 的执行结果重定向到 jos.out 文件过后，可能会有换行问题，导致 Python 的grade 脚本匹配失败，如：</p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-32-35.png" alt="grade fail"></p><p><img src="https://imgs.bencorn.com/imgs/Lab1-Booting-a-PC-2023-04-29-22-34-24.png" alt="缺少回车"></p><p>解决方法就是在 6828 前边儿加个回车符号，满足脚本儿要求。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.828/2018Fall</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828/2018Fall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab syscall System calls</title>
    <link href="/2021/03/30/Lab-syscall-System-calls/"/>
    <url>/2021/03/30/Lab-syscall-System-calls/</url>
    
    <content type="html"><![CDATA[<h3 id="Lab-2-System-Call"><a href="#Lab-2-System-Call" class="headerlink" title="Lab 2 System Call"></a>Lab 2 System Call</h3><p>​lab2 总算是跌跌撞撞做完了，其实思路不难，但就是会发生一些意想不到的错误，就包括了 PPT 中提到的指针问题，把我卡了一天f**k；然后内存那个地方误打误撞还做出来了，思路找wyy提示了一下，总而言之还是对页表部分理解不够深刻吧可能</p><p>​学习网站：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a></p><h4 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h4><p>​要求实现一个调用跟踪的 trace，其中有一个地方我一开始没理解到 mask 是干嘛的（原文： You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. ），卡了2天（英语不够，google来凑）；</p><h5 id="1、修改-Makefile"><a href="#1、修改-Makefile" class="headerlink" title="1、修改 Makefile"></a>1、修改 Makefile</h5><p>​add $U&#x2F;_trace\</p><h5 id="2、添加-syscall"><a href="#2、添加-syscall" class="headerlink" title="2、添加 syscall"></a>2、添加 syscall</h5><p>​add a prototype for the system call to <code>user/user.h</code>, a stub to <code>user/usys.pl</code>, and a syscall number to <code>kernel/syscall.h</code>. The Makefile invokes the perl script <code>user/usys.pl</code>, which produces <code>user/usys.S</code>, the actual system call stubs, which use the RISC-V <code>ecall</code> instruction to transition to the kernel. </p><h5 id="3、添加-sys-trace-函数-kernel-x2F-sysproc-c"><a href="#3、添加-sys-trace-函数-kernel-x2F-sysproc-c" class="headerlink" title="3、添加 sys_trace()函数 kernel&#x2F;sysproc.c"></a>3、添加 sys_trace()函数 kernel&#x2F;sysproc.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab2 trace</span><br>uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-keyword">if</span> (argint(<span class="hljs-number">0</span>,&amp;n)&lt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    p-&gt;mask = n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、修改-fork-函数-kernel-x2F-proc-c"><a href="#4、修改-fork-函数-kernel-x2F-proc-c" class="headerlink" title="4、修改 fork 函数 kernel&#x2F;proc.c"></a>4、修改 fork 函数 kernel&#x2F;proc.c</h5><p>​以防万一，修改的时候mask还是上锁了，mask 其实是每个 process 的 private 信息应该，但是上锁无伤大雅感觉，就放到了release前边儿</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  np-&gt;parent = p;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  np-&gt;state = RUNNABLE;<br><br>  <span class="hljs-comment">// lab2 get the trace mask from parent</span><br>  np-&gt;mask = p-&gt;mask;<br><br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、添加trace输出"><a href="#5、添加trace输出" class="headerlink" title="5、添加trace输出"></a>5、添加trace输出</h5><p>​提前准备好映射的名字，因为输出的时候需要（You will need to add an array of syscall names to index into.），然后积极犯错，忘记如何定义二维数组的信息了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *syscall_names[] = &#123;<br>        [SYS_fork]    <span class="hljs-string">&quot;fork&quot;</span>,<br>        [SYS_exit]    <span class="hljs-string">&quot;exit&quot;</span>,<br>        [SYS_wait]    <span class="hljs-string">&quot;wait&quot;</span>,<br>        [SYS_pipe]    <span class="hljs-string">&quot;pipe&quot;</span>,<br>        [SYS_read]    <span class="hljs-string">&quot;read&quot;</span>,<br>        [SYS_kill]    <span class="hljs-string">&quot;kill&quot;</span>,<br>        [SYS_exec]    <span class="hljs-string">&quot;exec&quot;</span>,<br>        [SYS_fstat]   <span class="hljs-string">&quot;fstat&quot;</span>,<br>        [SYS_chdir]   <span class="hljs-string">&quot;chdir&quot;</span>,<br>        [SYS_dup]     <span class="hljs-string">&quot;dup&quot;</span>,<br>        [SYS_getpid]  <span class="hljs-string">&quot;getpid&quot;</span>,<br>        [SYS_sbrk]    <span class="hljs-string">&quot;sbrk&quot;</span>,<br>        [SYS_sleep]   <span class="hljs-string">&quot;sleep&quot;</span>,<br>        [SYS_uptime]  <span class="hljs-string">&quot;uptime&quot;</span>,<br>        [SYS_open]    <span class="hljs-string">&quot;open&quot;</span>,<br>        [SYS_write]   <span class="hljs-string">&quot;write&quot;</span>,<br>        [SYS_mknod]   <span class="hljs-string">&quot;mknod&quot;</span>,<br>        [SYS_unlink]  <span class="hljs-string">&quot;unlink&quot;</span>,<br>        [SYS_link]    <span class="hljs-string">&quot;link&quot;</span>,<br>        [SYS_mkdir]   <span class="hljs-string">&quot;mkdir&quot;</span>,<br>        [SYS_close]   <span class="hljs-string">&quot;close&quot;</span>,<br>        [SYS_trace]   <span class="hljs-string">&quot;trace&quot;</span>,<br>        [SYS_sysinfo] <span class="hljs-string">&quot;sysinfo&quot;</span>,<br>&#125;;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>    <span class="hljs-comment">// num syscall numbers store in the register a7</span><br>    num = p-&gt;trapframe-&gt;a7;<br>    <span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>        p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>               p-&gt;pid, p-&gt;name, num);<br>        p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// trace the syscall</span><br>    <span class="hljs-keyword">if</span> (((<span class="hljs-number">1</span> &lt;&lt; num) &amp; p-&gt;mask) &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);<br>&#125;<br></code></pre></td></tr></table></figure><p>​到这里 trace 就完成了，解决之前的疑惑，mask 和 num 两个的关系，在开头的英语中说的是，如果返回的 mask 和调用 num 在mask 中，也就是那个mask &#x3D; 1 &lt;&lt; num ，ok搞定</p><h4 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h4><p>​这个实验着实让人伤脑筋一开始，主要是没认真 xv6 这书，书上说了 defs.h 中定义了各个模块的接口，然而一开始没看见，所以老是不知道怎么把要加的两个函数加入到新函数中，老是出现未定义的错误提示</p><h5 id="1、添加基本的调用信息"><a href="#1、添加基本的调用信息" class="headerlink" title="1、添加基本的调用信息"></a>1、添加基本的调用信息</h5><p>​和 trace 中的步骤一样，每个地方都要填</p><h5 id="2、kernel-x2F-kalloc-c"><a href="#2、kernel-x2F-kalloc-c" class="headerlink" title="2、kernel&#x2F;kalloc.c"></a>2、kernel&#x2F;kalloc.c</h5><p>​遍历 freelist ，把所有的 page 求和就好了，这里我一开始很meng不知道怎么办，后来问了问wyy逻辑关系，一下子就明朗了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab2</span><br>uint64<br><span class="hljs-title function_">collect_free_memory</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    uint64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span>* <span class="hljs-title">r</span>;</span><br>    acquire(&amp;kmem.lock);<br>    r = kmem.freelist;<br>    <span class="hljs-keyword">while</span> (r) &#123;<br>        res += PGSIZE;<br>        r = r-&gt;next;<br>    &#125;<br>    release(&amp;kmem.lock);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、kernel-x2F-proc-c"><a href="#3、kernel-x2F-proc-c" class="headerlink" title="3、kernel&#x2F;proc.c"></a>3、kernel&#x2F;proc.c</h5><p>​这里的 p-&gt;state 在 proc.h 中有要求上锁，所以要小心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//lab2</span><br>uint64<br><span class="hljs-title function_">collect_process_number</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    uint64 n = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    <span class="hljs-keyword">for</span> (p = proc;p  &lt; &amp;proc[NPROC];p++) &#123;<br>        acquire(&amp;p-&gt;lock);<br>        <span class="hljs-keyword">if</span> (p-&gt;state != UNUSED)&#123;<br>            n += <span class="hljs-number">1</span>;<br>        &#125;<br>        release(&amp;p-&gt;lock);<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、kernel-x2F-sysproc-c"><a href="#4、kernel-x2F-sysproc-c" class="headerlink" title="4、kernel&#x2F;sysproc.c"></a>4、kernel&#x2F;sysproc.c</h5><p>​这里一开始我犯的错误，是开了一个 sysinfo 的指针，然后将 info-&gt;freemem &#x3D; collect_free_memory()，然后返回的地址是一个未知的地址，指针指向的是一个 uint64 的地址，根本不是值，f**k一天过去了原来如此，太菜了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// lab2 sys_info</span><br>uint64<br><span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br><br>    uint64 addr;<br><span class="hljs-comment">//   wrong answer</span><br><span class="hljs-comment">//   struct sysinfo* info;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br>    <span class="hljs-keyword">if</span> (argaddr(<span class="hljs-number">0</span>,&amp;addr)&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>    info.freemem= collect_free_memory();<br>    info.nproc = collect_process_number();<br><br>    <span class="hljs-keyword">if</span> (copyout(p-&gt;pagetable,addr,(<span class="hljs-type">char</span>*)&amp;info,<span class="hljs-keyword">sizeof</span>(info))&lt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​到此就两个实验结束了，赶紧学习下一个鸭得，不然得失业了要，下一个实验很有意思，是关于页表的。</p>]]></content>
    
    
    <categories>
      
      <category>6.s081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lab util Unix utilities</title>
    <link href="/2021/03/21/Lab-util-Unix-utilities/"/>
    <url>/2021/03/21/Lab-util-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<p>​ucore写了以后算是对操作系统有一个初步的认识，ucore 既然也是参照 xv6 来的，那何尝不尝试一下这个呢，而且这个课程可以对标更多的其他课程，坑也会少很多的样子，抓紧时间学习吧；</p><p>​先说一下整体的步骤：</p><p><code>因为有了 OS 基础、而不是第一次学习 OS，所以就比较快了可能，但是会发现让自己去独立的写一个.c文件而不是像ucore那样去填空还是有点儿吃力的</code></p><p>​1、看xv6电子书要求章节，看PPT，看说明</p><p>​2、看每个实验要求要看的源码</p><p>​3、写lab、debug</p><p>​4、不会的地方先查资料，再不会看学长代码提供的思路，最终独立敲一遍</p><p>​课程网页：<a href="https://pdos.csail.mit.edu/6.828/2020/index.html">https://pdos.csail.mit.edu/6.828/2020/index.html</a></p><h3 id="Lab-Util"><a href="#Lab-Util" class="headerlink" title="Lab Util"></a>Lab Util</h3><p>​正式开始之前，得搭建好实验环境，选择国内镜像站最好选择 ustc 的，貌似其他的几个镜像站 Ubuntu 20.04 有的安装包没进行缓存或者丢弃了（eg. qemu的部分组建）</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>​这个部分要求写一个用户态程序，然后理解用户态是如何通过 system call 调用内核代码的；记录踩坑经历，include 部分的每个顺序是有要求的，去查看三个头文件会发现会有依赖关系，如果顺序错了会造成编译失败，至于为啥请查询 C 语法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// order is important</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span><br>&#123;<br><span class="hljs-keyword">if</span>(argc&lt;<span class="hljs-number">2</span>)&#123;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Sleep Error: Argument is Needed...\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> n = atoi(argv[<span class="hljs-number">1</span>]);<br>sleep(n);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h4><p>​通过管道实现两个进程之间的通讯，子进程向父进程写一个字节，父进程也向子进程写一个字节，分别起两个管道就好了；我是直接输出字符串，没进行检测，想的是如果出错的化 read 会阻塞啥的，逻辑正确就没管了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// order is important</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> p1[<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> p2[<span class="hljs-number">2</span>];<br>pipe(p1);<br>pipe(p2);<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// fd[0] read end,fd[1] write end</span><br><br><span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>write(p2[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">1</span>);<br>close(p2[<span class="hljs-number">0</span>]);<br><br>read(p1[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>,getpid());<br>close(p1[<span class="hljs-number">1</span>]);<br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>write(p1[<span class="hljs-number">1</span>],<span class="hljs-string">&quot;f&quot;</span>,<span class="hljs-number">1</span>);<br>close(p1[<span class="hljs-number">0</span>]);<br>wait(<span class="hljs-number">0</span>);<br><br>read(p2[<span class="hljs-number">0</span>],buf,<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received pong\n&quot;</span>,getpid());<br>close(p2[<span class="hljs-number">1</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h4><p>​通过管道，实现一个流水线，也就是CSP模型的管道解（<a href="http://swtch.com/~rsc/thread/%EF%BC%89%EF%BC%8C%E5%8D%A1%E4%BA%86%E5%BE%88%E4%B9%85%E5%BE%88%E4%B9%85%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%B8%8D%E4%BC%9A%E5%86%99%E2%80%9C%E5%85%B1%E4%BA%AB%E2%80%9D%EF%BC%88%E8%BF%99%E9%87%8C%E7%9A%84%E5%85%B1%E4%BA%AB%E6%84%8F%E6%80%9D%E6%98%AF%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E9%83%BD%E4%BC%9A%E6%89%A7%E8%A1%8C%E7%9A%84%E7%9B%B8%E5%90%8C%E4%BB%A3%E7%A0%81%EF%BC%89%E9%83%A8%E5%88%86%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%8F%AA%E4%BC%9A%E5%86%99%E6%B5%81%E6%B0%B4%E7%BA%BF%E9%95%BF%E5%BA%A6%E4%B8%BA">http://swtch.com/~rsc/thread/），卡了很久很久，因为不会写“共享”（这里的共享意思是每个进程都会执行的相同代码）部分的代码，只会写流水线长度为</a> 2 的情况，想了很久想到用 goto 可以，而且书上给了一个 dup 的例子来进行文件描述符的控制，这样就避免了题干中提到的坑了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/// order is important</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">redict</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[])</span> &#123;<br>    close(<span class="hljs-number">0</span>);<br>    close(fd[<span class="hljs-number">1</span>]);<br>    dup(fd[<span class="hljs-number">0</span>]);<br>    close(fd[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>];<br>    pipe(fd);<br><br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>        redict(fd);<br><br>        <span class="hljs-type">int</span> buf, n, x, fd1[<span class="hljs-number">2</span>];<br>        lable:<br>        <span class="hljs-keyword">if</span> ((n = read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &lt;= <span class="hljs-number">0</span> || buf &lt;= <span class="hljs-number">0</span>)) &#123;<br>            close(<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;prime %d\n&quot;</span>, buf);<br>        x = buf;<br><br>        pipe(fd1);<br><br>        <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>            redict(fd1);<br>            <span class="hljs-keyword">goto</span> lable;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (buf % x != <span class="hljs-number">0</span>) &#123;<br>                write(fd1[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>            &#125;<br>        &#125;<br>        close(<span class="hljs-number">0</span>);<br>        close(fd1[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">35</span>; i++) &#123;<br>            write(fd[<span class="hljs-number">1</span>], &amp;i, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>        &#125;<br>        close(fd[<span class="hljs-number">1</span>]);<br>        wait(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>​find这个主要是引入了几个结构体和函数，需要仔细的阅读 ls.c 文件来弄懂每个函数是干什么的，然后才可以进行代码否则的话就会一直卡着；其实递归还好拉，就检测当前文件夹下边儿读到的一个stat结构体类型，如果是文件就判断名字是否相同，如果是文件夹就递归下去就好了（.和..的情况不进行递归），微光招新题也有一道类似的，实现copy函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *filepath, <span class="hljs-type">char</span> *filename)</span> &#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(filepath, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, filepath);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, filepath);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.type != T_DIR) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot find file %s in filepath %s\n&quot;</span>, filename, filepath);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(filepath) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">strcpy</span>(buf, filepath);<br>    p = buf + <span class="hljs-built_in">strlen</span>(buf);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de)) &#123;<br>        <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>)==<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">switch</span> (st.type) &#123;<br>            <span class="hljs-keyword">case</span> T_FILE:<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(p, filename) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> T_DIR:<br>                find(buf, filename);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><span class="hljs-comment">//        close(fd);</span><br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find error: need at least two arguments &#x27;filepath&#x27; and &#x27;filename&#x27;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>​这道题我一开始没理解到题目意思，我以为要写一个和 unix 一模一样的出来，一下子给我整懵了，当时也不是不可以写，但是仔细读题干发现要求完全不同好吧，xargs  后边儿执行的内容除了 exe_args  的以外，其他的是从标准输入进行输入的，那这样就好写很多阿，保存好 xargs 后边儿执行的命令，默认每次执行一次，只需要吧前边儿的内容嵌近来就 ok</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xargs error: need at least 2 arguments\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/// To get the xargs command args</span><br>    <span class="hljs-comment">/// We need not to make the optimizations for xargs -n 1 echo line the fot the choice -n 1</span><br>    <span class="hljs-comment">/// its always -n 1 for this lab</span><br>    <span class="hljs-type">char</span> *exec_args[MAXARG];<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; ++i) &#123;<br>        exec_args[cnt] = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br>        memmove(exec_args[cnt], argv[i], <span class="hljs-built_in">strlen</span>(argv[i]));<br>        cnt++;<br>    &#125;<br><br>    exec_args[cnt] = (<span class="hljs-type">char</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> len = read(<span class="hljs-number">0</span>, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-built_in">memset</span>(exec_args[cnt], <span class="hljs-number">0</span>, <span class="hljs-number">20</span>);<br>            memmove(exec_args[cnt], buf + start, i - start);<br>            exec_args[cnt + <span class="hljs-number">1</span>] = (<span class="hljs-type">char</span> *) <span class="hljs-number">0</span>;<br>            start = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>                exec(*exec_args, exec_args);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><p>​写一个time.txt的文件，里边儿写好完成实验花的时间，那每天2小时，一周完成14h吧差不多，太菜了我还是，呜呜呜～～</p><p>​make grade 总算完成了，还是最简单的实验了应该是，下周lab1哇</p>]]></content>
    
    
    <categories>
      
      <category>6.s081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.s081</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BlogByHexo</title>
    <link href="/2020/11/09/BlogByHexo/"/>
    <url>/2020/11/09/BlogByHexo/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo-折腾日记"><a href="#Hexo-折腾日记" class="headerlink" title="Hexo  折腾日记"></a>Hexo  折腾日记</h1><p>​网上有很多的教程，这里记录一下我的折腾，然后达到自己想要的效果都做了什么</p><ul><li>环境 Ubuntu 20.04，Git</li><li>参考链接：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></li></ul><h1 id="安装-nodejs、npm、git"><a href="#安装-nodejs、npm、git" class="headerlink" title="安装 nodejs、npm、git"></a>安装 nodejs、npm、git</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nodejs<br>sudo apt install npm<br>sudo apt install git<br></code></pre></td></tr></table></figure><h1 id="起一个名为-blog-的文件夹，在该文件夹里边儿起-Hexo"><a href="#起一个名为-blog-的文件夹，在该文件夹里边儿起-Hexo" class="headerlink" title="起一个名为 blog 的文件夹，在该文件夹里边儿起 Hexo"></a>起一个名为 blog 的文件夹，在该文件夹里边儿起 Hexo</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> blog<br><span class="hljs-built_in">cd</span> blog<br>sudo npm install -g hexo-cli<br>hexo init<br>npm install <span class="hljs-comment"># 安装必要的plugin</span><br></code></pre></td></tr></table></figure><h1 id="config-yml-配置，下面是我修改了的部分"><a href="#config-yml-配置，下面是我修改了的部分" class="headerlink" title="_config.yml 配置，下面是我修改了的部分"></a>_config.yml 配置，下面是我修改了的部分</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Site</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Bencorn</span><br><span class="hljs-attr">subtitle:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-attr">keywords:</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">shuisong</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-comment"># URL</span><br><span class="hljs-comment">## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://blog.bencorn.com</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br><span class="hljs-attr">permalink_defaults:</span><br><span class="hljs-attr">pretty_urls:</span><br>  <span class="hljs-attr">trailing_index:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br>  <span class="hljs-attr">trailing_html:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br>  <br><span class="hljs-comment"># Pagination</span><br><span class="hljs-comment">## Set per_page to 0 to disable pagination</span><br><span class="hljs-attr">per_page:</span> <span class="hljs-number">12</span><br><span class="hljs-attr">pagination_dir:</span> <span class="hljs-string">page</span><br><br><span class="hljs-comment"># Extensions</span><br><span class="hljs-comment">## Plugins: https://hexo.io/plugins/</span><br><span class="hljs-comment">## Themes: https://hexo.io/themes/</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">Chic</span><br><br><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">https://github.com/shatanyumi/shatanyumi.github.io</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><h1 id="安装-Hexo-git-插件，添加远程-github-仓库"><a href="#安装-Hexo-git-插件，添加远程-github-仓库" class="headerlink" title="安装 Hexo git 插件，添加远程 github 仓库"></a>安装 Hexo git 插件，添加远程 github 仓库</h1><ul><li>参考：<a href="https://hexo.io/zh-cn/docs/github-pages">https://hexo.io/zh-cn/docs/github-pages</a></li><li>仓库命名：‘你的github名’ .github.io</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br>git config --global user.name shatanyumi<br>git config --global user.email 1143005768@qq.com<br>ssh-keygen -t rsa -C 1143005768@qq.com<br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br><span class="hljs-comment"># 复制该内容到github的persoal access token</span><br>ssh git@github.com<br><span class="hljs-comment"># 出现下图表示配置好了</span><br></code></pre></td></tr></table></figure><p><img src="https://imgs.bencorn.com/imgs/2021/08/03/+08000803191648.png" alt="git 图片"></p><h1 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h1><p>​在不修改任何 _config.yml 的情况下，执行目录为 blog&#x2F;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo s<br><span class="hljs-comment"># ctrl + 鼠标点击 （或者输入localhost:4000）</span><br></code></pre></td></tr></table></figure><p>​在不修改 theme 的情况下，其他的如上修改 github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">heoxo c<br>hexo g<br>hexo d<br><span class="hljs-comment"># 访问 shatanyumi.github.io(自己的修改一下即可)</span><br></code></pre></td></tr></table></figure><h1 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h1><ul><li><p>如果有计网知识的，请参考：<a href="https://juejin.im/post/6844903634161909767#heading-33">https://juejin.im/post/6844903634161909767#heading-33</a></p></li><li><p>注意必须在 source 下，添加 CNAME 文件，里边儿放网站的域名</p></li><li><p>然后，在 github 的该仓库下 domina 添加域名</p></li></ul><h1 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h1><ul><li><p>操作位置：blog&#x2F;themes&#x2F;</p></li><li><p>个人使用的是 Chic 主题：<a href="https://github.com/Siricee/hexo-theme-Chic">https://github.com/Siricee/hexo-theme-Chic</a></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> themes<br>git <span class="hljs-built_in">clone</span> https://github.com/Siricee/hexo-theme-Chic.git Chic<br><span class="hljs-comment"># 修改如前边儿说的.yml文件 theme: Chic</span><br></code></pre></td></tr></table></figure><ul><li>然后照着人家给出来的 DIY 文档，修改自己喜欢的就好了</li></ul><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><ul><li>因为hexo是靠yml来组织的，使用之前得好好看一下官方文档，然后在写</li><li>注意：操作目录 blog&#x2F;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page tag<br>hexo new page about<br>hexo new page categories<br></code></pre></td></tr></table></figure><ul><li>编辑 tag、categories、about，下边儿给出 tag 的 front-matter ，添加 layout：tag，about不用添加</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">title:</span> <span class="hljs-string">tag</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">tag</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-11-09 00:09:51</span><br><span class="hljs-string">______________________________________________________________________________________________________________________________</span><br></code></pre></td></tr></table></figure><p>然后写文章的时候，front-matter注意添加就好了</p>]]></content>
    
    
    <categories>
      
      <category>tool</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tool</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
